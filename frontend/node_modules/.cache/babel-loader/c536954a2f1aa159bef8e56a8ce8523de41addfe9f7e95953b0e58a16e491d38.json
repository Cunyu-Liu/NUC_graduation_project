{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport { ref, onMounted, watch, onBeforeUnmount, computed, unref, watchEffect } from 'vue';\nimport { offset, flip, shift, arrow, autoUpdate, detectOverflow, computePosition } from '@floating-ui/dom';\nimport { isString, isFunction, isArray } from '@vue/shared';\nimport { isClient } from '@vueuse/core';\nimport { keysOf } from '../../../utils/objects.mjs';\nconst useTarget = (target, open, gap, mergedMask, scrollIntoViewOptions) => {\n  const posInfo = ref(null);\n  const getTargetEl = () => {\n    let targetEl;\n    if (isString(target.value)) {\n      targetEl = document.querySelector(target.value);\n    } else if (isFunction(target.value)) {\n      targetEl = target.value();\n    } else {\n      targetEl = target.value;\n    }\n    return targetEl;\n  };\n  const updatePosInfo = () => {\n    const targetEl = getTargetEl();\n    if (!targetEl || !open.value) {\n      posInfo.value = null;\n      return;\n    }\n    if (!isInViewPort(targetEl)) {\n      targetEl.scrollIntoView(scrollIntoViewOptions.value);\n    }\n    const {\n      left,\n      top,\n      width,\n      height\n    } = targetEl.getBoundingClientRect();\n    posInfo.value = {\n      left,\n      top,\n      width,\n      height,\n      radius: 0\n    };\n  };\n  onMounted(() => {\n    watch([open, target], () => {\n      updatePosInfo();\n    }, {\n      immediate: true\n    });\n    window.addEventListener(\"resize\", updatePosInfo);\n  });\n  onBeforeUnmount(() => {\n    window.removeEventListener(\"resize\", updatePosInfo);\n  });\n  const getGapOffset = index => {\n    var _a;\n    return (_a = isArray(gap.value.offset) ? gap.value.offset[index] : gap.value.offset) != null ? _a : 6;\n  };\n  const mergedPosInfo = computed(() => {\n    var _a;\n    if (!posInfo.value) return posInfo.value;\n    const gapOffsetX = getGapOffset(0);\n    const gapOffsetY = getGapOffset(1);\n    const gapRadius = ((_a = gap.value) == null ? void 0 : _a.radius) || 2;\n    return {\n      left: posInfo.value.left - gapOffsetX,\n      top: posInfo.value.top - gapOffsetY,\n      width: posInfo.value.width + gapOffsetX * 2,\n      height: posInfo.value.height + gapOffsetY * 2,\n      radius: gapRadius\n    };\n  });\n  const triggerTarget = computed(() => {\n    const targetEl = getTargetEl();\n    if (!mergedMask.value || !targetEl || !window.DOMRect) {\n      return targetEl || void 0;\n    }\n    return {\n      getBoundingClientRect() {\n        var _a, _b, _c, _d;\n        return window.DOMRect.fromRect({\n          width: ((_a = mergedPosInfo.value) == null ? void 0 : _a.width) || 0,\n          height: ((_b = mergedPosInfo.value) == null ? void 0 : _b.height) || 0,\n          x: ((_c = mergedPosInfo.value) == null ? void 0 : _c.left) || 0,\n          y: ((_d = mergedPosInfo.value) == null ? void 0 : _d.top) || 0\n        });\n      }\n    };\n  });\n  return {\n    mergedPosInfo,\n    triggerTarget\n  };\n};\nconst tourKey = Symbol(\"ElTour\");\nfunction isInViewPort(element) {\n  const viewWidth = window.innerWidth || document.documentElement.clientWidth;\n  const viewHeight = window.innerHeight || document.documentElement.clientHeight;\n  const {\n    top,\n    right,\n    bottom,\n    left\n  } = element.getBoundingClientRect();\n  return top >= 0 && left >= 0 && right <= viewWidth && bottom <= viewHeight;\n}\nconst useFloating = (referenceRef, contentRef, arrowRef, placement, strategy, offset$1, zIndex, showArrow) => {\n  const x = ref();\n  const y = ref();\n  const middlewareData = ref({});\n  const states = {\n    x,\n    y,\n    placement,\n    strategy,\n    middlewareData\n  };\n  const middleware = computed(() => {\n    const _middleware = [offset(unref(offset$1)), flip(), shift(), overflowMiddleware()];\n    if (unref(showArrow) && unref(arrowRef)) {\n      _middleware.push(arrow({\n        element: unref(arrowRef)\n      }));\n    }\n    return _middleware;\n  });\n  const update = async () => {\n    if (!isClient) return;\n    const referenceEl = unref(referenceRef);\n    const contentEl = unref(contentRef);\n    if (!referenceEl || !contentEl) return;\n    const data = await computePosition(referenceEl, contentEl, {\n      placement: unref(placement),\n      strategy: unref(strategy),\n      middleware: unref(middleware)\n    });\n    keysOf(states).forEach(key => {\n      states[key].value = data[key];\n    });\n  };\n  const contentStyle = computed(() => {\n    if (!unref(referenceRef)) {\n      return {\n        position: \"fixed\",\n        top: \"50%\",\n        left: \"50%\",\n        transform: \"translate3d(-50%, -50%, 0)\",\n        maxWidth: \"100vw\",\n        zIndex: unref(zIndex)\n      };\n    }\n    const {\n      overflow\n    } = unref(middlewareData);\n    return {\n      position: unref(strategy),\n      zIndex: unref(zIndex),\n      top: unref(y) != null ? `${unref(y)}px` : \"\",\n      left: unref(x) != null ? `${unref(x)}px` : \"\",\n      maxWidth: (overflow == null ? void 0 : overflow.maxWidth) ? `${overflow == null ? void 0 : overflow.maxWidth}px` : \"\"\n    };\n  });\n  const arrowStyle = computed(() => {\n    if (!unref(showArrow)) return {};\n    const {\n      arrow: arrow2\n    } = unref(middlewareData);\n    return {\n      left: (arrow2 == null ? void 0 : arrow2.x) != null ? `${arrow2 == null ? void 0 : arrow2.x}px` : \"\",\n      top: (arrow2 == null ? void 0 : arrow2.y) != null ? `${arrow2 == null ? void 0 : arrow2.y}px` : \"\"\n    };\n  });\n  let cleanup;\n  onMounted(() => {\n    const referenceEl = unref(referenceRef);\n    const contentEl = unref(contentRef);\n    if (referenceEl && contentEl) {\n      cleanup = autoUpdate(referenceEl, contentEl, update);\n    }\n    watchEffect(() => {\n      update();\n    });\n  });\n  onBeforeUnmount(() => {\n    cleanup && cleanup();\n  });\n  return {\n    update,\n    contentStyle,\n    arrowStyle\n  };\n};\nconst overflowMiddleware = () => {\n  return {\n    name: \"overflow\",\n    async fn(state) {\n      const overflow = await detectOverflow(state);\n      let overWidth = 0;\n      if (overflow.left > 0) overWidth = overflow.left;\n      if (overflow.right > 0) overWidth = overflow.right;\n      const floatingWidth = state.rects.floating.width;\n      return {\n        data: {\n          maxWidth: floatingWidth - overWidth\n        }\n      };\n    }\n  };\n};\nexport { tourKey, useFloating, useTarget };","map":{"version":3,"names":["useTarget","target","open","gap","mergedMask","scrollIntoViewOptions","posInfo","ref","getTargetEl","targetEl","isString","value","document","querySelector","isFunction","updatePosInfo","isInViewPort","scrollIntoView","left","top","width","height","getBoundingClientRect","radius","onMounted","watch","immediate","window","addEventListener","onBeforeUnmount","removeEventListener","getGapOffset","index","_a","isArray","offset","mergedPosInfo","computed","gapOffsetX","gapOffsetY","gapRadius","triggerTarget","DOMRect","_b","_c","_d","fromRect","x","y","tourKey","Symbol","element","viewWidth","innerWidth","documentElement","clientWidth","viewHeight","innerHeight","clientHeight","right","bottom","useFloating","referenceRef","contentRef","arrowRef","placement","strategy","offset$1","zIndex","showArrow","middlewareData","states","middleware","_middleware","unref","flip","shift","overflowMiddleware","push","arrow","update","isClient","referenceEl","contentEl","data","computePosition","keysOf","forEach","key","contentStyle","position","transform","maxWidth","overflow","arrowStyle","arrow2","cleanup","autoUpdate","watchEffect","name","fn","state","detectOverflow","overWidth","floatingWidth","rects","floating"],"sources":["../../../../../../packages/components/tour/src/helper.ts"],"sourcesContent":["import {\n  computed,\n  onBeforeUnmount,\n  onMounted,\n  ref,\n  unref,\n  watch,\n  watchEffect,\n} from 'vue'\nimport {\n  arrow,\n  autoUpdate,\n  computePosition,\n  detectOverflow,\n  flip,\n  offset as offsetMiddleware,\n  shift,\n} from '@floating-ui/dom'\nimport {\n  isArray,\n  isClient,\n  isFunction,\n  isString,\n  keysOf,\n} from '@element-plus/utils'\n\nimport type {\n  CSSProperties,\n  Component,\n  InjectionKey,\n  Ref,\n  SetupContext,\n} from 'vue'\nimport type { UseNamespaceReturn } from '@element-plus/hooks'\nimport type { PosInfo, TourGap, TourMask } from './types'\nimport type {\n  ComputePositionReturn,\n  Middleware,\n  Placement,\n  Strategy,\n  VirtualElement,\n} from '@floating-ui/dom'\nimport type { TourStepProps } from './step'\n\nexport const useTarget = (\n  target: Ref<\n    string | HTMLElement | (() => HTMLElement | null) | null | undefined\n  >,\n  open: Ref<boolean>,\n  gap: Ref<TourGap>,\n  mergedMask: Ref<TourMask>,\n  scrollIntoViewOptions: Ref<boolean | ScrollIntoViewOptions>\n) => {\n  const posInfo: Ref<PosInfo | null> = ref(null)\n\n  const getTargetEl = () => {\n    let targetEl: HTMLElement | null | undefined\n    if (isString(target.value)) {\n      targetEl = document.querySelector<HTMLElement>(target.value)\n    } else if (isFunction(target.value)) {\n      targetEl = target.value()\n    } else {\n      targetEl = target.value\n    }\n    return targetEl\n  }\n\n  const updatePosInfo = () => {\n    const targetEl = getTargetEl()\n    if (!targetEl || !open.value) {\n      posInfo.value = null\n      return\n    }\n    if (!isInViewPort(targetEl)) {\n      targetEl.scrollIntoView(scrollIntoViewOptions.value)\n    }\n    const { left, top, width, height } = targetEl.getBoundingClientRect()\n    posInfo.value = {\n      left,\n      top,\n      width,\n      height,\n      radius: 0,\n    }\n  }\n\n  onMounted(() => {\n    watch(\n      [open, target],\n      () => {\n        updatePosInfo()\n      },\n      {\n        immediate: true,\n      }\n    )\n    window.addEventListener('resize', updatePosInfo)\n  })\n\n  onBeforeUnmount(() => {\n    window.removeEventListener('resize', updatePosInfo)\n  })\n\n  const getGapOffset = (index: number) =>\n    (isArray(gap.value.offset) ? gap.value.offset[index] : gap.value.offset) ??\n    6\n\n  const mergedPosInfo = computed(() => {\n    if (!posInfo.value) return posInfo.value\n\n    const gapOffsetX = getGapOffset(0)\n    const gapOffsetY = getGapOffset(1)\n    const gapRadius = gap.value?.radius || 2\n\n    return {\n      left: posInfo.value.left - gapOffsetX,\n      top: posInfo.value.top - gapOffsetY,\n      width: posInfo.value.width + gapOffsetX * 2,\n      height: posInfo.value.height + gapOffsetY * 2,\n      radius: gapRadius,\n    }\n  })\n\n  const triggerTarget = computed(() => {\n    const targetEl = getTargetEl()\n    if (!mergedMask.value || !targetEl || !window.DOMRect) {\n      return targetEl || undefined\n    }\n\n    return {\n      getBoundingClientRect() {\n        return window.DOMRect.fromRect({\n          width: mergedPosInfo.value?.width || 0,\n          height: mergedPosInfo.value?.height || 0,\n          x: mergedPosInfo.value?.left || 0,\n          y: mergedPosInfo.value?.top || 0,\n        })\n      },\n    }\n  })\n\n  return {\n    mergedPosInfo,\n    triggerTarget,\n  }\n}\n\nexport interface TourContext {\n  currentStep: Ref<TourStepProps | undefined>\n  current: Ref<number>\n  total: Ref<number>\n  showClose: Ref<boolean>\n  closeIcon: Ref<string | Component | undefined>\n  mergedType: Ref<'default' | 'primary' | undefined>\n  ns: UseNamespaceReturn\n  slots: SetupContext['slots']\n  updateModelValue(modelValue: boolean): void\n  onClose(): void\n  onFinish(): void\n  onChange(): void\n}\n\nexport const tourKey: InjectionKey<TourContext> = Symbol('ElTour')\n\nfunction isInViewPort(element: HTMLElement) {\n  const viewWidth = window.innerWidth || document.documentElement.clientWidth\n  const viewHeight = window.innerHeight || document.documentElement.clientHeight\n  const { top, right, bottom, left } = element.getBoundingClientRect()\n\n  return top >= 0 && left >= 0 && right <= viewWidth && bottom <= viewHeight\n}\n\nexport const useFloating = (\n  referenceRef: Ref<HTMLElement | VirtualElement | null>,\n  contentRef: Ref<HTMLElement | null>,\n  arrowRef: Ref<HTMLElement | null>,\n  placement: Ref<Placement | undefined>,\n  strategy: Ref<Strategy>,\n  offset: Ref<number>,\n  zIndex: Ref<number>,\n  showArrow: Ref<boolean>\n) => {\n  const x = ref<number>()\n  const y = ref<number>()\n  const middlewareData = ref<ComputePositionReturn['middlewareData']>({})\n\n  const states = {\n    x,\n    y,\n    placement,\n    strategy,\n    middlewareData,\n  } as const\n\n  const middleware = computed(() => {\n    const _middleware: Middleware[] = [\n      offsetMiddleware(unref(offset)),\n      flip(),\n      shift(),\n      overflowMiddleware(),\n    ]\n\n    if (unref(showArrow) && unref(arrowRef)) {\n      _middleware.push(\n        arrow({\n          element: unref(arrowRef)!,\n        })\n      )\n    }\n    return _middleware\n  })\n\n  const update = async () => {\n    if (!isClient) return\n\n    const referenceEl = unref(referenceRef)\n    const contentEl = unref(contentRef)\n    if (!referenceEl || !contentEl) return\n\n    const data = await computePosition(referenceEl, contentEl, {\n      placement: unref(placement),\n      strategy: unref(strategy),\n      middleware: unref(middleware),\n    })\n\n    keysOf(states).forEach((key) => {\n      states[key].value = data[key]\n    })\n  }\n\n  const contentStyle = computed<CSSProperties>(() => {\n    if (!unref(referenceRef)) {\n      return {\n        position: 'fixed',\n        top: '50%',\n        left: '50%',\n        transform: 'translate3d(-50%, -50%, 0)',\n        maxWidth: '100vw',\n        zIndex: unref(zIndex),\n      }\n    }\n\n    const { overflow } = unref(middlewareData)\n\n    return {\n      position: unref(strategy),\n      zIndex: unref(zIndex),\n      top: unref(y) != null ? `${unref(y)}px` : '',\n      left: unref(x) != null ? `${unref(x)}px` : '',\n      maxWidth: overflow?.maxWidth ? `${overflow?.maxWidth}px` : '',\n    }\n  })\n\n  const arrowStyle = computed<CSSProperties>(() => {\n    if (!unref(showArrow)) return {}\n\n    const { arrow } = unref(middlewareData)\n    return {\n      left: arrow?.x != null ? `${arrow?.x}px` : '',\n      top: arrow?.y != null ? `${arrow?.y}px` : '',\n    }\n  })\n\n  let cleanup: any\n  onMounted(() => {\n    const referenceEl = unref(referenceRef)\n    const contentEl = unref(contentRef)\n    if (referenceEl && contentEl) {\n      cleanup = autoUpdate(referenceEl, contentEl, update)\n    }\n\n    watchEffect(() => {\n      update()\n    })\n  })\n\n  onBeforeUnmount(() => {\n    cleanup && cleanup()\n  })\n\n  return {\n    update,\n    contentStyle,\n    arrowStyle,\n  }\n}\n\nconst overflowMiddleware = (): Middleware => {\n  return {\n    name: 'overflow',\n    async fn(state) {\n      const overflow = await detectOverflow(state)\n      let overWidth = 0\n      if (overflow.left > 0) overWidth = overflow.left\n      if (overflow.right > 0) overWidth = overflow.right\n      const floatingWidth = state.rects.floating.width\n      return {\n        data: {\n          maxWidth: floatingWidth - overWidth,\n        },\n      }\n    },\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}