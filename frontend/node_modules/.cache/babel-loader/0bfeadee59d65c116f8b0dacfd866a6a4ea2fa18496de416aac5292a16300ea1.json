{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\nimport { ref, computed, unref, watch } from 'vue';\nimport { isArray } from '@vue/shared';\nconst useData = (props, {\n  expandedRowKeys,\n  lastRenderedRowIndex,\n  resetAfterIndex\n}) => {\n  const depthMap = ref({});\n  const flattenedData = computed(() => {\n    const depths = {};\n    const {\n      data: data2,\n      rowKey\n    } = props;\n    const _expandedRowKeys = unref(expandedRowKeys);\n    if (!_expandedRowKeys || !_expandedRowKeys.length) return data2;\n    const array = [];\n    const keysSet = /* @__PURE__ */new Set();\n    _expandedRowKeys.forEach(x => keysSet.add(x));\n    let copy = data2.slice();\n    copy.forEach(x => depths[x[rowKey]] = 0);\n    while (copy.length > 0) {\n      const item = copy.shift();\n      array.push(item);\n      if (keysSet.has(item[rowKey]) && isArray(item.children) && item.children.length > 0) {\n        copy = [...item.children, ...copy];\n        item.children.forEach(child => depths[child[rowKey]] = depths[item[rowKey]] + 1);\n      }\n    }\n    depthMap.value = depths;\n    return array;\n  });\n  const data = computed(() => {\n    const {\n      data: data2,\n      expandColumnKey\n    } = props;\n    return expandColumnKey ? unref(flattenedData) : data2;\n  });\n  watch(data, (val, prev) => {\n    if (val !== prev) {\n      lastRenderedRowIndex.value = -1;\n      resetAfterIndex(0, true);\n    }\n  });\n  return {\n    data,\n    depthMap\n  };\n};\nexport { useData };","map":{"version":3,"names":["useData","props","expandedRowKeys","lastRenderedRowIndex","resetAfterIndex","depthMap","ref","flattenedData","computed","depths","data","data2","rowKey","_expandedRowKeys","unref","length","array","keysSet","Set","forEach","x","add","copy","slice","item","shift","push","has","isArray","children","child","value","expandColumnKey","watch","val","prev"],"sources":["../../../../../../../packages/components/table-v2/src/composables/use-data.ts"],"sourcesContent":["import { computed, ref, unref, watch } from 'vue'\nimport { isArray } from '@element-plus/utils'\n\nimport type { TableV2Props } from '../table'\nimport type { KeyType } from '../types'\nimport type { UseRowReturn } from './use-row'\n\ntype UseDataProps = {\n  expandedRowKeys: UseRowReturn['expandedRowKeys']\n  lastRenderedRowIndex: UseRowReturn['lastRenderedRowIndex']\n  resetAfterIndex: UseRowReturn['resetAfterIndex']\n}\n\nexport const useData = (\n  props: TableV2Props,\n  { expandedRowKeys, lastRenderedRowIndex, resetAfterIndex }: UseDataProps\n) => {\n  const depthMap = ref<Record<KeyType, number>>({})\n\n  const flattenedData = computed(() => {\n    const depths: Record<KeyType, number> = {}\n    const { data, rowKey } = props\n\n    const _expandedRowKeys = unref(expandedRowKeys)\n\n    if (!_expandedRowKeys || !_expandedRowKeys.length) return data\n\n    const array: any[] = []\n    const keysSet = new Set()\n    _expandedRowKeys.forEach((x) => keysSet.add(x))\n\n    let copy: any[] = data.slice()\n    copy.forEach((x) => (depths[x[rowKey]] = 0))\n    while (copy.length > 0) {\n      const item = copy.shift()!\n\n      array.push(item)\n      if (\n        keysSet.has(item[rowKey]) &&\n        isArray(item.children) &&\n        item.children.length > 0\n      ) {\n        copy = [...item.children, ...copy]\n        item.children.forEach(\n          (child: any) => (depths[child[rowKey]] = depths[item[rowKey]] + 1)\n        )\n      }\n    }\n\n    depthMap.value = depths\n    return array\n  })\n\n  const data = computed(() => {\n    const { data, expandColumnKey } = props\n    return expandColumnKey ? unref(flattenedData) : data\n  })\n\n  watch(data, (val, prev) => {\n    if (val !== prev) {\n      lastRenderedRowIndex.value = -1\n      resetAfterIndex(0, true)\n    }\n  })\n\n  return {\n    data,\n    depthMap,\n  }\n}\n\nexport type UseDataReturn = ReturnType<typeof useData>\n"],"mappings":";;;;;;;;;;;;AAaO,MAAMA,OAAA,GAAUA,CACrBC,KAAA,EACA;EAAEC,eAAiB;EAAAC,oBAAA;EAAsBC;AAAA,CACtC;EACG,MAAAC,QAAA,GAAWC,GAA6B,GAAE;EAE1C,MAAAC,aAAA,GAAgBC,QAAA,CAAS,MAAM;IACnC,MAAMC,MAAA,GAAkC,EAAC;IACzC,MAAM;MAAEC,IAAA,EAAAC,KAAM;MAAAC;IAAA,CAAW,GAAAX,KAAA;IAEnB,MAAAY,gBAAA,GAAmBC,KAAA,CAAMZ,eAAe;IAE1C,KAACW,gBAAoB,KAACA,gBAAiB,CAAAE,MAAA,EAAe,OAAAJ,KAAA;IAE1D,MAAMK,KAAA,GAAe,EAAC;IAChB,MAAAC,OAAA,sBAAcC,GAAI;IACxBL,gBAAA,CAAiBM,OAAA,CAASC,CAAA,IAAMH,OAAQ,CAAAI,GAAA,CAAID,CAAC,CAAC;IAE1C,IAAAE,IAAA,GAAcX,KAAA,CAAKY,KAAM;IAC7BD,IAAA,CAAKH,OAAA,CAASC,CAAA,IAAOX,MAAO,CAAAW,CAAA,CAAER,MAAA,KAAW,CAAE;IACpC,OAAAU,IAAA,CAAKP,MAAA,GAAS,CAAG;MAChB,MAAAS,IAAA,GAAOF,IAAA,CAAKG,KAAM;MAExBT,KAAA,CAAMU,IAAA,CAAKF,IAAI;MACf,IACEP,OAAQ,CAAAU,GAAA,CAAIH,IAAK,CAAAZ,MAAA,CAAO,CACxB,IAAAgB,OAAA,CAAQJ,IAAK,CAAAK,QAAQ,CACrB,IAAAL,IAAA,CAAKK,QAAS,CAAAd,MAAA,GAAS,CACvB;QACAO,IAAA,GAAO,CAAC,GAAGE,IAAK,CAAAK,QAAA,EAAU,GAAGP,IAAI;QACjCE,IAAA,CAAKK,QAAS,CAAAV,OAAA,CACXW,KAAgB,IAAArB,MAAA,CAAOqB,KAAA,CAAMlB,MAAW,KAAAH,MAAA,CAAOe,IAAA,CAAKZ,MAAW,OAClE;MAAA;IACF;IAGFP,QAAA,CAAS0B,KAAQ,GAAAtB,MAAA;IACV,OAAAO,KAAA;EAAA,CACR;EAEK,MAAAN,IAAA,GAAOF,QAAA,CAAS,MAAM;IAC1B,MAAM;MAAEE,IAAA,EAAAC,KAAM;MAAAqB;IAAA,CAAoB,GAAA/B,KAAA;IAC3B,OAAA+B,eAAA,GAAkBlB,KAAM,CAAAP,aAAa,CAAI,GAAAI,KAAA;EAAA,CACjD;EAEKsB,KAAA,CAAAvB,IAAA,EAAM,CAACwB,GAAA,EAAKC,IAAS;IACzB,IAAID,GAAA,KAAQC,IAAM;MAChBhC,oBAAA,CAAqB4B,KAAQ;MAC7B3B,eAAA,CAAgB,GAAG,IAAI;IAAA;EACzB,CACD;EAEM;IACLM,IAAA;IACAL;EAAA,CACF;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}