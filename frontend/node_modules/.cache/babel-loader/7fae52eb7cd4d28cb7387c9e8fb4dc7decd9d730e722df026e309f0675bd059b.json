{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { defineComponent, useSlots, ref, computed, watch, onMounted, provide, openBlock, createElementBlock, normalizeClass, unref, normalizeStyle, createCommentVNode, createElementVNode, renderSlot, nextTick } from 'vue';\nimport { useEventListener } from '@vueuse/core';\nimport { anchorProps, anchorEmits } from './anchor.mjs';\nimport { anchorKey } from './constants.mjs';\nimport _export_sfc from '../../../_virtual/plugin-vue_export-helper.mjs';\nimport { getElement } from '../../../utils/dom/element.mjs';\nimport { throttleByRaf } from '../../../utils/throttleByRaf.mjs';\nimport { getScrollElement, animateScrollTo, getScrollTop } from '../../../utils/dom/scroll.mjs';\nimport { getOffsetTopDistance } from '../../../utils/dom/position.mjs';\nimport { useNamespace } from '../../../hooks/use-namespace/index.mjs';\nimport { isWindow, isUndefined } from '../../../utils/types.mjs';\nimport { CHANGE_EVENT } from '../../../constants/event.mjs';\nconst _sfc_main = defineComponent({\n  ...{\n    name: \"ElAnchor\"\n  },\n  __name: \"anchor\",\n  props: anchorProps,\n  emits: anchorEmits,\n  setup(__props, {\n    expose: __expose,\n    emit: __emit\n  }) {\n    const props = __props;\n    const emit = __emit;\n    const slots = useSlots();\n    const currentAnchor = ref(\"\");\n    const markerStyle = ref({});\n    const anchorRef = ref(null);\n    const markerRef = ref(null);\n    const containerEl = ref();\n    const links = {};\n    let isScrolling = false;\n    let currentScrollTop = 0;\n    const ns = useNamespace(\"anchor\");\n    const cls = computed(() => [ns.b(), props.type === \"underline\" ? ns.m(\"underline\") : \"\", ns.m(props.direction)]);\n    const addLink = state => {\n      links[state.href] = state.el;\n    };\n    const removeLink = href => {\n      delete links[href];\n    };\n    const setCurrentAnchor = href => {\n      const activeHref = currentAnchor.value;\n      if (activeHref !== href) {\n        currentAnchor.value = href;\n        emit(CHANGE_EVENT, href);\n      }\n    };\n    let clearAnimate = null;\n    let currentTargetHref = \"\";\n    const scrollToAnchor = href => {\n      if (!containerEl.value) return;\n      const target = getElement(href);\n      if (!target) return;\n      if (clearAnimate) {\n        if (currentTargetHref === href) return;\n        clearAnimate();\n      }\n      currentTargetHref = href;\n      isScrolling = true;\n      const scrollEle = getScrollElement(target, containerEl.value);\n      const distance = getOffsetTopDistance(target, scrollEle);\n      const max = scrollEle.scrollHeight - scrollEle.clientHeight;\n      const to = Math.min(distance - props.offset, max);\n      clearAnimate = animateScrollTo(containerEl.value, currentScrollTop, to, props.duration, () => {\n        setTimeout(() => {\n          isScrolling = false;\n          currentTargetHref = \"\";\n        }, 20);\n      });\n    };\n    const scrollTo = href => {\n      if (href) {\n        setCurrentAnchor(href);\n        scrollToAnchor(href);\n      }\n    };\n    const handleClick = (e, href) => {\n      emit(\"click\", e, href);\n      scrollTo(href);\n    };\n    const handleScroll = throttleByRaf(() => {\n      if (containerEl.value) {\n        currentScrollTop = getScrollTop(containerEl.value);\n      }\n      const currentHref = getCurrentHref();\n      if (isScrolling || isUndefined(currentHref)) return;\n      setCurrentAnchor(currentHref);\n    });\n    const getCurrentHref = () => {\n      if (!containerEl.value) return;\n      const scrollTop = getScrollTop(containerEl.value);\n      const anchorTopList = [];\n      for (const href of Object.keys(links)) {\n        const target = getElement(href);\n        if (!target) continue;\n        const scrollEle = getScrollElement(target, containerEl.value);\n        const distance = getOffsetTopDistance(target, scrollEle);\n        anchorTopList.push({\n          top: distance - props.offset - props.bound,\n          href\n        });\n      }\n      anchorTopList.sort((prev, next) => prev.top - next.top);\n      for (let i = 0; i < anchorTopList.length; i++) {\n        const item = anchorTopList[i];\n        const next = anchorTopList[i + 1];\n        if (i === 0 && scrollTop === 0) {\n          return props.selectScrollTop ? item.href : \"\";\n        }\n        if (item.top <= scrollTop && (!next || next.top > scrollTop)) {\n          return item.href;\n        }\n      }\n    };\n    const getContainer = () => {\n      const el = getElement(props.container);\n      if (!el || isWindow(el)) {\n        containerEl.value = window;\n      } else {\n        containerEl.value = el;\n      }\n    };\n    useEventListener(containerEl, \"scroll\", handleScroll);\n    const updateMarkerStyle = () => {\n      nextTick(() => {\n        if (!anchorRef.value || !markerRef.value || !currentAnchor.value) {\n          markerStyle.value = {};\n          return;\n        }\n        const currentLinkEl = links[currentAnchor.value];\n        if (!currentLinkEl) {\n          markerStyle.value = {};\n          return;\n        }\n        const anchorRect = anchorRef.value.getBoundingClientRect();\n        const markerRect = markerRef.value.getBoundingClientRect();\n        const linkRect = currentLinkEl.getBoundingClientRect();\n        if (props.direction === \"horizontal\") {\n          const left = linkRect.left - anchorRect.left;\n          markerStyle.value = {\n            left: `${left}px`,\n            width: `${linkRect.width}px`,\n            opacity: 1\n          };\n        } else {\n          const top = linkRect.top - anchorRect.top + (linkRect.height - markerRect.height) / 2;\n          markerStyle.value = {\n            top: `${top}px`,\n            opacity: 1\n          };\n        }\n      });\n    };\n    watch(currentAnchor, updateMarkerStyle);\n    watch(() => {\n      var _a;\n      return (_a = slots.default) == null ? void 0 : _a.call(slots);\n    }, updateMarkerStyle);\n    onMounted(() => {\n      getContainer();\n      const hash = decodeURIComponent(window.location.hash);\n      const target = getElement(hash);\n      if (target) {\n        scrollTo(hash);\n      } else {\n        handleScroll();\n      }\n    });\n    watch(() => props.container, () => {\n      getContainer();\n    });\n    provide(anchorKey, {\n      ns,\n      direction: props.direction,\n      currentAnchor,\n      addLink,\n      removeLink,\n      handleClick\n    });\n    __expose({\n      scrollTo\n    });\n    return (_ctx, _cache) => {\n      return openBlock(), createElementBlock(\"div\", {\n        ref_key: \"anchorRef\",\n        ref: anchorRef,\n        class: normalizeClass(cls.value)\n      }, [_ctx.marker ? (openBlock(), createElementBlock(\"div\", {\n        key: 0,\n        ref_key: \"markerRef\",\n        ref: markerRef,\n        class: normalizeClass(unref(ns).e(\"marker\")),\n        style: normalizeStyle(markerStyle.value)\n      }, null, 6)) : createCommentVNode(\"v-if\", true), createElementVNode(\"div\", {\n        class: normalizeClass(unref(ns).e(\"list\"))\n      }, [renderSlot(_ctx.$slots, \"default\")], 2)], 2);\n    };\n  }\n});\nvar Anchor = /* @__PURE__ */_export_sfc(_sfc_main, [[\"__file\", \"/home/runner/work/element-plus/element-plus/packages/components/anchor/src/anchor.vue\"]]);\nexport { Anchor as default };","map":{"version":3,"names":["props","__props","emit","__emit","slots","useSlots","currentAnchor","ref","markerStyle","anchorRef","markerRef","containerEl","links","isScrolling","currentScrollTop","ns","useNamespace","cls","computed","b","type","m","direction","addLink","state","href","el","removeLink","setCurrentAnchor","activeHref","value","CHANGE_EVENT","clearAnimate","currentTargetHref","scrollToAnchor","target","getElement","scrollEle","getScrollElement","distance","getOffsetTopDistance","max","scrollHeight","clientHeight","to","Math","min","offset","animateScrollTo","duration","setTimeout","scrollTo","handleClick","e","handleScroll","throttleByRaf","getScrollTop","currentHref","getCurrentHref","isUndefined","scrollTop","anchorTopList","Object","keys","push","top","bound","sort","prev","next","i","length","item","selectScrollTop","getContainer","container","isWindow","window","useEventListener","updateMarkerStyle","nextTick","currentLinkEl","anchorRect","getBoundingClientRect","markerRect","linkRect","left","width","opacity","height","watch","_a","default","call","onMounted","hash","decodeURIComponent","location","provide","anchorKey","__expose","openBlock","createElementBlock","ref_key","class","normalizeClass","_ctx","marker","key","unref","style","normalizeStyle","createElementVNode","renderSlot","$slots"],"sources":["../../../../../../packages/components/anchor/src/anchor.vue"],"sourcesContent":["<template>\n  <div ref=\"anchorRef\" :class=\"cls\">\n    <div\n      v-if=\"marker\"\n      ref=\"markerRef\"\n      :class=\"ns.e('marker')\"\n      :style=\"markerStyle\"\n    />\n    <div :class=\"ns.e('list')\">\n      <slot />\n    </div>\n  </div>\n</template>\n\n<script lang=\"ts\" setup>\nimport {\n  computed,\n  nextTick,\n  onMounted,\n  provide,\n  ref,\n  useSlots,\n  watch,\n} from 'vue'\nimport { useEventListener } from '@vueuse/core'\nimport { useNamespace } from '@element-plus/hooks'\nimport {\n  animateScrollTo,\n  getElement,\n  getOffsetTopDistance,\n  getScrollElement,\n  getScrollTop,\n  isUndefined,\n  isWindow,\n  throttleByRaf,\n} from '@element-plus/utils'\nimport { CHANGE_EVENT } from '@element-plus/constants'\nimport { anchorEmits, anchorProps } from './anchor'\nimport { anchorKey } from './constants'\n\nimport type { CSSProperties } from 'vue'\nimport type { AnchorLinkState } from './constants'\n\ndefineOptions({\n  name: 'ElAnchor',\n})\n\nconst props = defineProps(anchorProps)\nconst emit = defineEmits(anchorEmits)\nconst slots = useSlots()\n\nconst currentAnchor = ref('')\nconst markerStyle = ref<CSSProperties>({})\nconst anchorRef = ref<HTMLElement | null>(null)\nconst markerRef = ref<HTMLElement | null>(null)\nconst containerEl = ref<HTMLElement | Window>()\n\nconst links: Record<string, HTMLElement> = {}\nlet isScrolling = false\nlet currentScrollTop = 0\n\nconst ns = useNamespace('anchor')\n\nconst cls = computed(() => [\n  ns.b(),\n  props.type === 'underline' ? ns.m('underline') : '',\n  ns.m(props.direction),\n])\n\nconst addLink = (state: AnchorLinkState) => {\n  links[state.href] = state.el\n}\n\nconst removeLink = (href: string) => {\n  delete links[href]\n}\n\nconst setCurrentAnchor = (href: string) => {\n  const activeHref = currentAnchor.value\n  if (activeHref !== href) {\n    currentAnchor.value = href\n    emit(CHANGE_EVENT, href)\n  }\n}\n\nlet clearAnimate: (() => void) | null = null\nlet currentTargetHref = ''\n\nconst scrollToAnchor = (href: string) => {\n  if (!containerEl.value) return\n  const target = getElement(href)\n  if (!target) return\n\n  if (clearAnimate) {\n    if (currentTargetHref === href) return\n    clearAnimate()\n  }\n\n  currentTargetHref = href\n  isScrolling = true\n  const scrollEle = getScrollElement(target, containerEl.value)\n  const distance = getOffsetTopDistance(target, scrollEle)\n  const max = scrollEle.scrollHeight - scrollEle.clientHeight\n  const to = Math.min(distance - props.offset, max)\n  clearAnimate = animateScrollTo(\n    containerEl.value,\n    currentScrollTop,\n    to,\n    props.duration,\n    () => {\n      // make sure it is executed after throttleByRaf's handleScroll\n      setTimeout(() => {\n        isScrolling = false\n        currentTargetHref = ''\n      }, 20)\n    }\n  )\n}\n\nconst scrollTo = (href?: string) => {\n  if (href) {\n    setCurrentAnchor(href)\n    scrollToAnchor(href)\n  }\n}\n\nconst handleClick = (e: MouseEvent, href?: string) => {\n  emit('click', e, href)\n  scrollTo(href)\n}\n\nconst handleScroll = throttleByRaf(() => {\n  if (containerEl.value) {\n    currentScrollTop = getScrollTop(containerEl.value)\n  }\n  const currentHref = getCurrentHref()\n  if (isScrolling || isUndefined(currentHref)) return\n  setCurrentAnchor(currentHref)\n})\n\nconst getCurrentHref = () => {\n  if (!containerEl.value) return\n  const scrollTop = getScrollTop(containerEl.value)\n  const anchorTopList: { top: number; href: string }[] = []\n\n  for (const href of Object.keys(links)) {\n    const target = getElement(href)\n    if (!target) continue\n    const scrollEle = getScrollElement(target, containerEl.value)\n    const distance = getOffsetTopDistance(target, scrollEle)\n    anchorTopList.push({\n      top: distance - props.offset - props.bound,\n      href,\n    })\n  }\n  anchorTopList.sort((prev, next) => prev.top - next.top)\n  for (let i = 0; i < anchorTopList.length; i++) {\n    const item = anchorTopList[i]\n    const next = anchorTopList[i + 1]\n\n    if (i === 0 && scrollTop === 0) {\n      return props.selectScrollTop ? item.href : ''\n    }\n    if (item.top <= scrollTop && (!next || next.top > scrollTop)) {\n      return item.href\n    }\n  }\n}\n\nconst getContainer = () => {\n  const el = getElement(props.container)\n  if (!el || isWindow(el)) {\n    containerEl.value = window\n  } else {\n    containerEl.value = el\n  }\n}\n\nuseEventListener(containerEl, 'scroll', handleScroll)\n\nconst updateMarkerStyle = () => {\n  nextTick(() => {\n    if (!anchorRef.value || !markerRef.value || !currentAnchor.value) {\n      markerStyle.value = {}\n      return\n    }\n    const currentLinkEl = links[currentAnchor.value]\n    if (!currentLinkEl) {\n      markerStyle.value = {}\n      return\n    }\n    const anchorRect = anchorRef.value.getBoundingClientRect()\n    const markerRect = markerRef.value.getBoundingClientRect()\n    const linkRect = currentLinkEl.getBoundingClientRect()\n\n    if (props.direction === 'horizontal') {\n      const left = linkRect.left - anchorRect.left\n      markerStyle.value = {\n        left: `${left}px`,\n        width: `${linkRect.width}px`,\n        opacity: 1,\n      }\n    } else {\n      const top =\n        linkRect.top -\n        anchorRect.top +\n        (linkRect.height - markerRect.height) / 2\n      markerStyle.value = {\n        top: `${top}px`,\n        opacity: 1,\n      }\n    }\n  })\n}\n\nwatch(currentAnchor, updateMarkerStyle)\nwatch(() => slots.default?.(), updateMarkerStyle)\n\nonMounted(() => {\n  getContainer()\n  const hash = decodeURIComponent(window.location.hash)\n  const target = getElement(hash)\n  if (target) {\n    scrollTo(hash)\n  } else {\n    handleScroll()\n  }\n})\n\nwatch(\n  () => props.container,\n  () => {\n    getContainer()\n  }\n)\n\nprovide(anchorKey, {\n  ns,\n  direction: props.direction,\n  currentAnchor,\n  addLink,\n  removeLink,\n  handleClick,\n})\n\ndefineExpose({\n  scrollTo,\n})\n</script>\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}