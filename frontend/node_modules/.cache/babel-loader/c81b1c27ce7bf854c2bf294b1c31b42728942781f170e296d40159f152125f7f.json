{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.every.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.reduce.js\";\nimport { defineComponent, renderSlot, createVNode, isVNode, createTextVNode, Comment } from 'vue';\nimport SpaceItem from './item.mjs';\nimport { useSpace } from './use-space.mjs';\nimport { PatchFlags, isFragment, isValidElementNode } from '../../../utils/vue/vnode.mjs';\nimport { buildProps, definePropType } from '../../../utils/vue/props/runtime.mjs';\nimport { isArray, isString } from '@vue/shared';\nimport { isNumber } from '../../../utils/types.mjs';\nimport { componentSizes } from '../../../constants/size.mjs';\nconst spaceProps = buildProps({\n  direction: {\n    type: String,\n    values: [\"horizontal\", \"vertical\"],\n    default: \"horizontal\"\n  },\n  class: {\n    type: definePropType([String, Object, Array]),\n    default: \"\"\n  },\n  style: {\n    type: definePropType([String, Array, Object]),\n    default: \"\"\n  },\n  alignment: {\n    type: definePropType(String),\n    default: \"center\"\n  },\n  prefixCls: {\n    type: String\n  },\n  spacer: {\n    type: definePropType([Object, String, Number, Array]),\n    default: null,\n    validator: val => isVNode(val) || isNumber(val) || isString(val)\n  },\n  wrap: Boolean,\n  fill: Boolean,\n  fillRatio: {\n    type: Number,\n    default: 100\n  },\n  size: {\n    type: [String, Array, Number],\n    values: componentSizes,\n    validator: val => {\n      return isNumber(val) || isArray(val) && val.length === 2 && val.every(isNumber);\n    }\n  }\n});\nconst Space = defineComponent({\n  name: \"ElSpace\",\n  props: spaceProps,\n  setup(props, {\n    slots\n  }) {\n    const {\n      classes,\n      containerStyle,\n      itemStyle\n    } = useSpace(props);\n    function extractChildren(children, parentKey = \"\", extractedChildren = []) {\n      const {\n        prefixCls\n      } = props;\n      children.forEach((child, loopKey) => {\n        if (isFragment(child)) {\n          if (isArray(child.children)) {\n            child.children.forEach((nested, key) => {\n              if (isFragment(nested) && isArray(nested.children)) {\n                extractChildren(nested.children, `${parentKey + key}-`, extractedChildren);\n              } else {\n                if (isVNode(nested) && (nested == null ? void 0 : nested.type) === Comment) {\n                  extractedChildren.push(nested);\n                } else {\n                  extractedChildren.push(createVNode(SpaceItem, {\n                    style: itemStyle.value,\n                    prefixCls,\n                    key: `nested-${parentKey + key}`\n                  }, {\n                    default: () => [nested]\n                  }, PatchFlags.PROPS | PatchFlags.STYLE, [\"style\", \"prefixCls\"]));\n                }\n              }\n            });\n          }\n        } else if (isValidElementNode(child)) {\n          extractedChildren.push(createVNode(SpaceItem, {\n            style: itemStyle.value,\n            prefixCls,\n            key: `LoopKey${parentKey + loopKey}`\n          }, {\n            default: () => [child]\n          }, PatchFlags.PROPS | PatchFlags.STYLE, [\"style\", \"prefixCls\"]));\n        }\n      });\n      return extractedChildren;\n    }\n    return () => {\n      var _a;\n      const {\n        spacer,\n        direction\n      } = props;\n      const children = renderSlot(slots, \"default\", {\n        key: 0\n      }, () => []);\n      if (((_a = children.children) != null ? _a : []).length === 0) return null;\n      if (isArray(children.children)) {\n        let extractedChildren = extractChildren(children.children);\n        if (spacer) {\n          const len = extractedChildren.length - 1;\n          extractedChildren = extractedChildren.reduce((acc, child, idx) => {\n            const children2 = [...acc, child];\n            if (idx !== len) {\n              children2.push(createVNode(\"span\", {\n                style: [itemStyle.value, direction === \"vertical\" ? \"width: 100%\" : null],\n                key: idx\n              }, [isVNode(spacer) ? spacer : createTextVNode(spacer, PatchFlags.TEXT)], PatchFlags.STYLE));\n            }\n            return children2;\n          }, []);\n        }\n        return createVNode(\"div\", {\n          class: classes.value,\n          style: containerStyle.value\n        }, extractedChildren, PatchFlags.STYLE | PatchFlags.CLASS);\n      }\n      return children.children;\n    };\n  }\n});\nexport { Space as default, spaceProps };","map":{"version":3,"names":["spaceProps","buildProps","direction","type","String","values","default","class","definePropType","Object","Array","style","alignment","prefixCls","spacer","Number","validator","val","isVNode","isNumber","isString","wrap","Boolean","fill","fillRatio","size","componentSizes","isArray","length","every","Space","defineComponent","name","props","setup","slots","classes","containerStyle","itemStyle","useSpace","extractChildren","children","parentKey","extractedChildren","forEach","child","loopKey","isFragment","nested","key","Comment","push","createVNode","SpaceItem","value","PatchFlags","PROPS","STYLE","isValidElementNode","_a","renderSlot","len","reduce","acc","idx","children2","createTextVNode","TEXT","CLASS"],"sources":["../../../../../../packages/components/space/src/space.ts"],"sourcesContent":["import {\n  Comment,\n  createTextVNode,\n  createVNode,\n  defineComponent,\n  isVNode,\n  renderSlot,\n} from 'vue'\nimport {\n  PatchFlags,\n  buildProps,\n  definePropType,\n  isArray,\n  isFragment,\n  isNumber,\n  isString,\n  isValidElementNode,\n} from '@element-plus/utils'\nimport { componentSizes } from '@element-plus/constants'\nimport Item from './item'\nimport { useSpace } from './use-space'\n\nimport type {\n  CSSProperties,\n  ExtractPropTypes,\n  ExtractPublicPropTypes,\n  StyleValue,\n  VNode,\n  VNodeArrayChildren,\n  VNodeChild,\n} from 'vue'\nimport type { Arrayable } from '@element-plus/utils'\n\nexport const spaceProps = buildProps({\n  /**\n   * @description Placement direction\n   */\n  direction: {\n    type: String,\n    values: ['horizontal', 'vertical'],\n    default: 'horizontal',\n  },\n  /**\n   * @description Classname\n   */\n  class: {\n    type: definePropType<Arrayable<Record<string, boolean> | string>>([\n      String,\n      Object,\n      Array,\n    ]),\n    default: '',\n  },\n  /**\n   * @description Extra style rules\n   */\n  style: {\n    type: definePropType<StyleValue>([String, Array, Object]),\n    default: '',\n  },\n  /**\n   * @description Controls the alignment of items\n   */\n  alignment: {\n    type: definePropType<CSSProperties['align-items']>(String),\n    default: 'center',\n  },\n  /**\n   * @description Prefix for space-items\n   */\n  prefixCls: {\n    type: String,\n  },\n  /**\n   * @description Spacer\n   */\n  spacer: {\n    type: definePropType<VNodeChild>([Object, String, Number, Array]),\n    default: null,\n    validator: (val: unknown) => isVNode(val) || isNumber(val) || isString(val),\n  },\n  /**\n   * @description Auto wrapping\n   */\n  wrap: Boolean,\n  /**\n   * @description Whether to fill the container\n   */\n  fill: Boolean,\n  /**\n   * @description Ratio of fill\n   */\n  fillRatio: {\n    type: Number,\n    default: 100,\n  },\n  /**\n   * @description Spacing size\n   */\n  size: {\n    type: [String, Array, Number],\n    values: componentSizes,\n    validator: (val: unknown): val is [number, number] | number => {\n      return (\n        isNumber(val) ||\n        (isArray(val) && val.length === 2 && val.every(isNumber))\n      )\n    },\n  },\n} as const)\nexport type SpaceProps = ExtractPropTypes<typeof spaceProps>\nexport type SpacePropsPublic = ExtractPublicPropTypes<typeof spaceProps>\n\nconst Space = defineComponent({\n  name: 'ElSpace',\n\n  props: spaceProps,\n\n  setup(props, { slots }) {\n    const { classes, containerStyle, itemStyle } = useSpace(props)\n\n    // retrieve the children out via a simple for loop\n    // the edge case here is that when users uses directives like <v-for>, <v-if>\n    // we need to go deeper until the child is not the Fragment type\n    function extractChildren(\n      children: VNodeArrayChildren,\n      parentKey = '',\n      extractedChildren: VNode[] = []\n    ) {\n      const { prefixCls } = props\n      children.forEach((child, loopKey) => {\n        if (isFragment(child)) {\n          if (isArray(child.children)) {\n            child.children.forEach((nested, key) => {\n              if (isFragment(nested) && isArray(nested.children)) {\n                extractChildren(\n                  nested.children,\n                  `${parentKey + key}-`,\n                  extractedChildren\n                )\n              } else {\n                if (isVNode(nested) && nested?.type === Comment) {\n                  extractedChildren.push(nested)\n                } else {\n                  extractedChildren.push(\n                    createVNode(\n                      Item,\n                      {\n                        style: itemStyle.value,\n                        prefixCls,\n                        key: `nested-${parentKey + key}`,\n                      },\n                      {\n                        default: () => [nested],\n                      },\n                      PatchFlags.PROPS | PatchFlags.STYLE,\n                      ['style', 'prefixCls']\n                    )\n                  )\n                }\n              }\n            })\n          }\n          // if the current child is valid vnode, then append this current vnode\n          // to item as child node.\n        } else if (isValidElementNode(child)) {\n          extractedChildren.push(\n            createVNode(\n              Item,\n              {\n                style: itemStyle.value,\n                prefixCls,\n                key: `LoopKey${parentKey + loopKey}`,\n              },\n              {\n                default: () => [child],\n              },\n              PatchFlags.PROPS | PatchFlags.STYLE,\n              ['style', 'prefixCls']\n            )\n          )\n        }\n      })\n\n      return extractedChildren\n    }\n\n    return () => {\n      const { spacer, direction } = props\n\n      const children = renderSlot(slots, 'default', { key: 0 }, () => [])\n\n      if ((children.children ?? []).length === 0) return null\n      // loop the children, if current children is rendered via `renderList` or `<v-for>`\n      if (isArray(children.children)) {\n        let extractedChildren = extractChildren(children.children)\n\n        if (spacer) {\n          // track the current rendering index, when encounters the last element\n          // then no need to add a spacer after it.\n          const len = extractedChildren.length - 1\n          extractedChildren = extractedChildren.reduce<VNode[]>(\n            (acc, child, idx) => {\n              const children = [...acc, child]\n              if (idx !== len) {\n                children.push(\n                  createVNode(\n                    'span',\n                    // adding width 100% for vertical alignment,\n                    // when the spacer inherit the width from the\n                    // parent, this span's width was not set, so space\n                    // might disappear\n                    {\n                      style: [\n                        itemStyle.value,\n                        direction === 'vertical' ? 'width: 100%' : null,\n                      ],\n                      key: idx,\n                    },\n                    [\n                      // if spacer is already a valid vnode, then append it to the current\n                      // span element.\n                      // otherwise, treat it as string.\n                      isVNode(spacer)\n                        ? spacer\n                        : createTextVNode(spacer as string, PatchFlags.TEXT),\n                    ],\n                    PatchFlags.STYLE\n                  )\n                )\n              }\n              return children\n            },\n            []\n          )\n        }\n\n        // spacer container.\n        return createVNode(\n          'div',\n          {\n            class: classes.value,\n            style: containerStyle.value,\n          },\n          extractedChildren,\n          PatchFlags.STYLE | PatchFlags.CLASS\n        )\n      }\n\n      return children.children\n    }\n  },\n})\n\nexport type SpaceInstance = InstanceType<typeof Space> & unknown\n\nexport default Space\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}