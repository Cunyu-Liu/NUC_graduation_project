{"ast":null,"code":"import { defineComponent, ref, computed, watch, nextTick, provide, reactive, onActivated, onMounted, onUpdated, openBlock, createElementBlock, normalizeClass, unref, createElementVNode, normalizeStyle, createBlock, resolveDynamicComponent, withCtx, renderSlot, createCommentVNode } from 'vue';\nimport { useResizeObserver, useEventListener } from '@vueuse/core';\nimport Bar from './bar2.mjs';\nimport { scrollbarContextKey } from './constants.mjs';\nimport { scrollbarProps, scrollbarEmits } from './scrollbar.mjs';\nimport _export_sfc from '../../../_virtual/plugin-vue_export-helper.mjs';\nimport { useNamespace } from '../../../hooks/use-namespace/index.mjs';\nimport { addUnit } from '../../../utils/dom/style.mjs';\nimport { isObject } from '@vue/shared';\nimport { isNumber } from '../../../utils/types.mjs';\nimport { debugWarn } from '../../../utils/error.mjs';\nconst _hoisted_1 = [\"tabindex\"];\nconst COMPONENT_NAME = \"ElScrollbar\";\nconst _sfc_main = defineComponent({\n  ...{\n    name: COMPONENT_NAME\n  },\n  __name: \"scrollbar\",\n  props: scrollbarProps,\n  emits: scrollbarEmits,\n  setup(__props, {\n    expose: __expose,\n    emit: __emit\n  }) {\n    const props = __props;\n    const emit = __emit;\n    const ns = useNamespace(\"scrollbar\");\n    let stopResizeObserver = void 0;\n    let stopWrapResizeObserver = void 0;\n    let stopResizeListener = void 0;\n    let wrapScrollTop = 0;\n    let wrapScrollLeft = 0;\n    let direction = \"\";\n    const distanceScrollState = {\n      bottom: false,\n      top: false,\n      right: false,\n      left: false\n    };\n    const scrollbarRef = ref();\n    const wrapRef = ref();\n    const resizeRef = ref();\n    const barRef = ref();\n    const wrapStyle = computed(() => {\n      const style = {};\n      const height = addUnit(props.height);\n      const maxHeight = addUnit(props.maxHeight);\n      if (height) style.height = height;\n      if (maxHeight) style.maxHeight = maxHeight;\n      return [props.wrapStyle, style];\n    });\n    const wrapKls = computed(() => {\n      return [props.wrapClass, ns.e(\"wrap\"), {\n        [ns.em(\"wrap\", \"hidden-default\")]: !props.native\n      }];\n    });\n    const resizeKls = computed(() => {\n      return [ns.e(\"view\"), props.viewClass];\n    });\n    const shouldSkipDirection = direction2 => {\n      var _a;\n      return (_a = distanceScrollState[direction2]) != null ? _a : false;\n    };\n    const DIRECTION_PAIRS = {\n      top: \"bottom\",\n      bottom: \"top\",\n      left: \"right\",\n      right: \"left\"\n    };\n    const updateTriggerStatus = arrivedStates => {\n      const oppositeDirection = DIRECTION_PAIRS[direction];\n      if (!oppositeDirection) return;\n      const arrived = arrivedStates[direction];\n      const oppositeArrived = arrivedStates[oppositeDirection];\n      if (arrived && !distanceScrollState[direction]) {\n        distanceScrollState[direction] = true;\n      }\n      if (!oppositeArrived && distanceScrollState[oppositeDirection]) {\n        distanceScrollState[oppositeDirection] = false;\n      }\n    };\n    const handleScroll = () => {\n      var _a;\n      if (wrapRef.value) {\n        (_a = barRef.value) == null ? void 0 : _a.handleScroll(wrapRef.value);\n        const prevTop = wrapScrollTop;\n        const prevLeft = wrapScrollLeft;\n        wrapScrollTop = wrapRef.value.scrollTop;\n        wrapScrollLeft = wrapRef.value.scrollLeft;\n        const arrivedStates = {\n          bottom: wrapScrollTop + wrapRef.value.clientHeight >= wrapRef.value.scrollHeight - props.distance,\n          top: wrapScrollTop <= props.distance && prevTop !== 0,\n          right: wrapScrollLeft + wrapRef.value.clientWidth >= wrapRef.value.scrollWidth - props.distance && prevLeft !== wrapScrollLeft,\n          left: wrapScrollLeft <= props.distance && prevLeft !== 0\n        };\n        emit(\"scroll\", {\n          scrollTop: wrapScrollTop,\n          scrollLeft: wrapScrollLeft\n        });\n        if (prevTop !== wrapScrollTop) {\n          direction = wrapScrollTop > prevTop ? \"bottom\" : \"top\";\n        }\n        if (prevLeft !== wrapScrollLeft) {\n          direction = wrapScrollLeft > prevLeft ? \"right\" : \"left\";\n        }\n        if (props.distance > 0) {\n          if (shouldSkipDirection(direction)) {\n            return;\n          }\n          updateTriggerStatus(arrivedStates);\n        }\n        if (arrivedStates[direction]) emit(\"end-reached\", direction);\n      }\n    };\n    function scrollTo(arg1, arg2) {\n      if (isObject(arg1)) {\n        wrapRef.value.scrollTo(arg1);\n      } else if (isNumber(arg1) && isNumber(arg2)) {\n        wrapRef.value.scrollTo(arg1, arg2);\n      }\n    }\n    const setScrollTop = value => {\n      if (!isNumber(value)) {\n        debugWarn(COMPONENT_NAME, \"value must be a number\");\n        return;\n      }\n      wrapRef.value.scrollTop = value;\n    };\n    const setScrollLeft = value => {\n      if (!isNumber(value)) {\n        debugWarn(COMPONENT_NAME, \"value must be a number\");\n        return;\n      }\n      wrapRef.value.scrollLeft = value;\n    };\n    const update = () => {\n      var _a;\n      (_a = barRef.value) == null ? void 0 : _a.update();\n      distanceScrollState[direction] = false;\n    };\n    watch(() => props.noresize, noresize => {\n      if (noresize) {\n        stopResizeObserver == null ? void 0 : stopResizeObserver();\n        stopWrapResizeObserver == null ? void 0 : stopWrapResizeObserver();\n        stopResizeListener == null ? void 0 : stopResizeListener();\n      } else {\n        ({\n          stop: stopResizeObserver\n        } = useResizeObserver(resizeRef, update));\n        ({\n          stop: stopWrapResizeObserver\n        } = useResizeObserver(wrapRef, update));\n        stopResizeListener = useEventListener(\"resize\", update);\n      }\n    }, {\n      immediate: true\n    });\n    watch(() => [props.maxHeight, props.height], () => {\n      if (!props.native) nextTick(() => {\n        var _a;\n        update();\n        if (wrapRef.value) {\n          (_a = barRef.value) == null ? void 0 : _a.handleScroll(wrapRef.value);\n        }\n      });\n    });\n    provide(scrollbarContextKey, reactive({\n      scrollbarElement: scrollbarRef,\n      wrapElement: wrapRef\n    }));\n    onActivated(() => {\n      if (wrapRef.value) {\n        wrapRef.value.scrollTop = wrapScrollTop;\n        wrapRef.value.scrollLeft = wrapScrollLeft;\n      }\n    });\n    onMounted(() => {\n      if (!props.native) nextTick(() => {\n        update();\n      });\n    });\n    onUpdated(() => update());\n    __expose({\n      wrapRef,\n      update,\n      scrollTo,\n      setScrollTop,\n      setScrollLeft,\n      handleScroll\n    });\n    return (_ctx, _cache) => {\n      return openBlock(), createElementBlock(\"div\", {\n        ref_key: \"scrollbarRef\",\n        ref: scrollbarRef,\n        class: normalizeClass(unref(ns).b())\n      }, [createElementVNode(\"div\", {\n        ref_key: \"wrapRef\",\n        ref: wrapRef,\n        class: normalizeClass(wrapKls.value),\n        style: normalizeStyle(wrapStyle.value),\n        tabindex: _ctx.tabindex,\n        onScroll: handleScroll\n      }, [(openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), {\n        id: _ctx.id,\n        ref_key: \"resizeRef\",\n        ref: resizeRef,\n        class: normalizeClass(resizeKls.value),\n        style: normalizeStyle(_ctx.viewStyle),\n        role: _ctx.role,\n        \"aria-label\": _ctx.ariaLabel,\n        \"aria-orientation\": _ctx.ariaOrientation\n      }, {\n        default: withCtx(() => [renderSlot(_ctx.$slots, \"default\")]),\n        _: 3\n      }, 8, [\"id\", \"class\", \"style\", \"role\", \"aria-label\", \"aria-orientation\"]))], 46, _hoisted_1), !_ctx.native ? (openBlock(), createBlock(Bar, {\n        key: 0,\n        ref_key: \"barRef\",\n        ref: barRef,\n        always: _ctx.always,\n        \"min-size\": _ctx.minSize\n      }, null, 8, [\"always\", \"min-size\"])) : createCommentVNode(\"v-if\", true)], 2);\n    };\n  }\n});\nvar Scrollbar = /* @__PURE__ */_export_sfc(_sfc_main, [[\"__file\", \"/home/runner/work/element-plus/element-plus/packages/components/scrollbar/src/scrollbar.vue\"]]);\nexport { Scrollbar as default };","map":{"version":3,"names":["COMPONENT_NAME","props","__props","emit","__emit","ns","useNamespace","stopResizeObserver","stopWrapResizeObserver","stopResizeListener","wrapScrollTop","wrapScrollLeft","direction","distanceScrollState","bottom","top","right","left","scrollbarRef","ref","wrapRef","resizeRef","barRef","wrapStyle","computed","style","height","addUnit","maxHeight","wrapKls","wrapClass","e","em","native","resizeKls","viewClass","shouldSkipDirection","direction2","_a","DIRECTION_PAIRS","updateTriggerStatus","arrivedStates","oppositeDirection","arrived","oppositeArrived","handleScroll","value","prevTop","prevLeft","scrollTop","scrollLeft","clientHeight","scrollHeight","distance","clientWidth","scrollWidth","scrollTo","arg1","arg2","isObject","isNumber","setScrollTop","debugWarn","setScrollLeft","update","watch","noresize","stop","useResizeObserver","useEventListener","immediate","nextTick","provide","scrollbarContextKey","reactive","scrollbarElement","wrapElement","onActivated","onMounted","onUpdated","__expose","openBlock","createElementBlock","ref_key","class","normalizeClass","unref","b","createElementVNode","normalizeStyle","tabindex","_ctx","onScroll","createBlock","resolveDynamicComponent","tag","id","viewStyle","role","ariaLabel","ariaOrientation","default","withCtx","renderSlot","$slots","_","Bar","key","always","minSize","createCommentVNode"],"sources":["../../../../../../packages/components/scrollbar/src/scrollbar.vue"],"sourcesContent":["<template>\n  <div ref=\"scrollbarRef\" :class=\"ns.b()\">\n    <div\n      ref=\"wrapRef\"\n      :class=\"wrapKls\"\n      :style=\"wrapStyle\"\n      :tabindex=\"tabindex\"\n      @scroll=\"handleScroll\"\n    >\n      <component\n        :is=\"tag\"\n        :id=\"id\"\n        ref=\"resizeRef\"\n        :class=\"resizeKls\"\n        :style=\"viewStyle\"\n        :role=\"role\"\n        :aria-label=\"ariaLabel\"\n        :aria-orientation=\"ariaOrientation\"\n      >\n        <slot />\n      </component>\n    </div>\n    <template v-if=\"!native\">\n      <bar ref=\"barRef\" :always=\"always\" :min-size=\"minSize\" />\n    </template>\n  </div>\n</template>\n\n<script lang=\"ts\" setup>\nimport {\n  computed,\n  nextTick,\n  onActivated,\n  onMounted,\n  onUpdated,\n  provide,\n  reactive,\n  ref,\n  watch,\n} from 'vue'\nimport { useEventListener, useResizeObserver } from '@vueuse/core'\nimport { addUnit, debugWarn, isNumber, isObject } from '@element-plus/utils'\nimport { useNamespace } from '@element-plus/hooks'\nimport Bar from './bar.vue'\nimport { scrollbarContextKey } from './constants'\nimport { scrollbarEmits, scrollbarProps } from './scrollbar'\n\nimport type { ScrollbarDirection } from './scrollbar'\nimport type { BarInstance } from './bar'\nimport type { CSSProperties, StyleValue } from 'vue'\n\nconst COMPONENT_NAME = 'ElScrollbar'\n\ndefineOptions({\n  name: COMPONENT_NAME,\n})\n\nconst props = defineProps(scrollbarProps)\nconst emit = defineEmits(scrollbarEmits)\n\nconst ns = useNamespace('scrollbar')\n\nlet stopResizeObserver: (() => void) | undefined = undefined\nlet stopWrapResizeObserver: (() => void) | undefined = undefined\nlet stopResizeListener: (() => void) | undefined = undefined\nlet wrapScrollTop = 0\nlet wrapScrollLeft = 0\nlet direction = '' as ScrollbarDirection\nconst distanceScrollState = {\n  bottom: false,\n  top: false,\n  right: false,\n  left: false,\n}\n\nconst scrollbarRef = ref<HTMLDivElement>()\nconst wrapRef = ref<HTMLDivElement>()\nconst resizeRef = ref<HTMLElement>()\nconst barRef = ref<BarInstance>()\n\nconst wrapStyle = computed<StyleValue>(() => {\n  const style: CSSProperties = {}\n  const height = addUnit(props.height)\n  const maxHeight = addUnit(props.maxHeight)\n  if (height) style.height = height\n  if (maxHeight) style.maxHeight = maxHeight\n  return [props.wrapStyle, style]\n})\n\nconst wrapKls = computed(() => {\n  return [\n    props.wrapClass,\n    ns.e('wrap'),\n    { [ns.em('wrap', 'hidden-default')]: !props.native },\n  ]\n})\n\nconst resizeKls = computed(() => {\n  return [ns.e('view'), props.viewClass]\n})\n\nconst shouldSkipDirection = (direction: ScrollbarDirection) => {\n  return distanceScrollState[direction] ?? false\n}\n\nconst DIRECTION_PAIRS: Record<ScrollbarDirection, ScrollbarDirection> = {\n  top: 'bottom',\n  bottom: 'top',\n  left: 'right',\n  right: 'left',\n}\nconst updateTriggerStatus = (arrivedStates: Record<string, boolean>) => {\n  const oppositeDirection = DIRECTION_PAIRS[direction]\n  if (!oppositeDirection) return\n\n  const arrived = arrivedStates[direction]\n  const oppositeArrived = arrivedStates[oppositeDirection]\n\n  if (arrived && !distanceScrollState[direction]) {\n    distanceScrollState[direction] = true\n  }\n\n  if (!oppositeArrived && distanceScrollState[oppositeDirection]) {\n    distanceScrollState[oppositeDirection] = false\n  }\n}\n\nconst handleScroll = () => {\n  if (wrapRef.value) {\n    barRef.value?.handleScroll(wrapRef.value)\n    const prevTop = wrapScrollTop\n    const prevLeft = wrapScrollLeft\n    wrapScrollTop = wrapRef.value.scrollTop\n    wrapScrollLeft = wrapRef.value.scrollLeft\n\n    const arrivedStates = {\n      bottom:\n        wrapScrollTop + wrapRef.value.clientHeight >=\n        wrapRef.value.scrollHeight - props.distance,\n      top: wrapScrollTop <= props.distance && prevTop !== 0,\n      right:\n        wrapScrollLeft + wrapRef.value.clientWidth >=\n          wrapRef.value.scrollWidth - props.distance &&\n        prevLeft !== wrapScrollLeft,\n      left: wrapScrollLeft <= props.distance && prevLeft !== 0,\n    }\n\n    emit('scroll', {\n      scrollTop: wrapScrollTop,\n      scrollLeft: wrapScrollLeft,\n    })\n\n    if (prevTop !== wrapScrollTop) {\n      direction = wrapScrollTop > prevTop ? 'bottom' : 'top'\n    }\n    if (prevLeft !== wrapScrollLeft) {\n      direction = wrapScrollLeft > prevLeft ? 'right' : 'left'\n    }\n    if (props.distance > 0) {\n      if (shouldSkipDirection(direction)) {\n        return\n      }\n      updateTriggerStatus(arrivedStates)\n    }\n    if (arrivedStates[direction]) emit('end-reached', direction)\n  }\n}\n\nfunction scrollTo(xCord: number, yCord?: number): void\nfunction scrollTo(options: ScrollToOptions): void\nfunction scrollTo(arg1: unknown, arg2?: number) {\n  if (isObject(arg1)) {\n    wrapRef.value!.scrollTo(arg1)\n  } else if (isNumber(arg1) && isNumber(arg2)) {\n    wrapRef.value!.scrollTo(arg1, arg2)\n  }\n}\n\nconst setScrollTop = (value: number) => {\n  if (!isNumber(value)) {\n    debugWarn(COMPONENT_NAME, 'value must be a number')\n    return\n  }\n  wrapRef.value!.scrollTop = value\n}\n\nconst setScrollLeft = (value: number) => {\n  if (!isNumber(value)) {\n    debugWarn(COMPONENT_NAME, 'value must be a number')\n    return\n  }\n  wrapRef.value!.scrollLeft = value\n}\n\nconst update = () => {\n  barRef.value?.update()\n  distanceScrollState[direction] = false\n}\n\nwatch(\n  () => props.noresize,\n  (noresize) => {\n    if (noresize) {\n      stopResizeObserver?.()\n      stopWrapResizeObserver?.()\n      stopResizeListener?.()\n    } else {\n      ;({ stop: stopResizeObserver } = useResizeObserver(resizeRef, update))\n      ;({ stop: stopWrapResizeObserver } = useResizeObserver(wrapRef, update))\n      stopResizeListener = useEventListener('resize', update)\n    }\n  },\n  { immediate: true }\n)\n\nwatch(\n  () => [props.maxHeight, props.height],\n  () => {\n    if (!props.native)\n      nextTick(() => {\n        update()\n        if (wrapRef.value) {\n          barRef.value?.handleScroll(wrapRef.value)\n        }\n      })\n  }\n)\n\nprovide(\n  scrollbarContextKey,\n  reactive({\n    scrollbarElement: scrollbarRef,\n    wrapElement: wrapRef,\n  })\n)\n\nonActivated(() => {\n  if (wrapRef.value) {\n    wrapRef.value.scrollTop = wrapScrollTop\n    wrapRef.value.scrollLeft = wrapScrollLeft\n  }\n})\n\nonMounted(() => {\n  if (!props.native)\n    nextTick(() => {\n      update()\n    })\n})\nonUpdated(() => update())\n\ndefineExpose({\n  /** @description scrollbar wrap ref */\n  wrapRef,\n  /** @description update scrollbar state manually */\n  update,\n  /** @description scrolls to a particular set of coordinates */\n  scrollTo,\n  /** @description set distance to scroll top */\n  setScrollTop,\n  /** @description set distance to scroll left */\n  setScrollLeft,\n  /** @description handle scroll event */\n  handleScroll,\n})\n</script>\n"],"mappings":";;;;;;;;;;;;AAmDA,MAAMA,cAAiB;;;;;;;;;;;;IAMvB,MAAMC,KAAQ,GAAAC,OAAA;IACd,MAAMC,IAAO,GAAAC,MAAA;IAEP,MAAAC,EAAA,GAAKC,YAAA,CAAa,WAAW;IAEnC,IAAIC,kBAA+C;IACnD,IAAIC,sBAAmD;IACvD,IAAIC,kBAA+C;IACnD,IAAIC,aAAgB;IACpB,IAAIC,cAAiB;IACrB,IAAIC,SAAY;IAChB,MAAMC,mBAAsB;MAC1BC,MAAQ;MACRC,GAAK;MACLC,KAAO;MACPC,IAAM;IAAA,CACR;IAEA,MAAMC,YAAA,GAAeC,GAAoB;IACzC,MAAMC,OAAA,GAAUD,GAAoB;IACpC,MAAME,SAAA,GAAYF,GAAiB;IACnC,MAAMG,MAAA,GAASH,GAAiB;IAE1B,MAAAI,SAAA,GAAYC,QAAA,CAAqB,MAAM;MAC3C,MAAMC,KAAA,GAAuB,EAAC;MACxB,MAAAC,MAAA,GAASC,OAAQ,CAAA1B,KAAA,CAAMyB,MAAM;MAC7B,MAAAE,SAAA,GAAYD,OAAQ,CAAA1B,KAAA,CAAM2B,SAAS;MACrC,IAAAF,MAAA,E,MAAcA,MAAS,GAAAA,MAAA;MACvB,IAAAE,SAAA,E,MAAiBA,SAAY,GAAAA,SAAA;MAC1B,QAAC3B,KAAM,CAAAsB,SAAA,EAAWE,KAAK;IAAA,CAC/B;IAEK,MAAAI,OAAA,GAAUL,QAAA,CAAS,MAAM;MACtB,QACLvB,KAAM,CAAA6B,SAAA,EACNzB,EAAA,CAAG0B,CAAA,CAAE,MAAM,GACX;QAAE,CAAC1B,EAAG,CAAA2B,EAAA,CAAG,QAAQ,gBAAgB,IAAI,CAAC/B,KAAA,CAAMgC;MAAO,EACrD;IAAA,CACD;IAEK,MAAAC,SAAA,GAAYV,QAAA,CAAS,MAAM;MAC/B,OAAO,CAACnB,EAAG,CAAA0B,CAAA,CAAE,MAAM,GAAG9B,KAAA,CAAMkC,SAAS;IAAA,CACtC;IAEK,MAAAC,mBAAA,GAAuBC,UAAkC;;MACtD,QAAAC,EAAA,GAAAzB,mBAAA,CAAoBwB,UAAA,MAApB,IAAkC,GAAAC,EAAA;IAAA,CAC3C;IAEA,MAAMC,eAAkE;MACtExB,GAAK;MACLD,MAAQ;MACRG,IAAM;MACND,KAAO;IAAA,CACT;IACM,MAAAwB,mBAAA,GAAuBC,aAA2C;MAChE,MAAAC,iBAAA,GAAoBH,eAAgB,CAAA3B,SAAA;MAC1C,IAAI,CAAC8B,iBAAA,EAAmB;MAElB,MAAAC,OAAA,GAAUF,aAAc,CAAA7B,SAAA;MACxB,MAAAgC,eAAA,GAAkBH,aAAc,CAAAC,iBAAA;MAElC,IAAAC,OAAA,IAAW,CAAC9B,mBAAA,CAAoBD,SAAY;QAC9CC,mBAAA,CAAoBD,SAAa;MAAA;MAG/B,KAACgC,eAAmB,IAAA/B,mBAAA,CAAoB6B,iBAAoB;QAC9D7B,mBAAA,CAAoB6B,iBAAqB;MAAA;IAC3C,CACF;IAEA,MAAMG,YAAA,GAAeA,CAAA,KAAM;;MACzB,IAAIzB,OAAA,CAAQ0B,KAAO;QACV,CAAAR,EAAA,GAAAhB,MAAA,CAAAwB,KAAA,SAAO,YAAAR,EAAA,CAAAO,YAAA,CAAazB,OAAQ,CAAA0B,KAAA;QACnC,MAAMC,OAAU,GAAArC,aAAA;QAChB,MAAMsC,QAAW,GAAArC,cAAA;QACjBD,aAAA,GAAgBU,OAAA,CAAQ0B,KAAM,CAAAG,SAAA;QAC9BtC,cAAA,GAAiBS,OAAA,CAAQ0B,KAAM,CAAAI,UAAA;QAE/B,MAAMT,aAAgB;UACpB3B,MAAA,EACEJ,aAAA,GAAgBU,OAAQ,CAAA0B,KAAA,CAAMK,YAAA,IAC9B/B,OAAQ,CAAA0B,KAAA,CAAMM,YAAA,GAAenD,KAAM,CAAAoD,QAAA;UACrCtC,GAAK,EAAAL,aAAA,IAAiBT,KAAM,CAAAoD,QAAA,IAAYN,OAAY;UACpD/B,KAAA,EACEL,cAAiB,GAAAS,OAAA,CAAQ0B,KAAM,CAAAQ,WAAA,IAC7BlC,OAAA,CAAQ0B,KAAM,CAAAS,WAAA,GAActD,KAAM,CAAAoD,QAAA,IACpCL,QAAa,KAAArC,cAAA;UACfM,IAAM,EAAAN,cAAA,IAAkBV,KAAM,CAAAoD,QAAA,IAAYL,QAAa;QAAA,CACzD;QAEA7C,IAAA,CAAK,QAAU;UACb8C,SAAW,EAAAvC,aAAA;UACXwC,UAAY,EAAAvC;QAAA,CACb;QAED,IAAIoC,OAAA,KAAYrC,aAAe;UACjBE,SAAA,GAAAF,aAAA,GAAgBqC,OAAA,GAAU,QAAW;QAAA;QAEnD,IAAIC,QAAA,KAAarC,cAAgB;UACnBC,SAAA,GAAAD,cAAA,GAAiBqC,QAAA,GAAW,OAAU;QAAA;QAEhD,IAAA/C,KAAA,CAAMoD,QAAA,GAAW,CAAG;UAClB,IAAAjB,mBAAA,CAAoBxB,SAAS,CAAG;YAClC;UAAA;UAEF4B,mBAAA,CAAoBC,aAAa;QAAA;QAEnC,IAAIA,aAAc,CAAA7B,SAAA,GAAYT,IAAA,CAAK,eAAeS,SAAS;MAAA;IAC7D,CACF;IAIS,SAAA4C,SAASC,IAAA,EAAeC,IAAe;MAC1C,IAAAC,QAAA,CAASF,IAAI,CAAG;QACVrC,OAAA,CAAA0B,KAAA,CAAOU,QAAA,CAASC,IAAI;MAAA,WACnBG,QAAS,CAAAH,IAAI,CAAK,IAAAG,QAAA,CAASF,IAAI,CAAG;QACnCtC,OAAA,CAAA0B,KAAA,CAAOU,QAAS,CAAAC,IAAA,EAAMC,IAAI;MAAA;IACpC;IAGI,MAAAG,YAAA,GAAgBf,KAAkB;MAClC,KAACc,QAAS,CAAAd,KAAK,CAAG;QACpBgB,SAAA,CAAU9D,cAAA,EAAgB,wBAAwB;QAClD;MAAA;MAEFoB,OAAA,CAAQ0B,KAAA,CAAOG,SAAY,GAAAH,KAAA;IAAA,CAC7B;IAEM,MAAAiB,aAAA,GAAiBjB,KAAkB;MACnC,KAACc,QAAS,CAAAd,KAAK,CAAG;QACpBgB,SAAA,CAAU9D,cAAA,EAAgB,wBAAwB;QAClD;MAAA;MAEFoB,OAAA,CAAQ0B,KAAA,CAAOI,UAAa,GAAAJ,KAAA;IAAA,CAC9B;IAEA,MAAMkB,MAAA,GAASA,CAAA,KAAM;;MACnB,CAAA1B,EAAA,GAAAhB,MAAA,CAAOwB,KAAA,KAAP,IAAc,YAAAR,EAAA,CAAA0B,MAAA;MACdnD,mBAAA,CAAoBD,SAAa;IAAA,CACnC;IAEAqD,KAAA,CACE,MAAMhE,KAAM,CAAAiE,QAAA,EACXA,QAAa;MACZ,IAAIA,QAAU;QACS3D,kBAAA,oBAAAA,kBAAA;QACIC,sBAAA,oBAAAA,sBAAA;QACJC,kBAAA,oBAAAA,kBAAA;MAAA,CAChB;QACJ,CAAC;UAAE0D,IAAM,EAAA5D;QAAA,CAAuB,GAAA6D,iBAAA,CAAkB/C,SAAA,EAAW2C,MAAM;QACnE,CAAC;UAAEG,IAAM,EAAA3D;QAAA,CAA2B,GAAA4D,iBAAA,CAAkBhD,OAAA,EAAS4C,MAAM;QACjDvD,kBAAA,GAAA4D,gBAAA,CAAiB,UAAUL,MAAM;MAAA;IACxD,CACF,EACA;MAAEM,SAAA,EAAW;IAAK,EACpB;IAEAL,KAAA,CACE,MAAM,CAAChE,KAAM,CAAA2B,SAAA,EAAW3B,KAAA,CAAMyB,MAAM,GACpC,MAAM;MACJ,IAAI,CAACzB,KAAM,CAAAgC,MAAA,EACTsC,QAAA,CAAS,MAAM;;QACNP,MAAA;QACP,IAAI5C,OAAA,CAAQ0B,KAAO;UACV,CAAAR,EAAA,GAAAhB,MAAA,CAAAwB,KAAA,SAAO,YAAAR,EAAA,CAAAO,YAAA,CAAazB,OAAQ,CAAA0B,KAAA;QAAA;MACrC,CACD;IAAA,CACL,CACF;IAEA0B,OAAA,CACEC,mBAAA,EACAC,QAAS;MACPC,gBAAkB,EAAAzD,YAAA;MAClB0D,WAAa,EAAAxD;IAAA,CACd,EACH;IAEAyD,WAAA,CAAY,MAAM;MAChB,IAAIzD,OAAA,CAAQ0B,KAAO;QACjB1B,OAAA,CAAQ0B,KAAA,CAAMG,SAAY,GAAAvC,aAAA;QAC1BU,OAAA,CAAQ0B,KAAA,CAAMI,UAAa,GAAAvC,cAAA;MAAA;IAC7B,CACD;IAEDmE,SAAA,CAAU,MAAM;MACd,IAAI,CAAC7E,KAAM,CAAAgC,MAAA,EACTsC,QAAA,CAAS,MAAM;QACNP,MAAA;MAAA,CACR;IAAA,CACJ;IACSe,SAAA,OAAMf,MAAA,EAAQ;IAEXgB,QAAA;MAEX5D,OAAA;MAEA4C,MAAA;MAEAR,QAAA;MAEAK,YAAA;MAEAE,aAAA;MAEAlB;IAAA,CACD;;MAvQC,OAAAoC,SAAA,IAAAC,kBAAA,CAwBM;QAxBGC,OAAA;QAAJhE,GAAI,EAAAD,YAAA;QAAgBkE,KAAA,EAAKC,cAAE,CAAAC,KAAA,CAAAjF,EAAA,EAAGkF,CAAA,EAAC;MAAA,IAClCC,kBAAA,CAmBM;QAlBAL,OAAA;QAAJhE,GAAI,EAAAC,OAAA;QACHgE,KAAA,EAAKC,cAAE,CAAAxD,OAAA,CAAOiB,KAAA;QACdrB,KAAA,EAAKgE,cAAE,CAAAlE,SAAA,CAASuB,KAAA;QAChB4C,QAAA,EAAUC,IAAA,CAAAD,QAAA;QACVE,QAAQ,EAAA/C;MAAA,KAEToC,SAAA,IAAAY,WAAA,CAWYC,uBAVL,CAAAH,IAAA,CAAGI,GAAA;QACPC,EAAA,EAAIL,IAAA,CAAAK,EAAA;QACDb,OAAA;QAAJhE,GAAI,EAAAE,SAAA;QACH+D,KAAA,EAAKC,cAAE,CAAAnD,SAAA,CAASY,KAAA;QAChBrB,KAAA,EAAKgE,cAAE,CAAAE,IAAA,CAASM,SAAA;QAChBC,IAAA,EAAMP,IAAA,CAAAO,IAAA;QACN,cAAYP,IAAA,CAAAQ,SAAA;QACZ,oBAAkBR,IAAA,CAAAS;MAAA;QAAAC,OAAA,EAAAC,OAAA,CAEnB,MAAQ,CAARC,UAAA,CAAQZ,IAAA,CAAAa,MAAA;QAAAC,CAAA;oGAGK,CAAAd,IAAA,CAAA1D,MAAA,IAAAgD,SAAA,IACfY,WAAA,CAAyDa,GAAA;QAAAC,GAAA;QAAhDxB,OAAA;QAAJhE,GAAI,EAAAG,MAAA;QAAUsF,MAAA,EAAQjB,IAAA,CAAAiB,MAAA;QAAS,YAAUjB,IAAA,CAAAkB;MAAA,uCAAAC,kBAAA,iB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}