{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { defineComponent, getCurrentInstance, ref, computed, unref, onMounted, nextTick, resolveDynamicComponent, h, mergeProps, Fragment } from 'vue';\nimport { useEventListener, isClient } from '@vueuse/core';\nimport ScrollBar from '../components/scrollbar.mjs';\nimport { useGridWheel } from '../hooks/use-grid-wheel.mjs';\nimport { useCache } from '../hooks/use-cache.mjs';\nimport { useGridTouch } from '../hooks/use-grid-touch.mjs';\nimport { virtualizedGridProps } from '../props.mjs';\nimport { getScrollDir, getRTLOffsetType, isRTL } from '../utils.mjs';\nimport { ITEM_RENDER_EVT, SCROLL_EVT, FORWARD, BACKWARD, AUTO_ALIGNMENT, RTL, RTL_OFFSET_POS_ASC, RTL_OFFSET_NAG, RTL_OFFSET_POS_DESC } from '../defaults.mjs';\nimport { useNamespace } from '../../../../hooks/use-namespace/index.mjs';\nimport { isNumber } from '../../../../utils/types.mjs';\nimport { getScrollBarWidth } from '../../../../utils/dom/scroll.mjs';\nimport { isString, hasOwn } from '@vue/shared';\nconst createGrid = ({\n  name,\n  clearCache,\n  getColumnPosition,\n  getColumnStartIndexForOffset,\n  getColumnStopIndexForStartIndex,\n  getEstimatedTotalHeight,\n  getEstimatedTotalWidth,\n  getColumnOffset,\n  getRowOffset,\n  getRowPosition,\n  getRowStartIndexForOffset,\n  getRowStopIndexForStartIndex,\n  initCache,\n  injectToInstance,\n  validateProps\n}) => {\n  return defineComponent({\n    name: name != null ? name : \"ElVirtualList\",\n    props: virtualizedGridProps,\n    emits: [ITEM_RENDER_EVT, SCROLL_EVT],\n    setup(props, {\n      emit,\n      expose,\n      slots\n    }) {\n      const ns = useNamespace(\"vl\");\n      validateProps(props);\n      const instance = getCurrentInstance();\n      const cache = ref(initCache(props, instance));\n      injectToInstance == null ? void 0 : injectToInstance(instance, cache);\n      const windowRef = ref();\n      const hScrollbar = ref();\n      const vScrollbar = ref();\n      const innerRef = ref();\n      const states = ref({\n        isScrolling: false,\n        scrollLeft: isNumber(props.initScrollLeft) ? props.initScrollLeft : 0,\n        scrollTop: isNumber(props.initScrollTop) ? props.initScrollTop : 0,\n        updateRequested: false,\n        xAxisScrollDir: FORWARD,\n        yAxisScrollDir: FORWARD\n      });\n      const getItemStyleCache = useCache();\n      const parsedHeight = computed(() => Number.parseInt(`${props.height}`, 10));\n      const parsedWidth = computed(() => Number.parseInt(`${props.width}`, 10));\n      const columnsToRender = computed(() => {\n        const {\n          totalColumn,\n          totalRow,\n          columnCache\n        } = props;\n        const {\n          isScrolling,\n          xAxisScrollDir,\n          scrollLeft\n        } = unref(states);\n        if (totalColumn === 0 || totalRow === 0) {\n          return [0, 0, 0, 0];\n        }\n        const startIndex = getColumnStartIndexForOffset(props, scrollLeft, unref(cache));\n        const stopIndex = getColumnStopIndexForStartIndex(props, startIndex, scrollLeft, unref(cache));\n        const cacheBackward = !isScrolling || xAxisScrollDir === BACKWARD ? Math.max(1, columnCache) : 1;\n        const cacheForward = !isScrolling || xAxisScrollDir === FORWARD ? Math.max(1, columnCache) : 1;\n        return [Math.max(0, startIndex - cacheBackward), Math.max(0, Math.min(totalColumn - 1, stopIndex + cacheForward)), startIndex, stopIndex];\n      });\n      const rowsToRender = computed(() => {\n        const {\n          totalColumn,\n          totalRow,\n          rowCache\n        } = props;\n        const {\n          isScrolling,\n          yAxisScrollDir,\n          scrollTop\n        } = unref(states);\n        if (totalColumn === 0 || totalRow === 0) {\n          return [0, 0, 0, 0];\n        }\n        const startIndex = getRowStartIndexForOffset(props, scrollTop, unref(cache));\n        const stopIndex = getRowStopIndexForStartIndex(props, startIndex, scrollTop, unref(cache));\n        const cacheBackward = !isScrolling || yAxisScrollDir === BACKWARD ? Math.max(1, rowCache) : 1;\n        const cacheForward = !isScrolling || yAxisScrollDir === FORWARD ? Math.max(1, rowCache) : 1;\n        return [Math.max(0, startIndex - cacheBackward), Math.max(0, Math.min(totalRow - 1, stopIndex + cacheForward)), startIndex, stopIndex];\n      });\n      const estimatedTotalHeight = computed(() => getEstimatedTotalHeight(props, unref(cache)));\n      const estimatedTotalWidth = computed(() => getEstimatedTotalWidth(props, unref(cache)));\n      const windowStyle = computed(() => {\n        var _a;\n        return [{\n          position: \"relative\",\n          overflow: \"hidden\",\n          WebkitOverflowScrolling: \"touch\",\n          willChange: \"transform\"\n        }, {\n          direction: props.direction,\n          height: isNumber(props.height) ? `${props.height}px` : props.height,\n          width: isNumber(props.width) ? `${props.width}px` : props.width\n        }, (_a = props.style) != null ? _a : {}];\n      });\n      const innerStyle = computed(() => {\n        const width = `${unref(estimatedTotalWidth)}px`;\n        const height = `${unref(estimatedTotalHeight)}px`;\n        return {\n          height,\n          pointerEvents: unref(states).isScrolling ? \"none\" : void 0,\n          width,\n          margin: 0,\n          boxSizing: \"border-box\"\n        };\n      });\n      const emitEvents = () => {\n        const {\n          totalColumn,\n          totalRow\n        } = props;\n        if (totalColumn > 0 && totalRow > 0) {\n          const [columnCacheStart, columnCacheEnd, columnVisibleStart, columnVisibleEnd] = unref(columnsToRender);\n          const [rowCacheStart, rowCacheEnd, rowVisibleStart, rowVisibleEnd] = unref(rowsToRender);\n          emit(ITEM_RENDER_EVT, {\n            columnCacheStart,\n            columnCacheEnd,\n            rowCacheStart,\n            rowCacheEnd,\n            columnVisibleStart,\n            columnVisibleEnd,\n            rowVisibleStart,\n            rowVisibleEnd\n          });\n        }\n        const {\n          scrollLeft,\n          scrollTop,\n          updateRequested,\n          xAxisScrollDir,\n          yAxisScrollDir\n        } = unref(states);\n        emit(SCROLL_EVT, {\n          xAxisScrollDir,\n          scrollLeft,\n          yAxisScrollDir,\n          scrollTop,\n          updateRequested\n        });\n      };\n      const onScroll = e => {\n        const {\n          clientHeight,\n          clientWidth,\n          scrollHeight,\n          scrollLeft,\n          scrollTop,\n          scrollWidth\n        } = e.currentTarget;\n        const _states = unref(states);\n        if (_states.scrollTop === scrollTop && _states.scrollLeft === scrollLeft) {\n          return;\n        }\n        let _scrollLeft = scrollLeft;\n        if (isRTL(props.direction)) {\n          switch (getRTLOffsetType()) {\n            case RTL_OFFSET_NAG:\n              _scrollLeft = -scrollLeft;\n              break;\n            case RTL_OFFSET_POS_DESC:\n              _scrollLeft = scrollWidth - clientWidth - scrollLeft;\n              break;\n          }\n        }\n        states.value = {\n          ..._states,\n          isScrolling: true,\n          scrollLeft: _scrollLeft,\n          scrollTop: Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight)),\n          updateRequested: true,\n          xAxisScrollDir: getScrollDir(_states.scrollLeft, _scrollLeft),\n          yAxisScrollDir: getScrollDir(_states.scrollTop, scrollTop)\n        };\n        nextTick(() => resetIsScrolling());\n        onUpdated();\n        emitEvents();\n      };\n      const onVerticalScroll = (distance, totalSteps) => {\n        const height = unref(parsedHeight);\n        const offset = (estimatedTotalHeight.value - height) / totalSteps * distance;\n        scrollTo({\n          scrollTop: Math.min(estimatedTotalHeight.value - height, offset)\n        });\n      };\n      const onHorizontalScroll = (distance, totalSteps) => {\n        const width = unref(parsedWidth);\n        const offset = (estimatedTotalWidth.value - width) / totalSteps * distance;\n        scrollTo({\n          scrollLeft: Math.min(estimatedTotalWidth.value - width, offset)\n        });\n      };\n      const {\n        onWheel\n      } = useGridWheel({\n        atXStartEdge: computed(() => states.value.scrollLeft <= 0),\n        atXEndEdge: computed(() => states.value.scrollLeft >= estimatedTotalWidth.value - unref(parsedWidth)),\n        atYStartEdge: computed(() => states.value.scrollTop <= 0),\n        atYEndEdge: computed(() => states.value.scrollTop >= estimatedTotalHeight.value - unref(parsedHeight))\n      }, (x, y) => {\n        var _a, _b, _c, _d;\n        (_b = (_a = hScrollbar.value) == null ? void 0 : _a.onMouseUp) == null ? void 0 : _b.call(_a);\n        (_d = (_c = vScrollbar.value) == null ? void 0 : _c.onMouseUp) == null ? void 0 : _d.call(_c);\n        const width = unref(parsedWidth);\n        const height = unref(parsedHeight);\n        scrollTo({\n          scrollLeft: Math.min(states.value.scrollLeft + x, estimatedTotalWidth.value - width),\n          scrollTop: Math.min(states.value.scrollTop + y, estimatedTotalHeight.value - height)\n        });\n      });\n      useEventListener(windowRef, \"wheel\", onWheel, {\n        passive: false\n      });\n      const scrollTo = ({\n        scrollLeft = states.value.scrollLeft,\n        scrollTop = states.value.scrollTop\n      }) => {\n        scrollLeft = Math.max(scrollLeft, 0);\n        scrollTop = Math.max(scrollTop, 0);\n        const _states = unref(states);\n        if (scrollTop === _states.scrollTop && scrollLeft === _states.scrollLeft) {\n          return;\n        }\n        states.value = {\n          ..._states,\n          xAxisScrollDir: getScrollDir(_states.scrollLeft, scrollLeft),\n          yAxisScrollDir: getScrollDir(_states.scrollTop, scrollTop),\n          scrollLeft,\n          scrollTop,\n          updateRequested: true\n        };\n        nextTick(() => resetIsScrolling());\n        onUpdated();\n        emitEvents();\n      };\n      const {\n        touchStartX,\n        touchStartY,\n        handleTouchStart,\n        handleTouchMove\n      } = useGridTouch(windowRef, states, scrollTo, estimatedTotalWidth, estimatedTotalHeight, parsedWidth, parsedHeight);\n      const scrollToItem = (rowIndex = 0, columnIdx = 0, alignment = AUTO_ALIGNMENT) => {\n        const _states = unref(states);\n        columnIdx = Math.max(0, Math.min(columnIdx, props.totalColumn - 1));\n        rowIndex = Math.max(0, Math.min(rowIndex, props.totalRow - 1));\n        const scrollBarWidth = getScrollBarWidth(ns.namespace.value);\n        const _cache = unref(cache);\n        const estimatedHeight = getEstimatedTotalHeight(props, _cache);\n        const estimatedWidth = getEstimatedTotalWidth(props, _cache);\n        scrollTo({\n          scrollLeft: getColumnOffset(props, columnIdx, alignment, _states.scrollLeft, _cache, estimatedWidth > props.width ? scrollBarWidth : 0),\n          scrollTop: getRowOffset(props, rowIndex, alignment, _states.scrollTop, _cache, estimatedHeight > props.height ? scrollBarWidth : 0)\n        });\n      };\n      const getItemStyle = (rowIndex, columnIndex) => {\n        const {\n          columnWidth,\n          direction,\n          rowHeight\n        } = props;\n        const itemStyleCache = getItemStyleCache.value(clearCache && columnWidth, clearCache && rowHeight, clearCache && direction);\n        const key = `${rowIndex},${columnIndex}`;\n        if (hasOwn(itemStyleCache, key)) {\n          return itemStyleCache[key];\n        } else {\n          const [, left] = getColumnPosition(props, columnIndex, unref(cache));\n          const _cache = unref(cache);\n          const rtl = isRTL(direction);\n          const [height, top] = getRowPosition(props, rowIndex, _cache);\n          const [width] = getColumnPosition(props, columnIndex, _cache);\n          itemStyleCache[key] = {\n            position: \"absolute\",\n            left: rtl ? void 0 : `${left}px`,\n            right: rtl ? `${left}px` : void 0,\n            top: `${top}px`,\n            height: `${height}px`,\n            width: `${width}px`\n          };\n          return itemStyleCache[key];\n        }\n      };\n      const resetIsScrolling = () => {\n        states.value.isScrolling = false;\n        nextTick(() => {\n          getItemStyleCache.value(-1, null, null);\n        });\n      };\n      onMounted(() => {\n        if (!isClient) return;\n        const {\n          initScrollLeft,\n          initScrollTop\n        } = props;\n        const windowElement = unref(windowRef);\n        if (windowElement) {\n          if (isNumber(initScrollLeft)) {\n            windowElement.scrollLeft = initScrollLeft;\n          }\n          if (isNumber(initScrollTop)) {\n            windowElement.scrollTop = initScrollTop;\n          }\n        }\n        emitEvents();\n      });\n      const onUpdated = () => {\n        const {\n          direction\n        } = props;\n        const {\n          scrollLeft,\n          scrollTop,\n          updateRequested\n        } = unref(states);\n        const windowElement = unref(windowRef);\n        if (updateRequested && windowElement) {\n          if (direction === RTL) {\n            switch (getRTLOffsetType()) {\n              case RTL_OFFSET_NAG:\n                {\n                  windowElement.scrollLeft = -scrollLeft;\n                  break;\n                }\n              case RTL_OFFSET_POS_ASC:\n                {\n                  windowElement.scrollLeft = scrollLeft;\n                  break;\n                }\n              default:\n                {\n                  const {\n                    clientWidth,\n                    scrollWidth\n                  } = windowElement;\n                  windowElement.scrollLeft = scrollWidth - clientWidth - scrollLeft;\n                  break;\n                }\n            }\n          } else {\n            windowElement.scrollLeft = Math.max(0, scrollLeft);\n          }\n          windowElement.scrollTop = Math.max(0, scrollTop);\n        }\n      };\n      const {\n        resetAfterColumnIndex,\n        resetAfterRowIndex,\n        resetAfter\n      } = instance.proxy;\n      expose({\n        windowRef,\n        innerRef,\n        getItemStyleCache,\n        touchStartX,\n        touchStartY,\n        handleTouchStart,\n        handleTouchMove,\n        scrollTo,\n        scrollToItem,\n        states,\n        resetAfterColumnIndex,\n        resetAfterRowIndex,\n        resetAfter\n      });\n      const renderScrollbars = () => {\n        const {\n          scrollbarAlwaysOn,\n          scrollbarStartGap,\n          scrollbarEndGap,\n          totalColumn,\n          totalRow\n        } = props;\n        const width = unref(parsedWidth);\n        const height = unref(parsedHeight);\n        const estimatedWidth = unref(estimatedTotalWidth);\n        const estimatedHeight = unref(estimatedTotalHeight);\n        const {\n          scrollLeft,\n          scrollTop\n        } = unref(states);\n        const horizontalScrollbar = h(ScrollBar, {\n          ref: hScrollbar,\n          alwaysOn: scrollbarAlwaysOn,\n          startGap: scrollbarStartGap,\n          endGap: scrollbarEndGap,\n          class: ns.e(\"horizontal\"),\n          clientSize: width,\n          layout: \"horizontal\",\n          onScroll: onHorizontalScroll,\n          ratio: width * 100 / estimatedWidth,\n          scrollFrom: scrollLeft / (estimatedWidth - width),\n          total: totalRow,\n          visible: true\n        });\n        const verticalScrollbar = h(ScrollBar, {\n          ref: vScrollbar,\n          alwaysOn: scrollbarAlwaysOn,\n          startGap: scrollbarStartGap,\n          endGap: scrollbarEndGap,\n          class: ns.e(\"vertical\"),\n          clientSize: height,\n          layout: \"vertical\",\n          onScroll: onVerticalScroll,\n          ratio: height * 100 / estimatedHeight,\n          scrollFrom: scrollTop / (estimatedHeight - height),\n          total: totalColumn,\n          visible: true\n        });\n        return {\n          horizontalScrollbar,\n          verticalScrollbar\n        };\n      };\n      const renderItems = () => {\n        var _a;\n        const [columnStart, columnEnd] = unref(columnsToRender);\n        const [rowStart, rowEnd] = unref(rowsToRender);\n        const {\n          data,\n          totalColumn,\n          totalRow,\n          useIsScrolling,\n          itemKey\n        } = props;\n        const children = [];\n        if (totalRow > 0 && totalColumn > 0) {\n          for (let row = rowStart; row <= rowEnd; row++) {\n            for (let column = columnStart; column <= columnEnd; column++) {\n              const key = itemKey({\n                columnIndex: column,\n                data,\n                rowIndex: row\n              });\n              children.push(h(Fragment, {\n                key\n              }, (_a = slots.default) == null ? void 0 : _a.call(slots, {\n                columnIndex: column,\n                data,\n                isScrolling: useIsScrolling ? unref(states).isScrolling : void 0,\n                style: getItemStyle(row, column),\n                rowIndex: row\n              })));\n            }\n          }\n        }\n        return children;\n      };\n      const renderInner = () => {\n        const Inner = resolveDynamicComponent(props.innerElement);\n        const children = renderItems();\n        return [h(Inner, mergeProps(props.innerProps, {\n          style: unref(innerStyle),\n          ref: innerRef\n        }), !isString(Inner) ? {\n          default: () => children\n        } : children)];\n      };\n      const renderWindow = () => {\n        const Container = resolveDynamicComponent(props.containerElement);\n        const {\n          horizontalScrollbar,\n          verticalScrollbar\n        } = renderScrollbars();\n        const Inner = renderInner();\n        return h(\"div\", {\n          key: 0,\n          class: ns.e(\"wrapper\"),\n          role: props.role\n        }, [h(Container, {\n          class: props.className,\n          style: unref(windowStyle),\n          onScroll,\n          ref: windowRef\n        }, !isString(Container) ? {\n          default: () => Inner\n        } : Inner), horizontalScrollbar, verticalScrollbar]);\n      };\n      return renderWindow;\n    }\n  });\n};\nexport { createGrid as default };","map":{"version":3,"names":["createGrid","name","clearCache","getColumnPosition","getColumnStartIndexForOffset","getColumnStopIndexForStartIndex","getEstimatedTotalHeight","getEstimatedTotalWidth","getColumnOffset","getRowOffset","getRowPosition","getRowStartIndexForOffset","getRowStopIndexForStartIndex","initCache","injectToInstance","validateProps","defineComponent","props","virtualizedGridProps","emits","ITEM_RENDER_EVT","SCROLL_EVT","setup","emit","expose","slots","ns","useNamespace","instance","getCurrentInstance","cache","ref","windowRef","hScrollbar","vScrollbar","innerRef","states","isScrolling","scrollLeft","isNumber","initScrollLeft","scrollTop","initScrollTop","updateRequested","xAxisScrollDir","FORWARD","yAxisScrollDir","getItemStyleCache","useCache","parsedHeight","computed","Number","parseInt","height","parsedWidth","width","columnsToRender","totalColumn","totalRow","columnCache","unref","startIndex","stopIndex","cacheBackward","BACKWARD","Math","max","cacheForward","min","rowsToRender","rowCache","estimatedTotalHeight","estimatedTotalWidth","windowStyle","_a","position","overflow","WebkitOverflowScrolling","willChange","direction","style","innerStyle","pointerEvents","margin","boxSizing","emitEvents","columnCacheStart","columnCacheEnd","columnVisibleStart","columnVisibleEnd","rowCacheStart","rowCacheEnd","rowVisibleStart","rowVisibleEnd","onScroll","e","clientHeight","clientWidth","scrollHeight","scrollWidth","currentTarget","_states","_scrollLeft","isRTL","getRTLOffsetType","RTL_OFFSET_NAG","RTL_OFFSET_POS_DESC","value","getScrollDir","nextTick","resetIsScrolling","onUpdated","onVerticalScroll","distance","totalSteps","offset","scrollTo","onHorizontalScroll","onWheel","useGridWheel","atXStartEdge","atXEndEdge","atYStartEdge","atYEndEdge","x","y","_b","_c","_d","onMouseUp","call","useEventListener","passive","touchStartX","touchStartY","handleTouchStart","handleTouchMove","useGridTouch","scrollToItem","rowIndex","columnIdx","alignment","AUTO_ALIGNMENT","scrollBarWidth","getScrollBarWidth","namespace","_cache","estimatedHeight","estimatedWidth","getItemStyle","columnIndex","columnWidth","rowHeight","itemStyleCache","key","hasOwn","left","rtl","top","right","onMounted","isClient","windowElement","RTL","RTL_OFFSET_POS_ASC","resetAfterColumnIndex","resetAfterRowIndex","resetAfter","proxy","renderScrollbars","scrollbarAlwaysOn","scrollbarStartGap","scrollbarEndGap","horizontalScrollbar","h","ScrollBar","alwaysOn","startGap","endGap","class","clientSize","layout","ratio","scrollFrom","total","visible","verticalScrollbar","renderItems","columnStart","columnEnd","rowStart","rowEnd","data","useIsScrolling","itemKey","children","row","column","push","Fragment","default","renderInner","Inner","resolveDynamicComponent","innerElement","mergeProps","innerProps","isString","renderWindow","Container","containerElement","role","className"],"sources":["../../../../../../../packages/components/virtual-list/src/builders/build-grid.ts"],"sourcesContent":["import {\n  Fragment,\n  computed,\n  defineComponent,\n  getCurrentInstance,\n  h,\n  mergeProps,\n  nextTick,\n  onMounted,\n  ref,\n  resolveDynamicComponent,\n  unref,\n} from 'vue'\nimport { useEventListener } from '@vueuse/core'\nimport {\n  getScrollBarWidth,\n  hasOwn,\n  isClient,\n  isNumber,\n  isString,\n} from '@element-plus/utils'\nimport { useNamespace } from '@element-plus/hooks'\nimport Scrollbar from '../components/scrollbar'\nimport { useGridWheel } from '../hooks/use-grid-wheel'\nimport { useCache } from '../hooks/use-cache'\nimport { useGridTouch } from '../hooks/use-grid-touch'\nimport { virtualizedGridProps } from '../props'\nimport { getRTLOffsetType, getScrollDir, isRTL } from '../utils'\nimport {\n  AUTO_ALIGNMENT,\n  BACKWARD,\n  FORWARD,\n  ITEM_RENDER_EVT,\n  RTL,\n  RTL_OFFSET_NAG,\n  RTL_OFFSET_POS_ASC,\n  RTL_OFFSET_POS_DESC,\n  SCROLL_EVT,\n} from '../defaults'\n\nimport type {\n  CSSProperties,\n  Ref,\n  StyleValue,\n  UnwrapRef,\n  VNode,\n  VNodeChild,\n} from 'vue'\nimport type {\n  Alignment,\n  GridConstructorProps,\n  GridScrollOptions,\n  GridStates,\n  ScrollbarExpose,\n} from '../types'\nimport type { VirtualizedGridProps } from '../props'\nimport type { DynamicSizeGridInstance } from '../components/dynamic-size-grid.ts'\n\nconst createGrid = ({\n  name,\n  clearCache,\n  getColumnPosition,\n  getColumnStartIndexForOffset,\n  getColumnStopIndexForStartIndex,\n  getEstimatedTotalHeight,\n  getEstimatedTotalWidth,\n  getColumnOffset,\n  getRowOffset,\n  getRowPosition,\n  getRowStartIndexForOffset,\n  getRowStopIndexForStartIndex,\n\n  initCache,\n  injectToInstance,\n  validateProps,\n}: GridConstructorProps<VirtualizedGridProps>) => {\n  return defineComponent({\n    name: name ?? 'ElVirtualList',\n    props: virtualizedGridProps,\n    emits: [ITEM_RENDER_EVT, SCROLL_EVT],\n    setup(props, { emit, expose, slots }) {\n      const ns = useNamespace('vl')\n\n      validateProps(props)\n      const instance = getCurrentInstance()!\n      const cache = ref(initCache(props, instance))\n      injectToInstance?.(instance, cache)\n      // refs\n      // here windowRef and innerRef can be type of HTMLElement\n      // or user defined component type, depends on the type passed\n      // by user\n      const windowRef = ref<HTMLElement>()\n      const hScrollbar = ref<ScrollbarExpose>()\n      const vScrollbar = ref<ScrollbarExpose>()\n      // innerRef is the actual container element which contains all the elements\n      const innerRef = ref<HTMLElement>()\n      const states = ref<GridStates>({\n        isScrolling: false,\n        scrollLeft: isNumber(props.initScrollLeft) ? props.initScrollLeft : 0,\n        scrollTop: isNumber(props.initScrollTop) ? props.initScrollTop : 0,\n        updateRequested: false,\n        xAxisScrollDir: FORWARD,\n        yAxisScrollDir: FORWARD,\n      })\n\n      const getItemStyleCache = useCache()\n\n      // computed\n      const parsedHeight = computed(() =>\n        Number.parseInt(`${props.height}`, 10)\n      )\n      const parsedWidth = computed(() => Number.parseInt(`${props.width}`, 10))\n      const columnsToRender = computed(() => {\n        const { totalColumn, totalRow, columnCache } = props\n        const { isScrolling, xAxisScrollDir, scrollLeft } = unref(states)\n\n        if (totalColumn === 0 || totalRow === 0) {\n          return [0, 0, 0, 0]\n        }\n\n        const startIndex = getColumnStartIndexForOffset(\n          props,\n          scrollLeft,\n          unref(cache)\n        )\n        const stopIndex = getColumnStopIndexForStartIndex(\n          props,\n          startIndex,\n          scrollLeft,\n          unref(cache)\n        )\n\n        const cacheBackward =\n          !isScrolling || xAxisScrollDir === BACKWARD\n            ? Math.max(1, columnCache)\n            : 1\n        const cacheForward =\n          !isScrolling || xAxisScrollDir === FORWARD\n            ? Math.max(1, columnCache)\n            : 1\n\n        return [\n          Math.max(0, startIndex - cacheBackward),\n          Math.max(0, Math.min(totalColumn! - 1, stopIndex + cacheForward)),\n          startIndex,\n          stopIndex,\n        ]\n      })\n\n      const rowsToRender = computed(() => {\n        const { totalColumn, totalRow, rowCache } = props\n        const { isScrolling, yAxisScrollDir, scrollTop } = unref(states)\n\n        if (totalColumn === 0 || totalRow === 0) {\n          return [0, 0, 0, 0]\n        }\n\n        const startIndex = getRowStartIndexForOffset(\n          props,\n          scrollTop,\n          unref(cache)\n        )\n        const stopIndex = getRowStopIndexForStartIndex(\n          props,\n          startIndex,\n          scrollTop,\n          unref(cache)\n        )\n\n        const cacheBackward =\n          !isScrolling || yAxisScrollDir === BACKWARD\n            ? Math.max(1, rowCache)\n            : 1\n        const cacheForward =\n          !isScrolling || yAxisScrollDir === FORWARD ? Math.max(1, rowCache) : 1\n\n        return [\n          Math.max(0, startIndex - cacheBackward),\n          Math.max(0, Math.min(totalRow! - 1, stopIndex + cacheForward)),\n          startIndex,\n          stopIndex,\n        ]\n      })\n\n      const estimatedTotalHeight = computed(() =>\n        getEstimatedTotalHeight(props, unref(cache))\n      )\n      const estimatedTotalWidth = computed(() =>\n        getEstimatedTotalWidth(props, unref(cache))\n      )\n\n      const windowStyle = computed<StyleValue>(() => [\n        {\n          position: 'relative',\n          overflow: 'hidden',\n          WebkitOverflowScrolling: 'touch',\n          willChange: 'transform',\n        },\n        {\n          direction: props.direction,\n          height: isNumber(props.height) ? `${props.height}px` : props.height,\n          width: isNumber(props.width) ? `${props.width}px` : props.width,\n        },\n        props.style ?? {},\n      ])\n\n      const innerStyle = computed(() => {\n        const width = `${unref(estimatedTotalWidth)}px`\n        const height = `${unref(estimatedTotalHeight)}px`\n\n        return {\n          height,\n          pointerEvents: unref(states).isScrolling ? 'none' : undefined,\n          width,\n\n          // fix scrolling issues in Firefox.\n          margin: 0,\n          boxSizing: 'border-box',\n        }\n      })\n\n      // methods\n      const emitEvents = () => {\n        const { totalColumn, totalRow } = props\n\n        if (totalColumn! > 0 && totalRow! > 0) {\n          const [\n            columnCacheStart,\n            columnCacheEnd,\n            columnVisibleStart,\n            columnVisibleEnd,\n          ] = unref(columnsToRender)\n          const [rowCacheStart, rowCacheEnd, rowVisibleStart, rowVisibleEnd] =\n            unref(rowsToRender)\n          // emit the render item event with\n          // [xAxisInvisibleStart, xAxisInvisibleEnd, xAxisVisibleStart, xAxisVisibleEnd]\n          // [yAxisInvisibleStart, yAxisInvisibleEnd, yAxisVisibleStart, yAxisVisibleEnd]\n          emit(ITEM_RENDER_EVT, {\n            columnCacheStart,\n            columnCacheEnd,\n            rowCacheStart,\n            rowCacheEnd,\n            columnVisibleStart,\n            columnVisibleEnd,\n            rowVisibleStart,\n            rowVisibleEnd,\n          })\n        }\n\n        const {\n          scrollLeft,\n          scrollTop,\n          updateRequested,\n          xAxisScrollDir,\n          yAxisScrollDir,\n        } = unref(states)\n        emit(SCROLL_EVT, {\n          xAxisScrollDir,\n          scrollLeft,\n          yAxisScrollDir,\n          scrollTop,\n          updateRequested,\n        })\n      }\n\n      const onScroll = (e: Event) => {\n        const {\n          clientHeight,\n          clientWidth,\n          scrollHeight,\n          scrollLeft,\n          scrollTop,\n          scrollWidth,\n        } = e.currentTarget as HTMLElement\n\n        const _states = unref(states)\n\n        if (\n          _states.scrollTop === scrollTop &&\n          _states.scrollLeft === scrollLeft\n        ) {\n          return\n        }\n\n        let _scrollLeft = scrollLeft\n\n        if (isRTL(props.direction)) {\n          switch (getRTLOffsetType()) {\n            case RTL_OFFSET_NAG:\n              _scrollLeft = -scrollLeft\n              break\n            case RTL_OFFSET_POS_DESC:\n              _scrollLeft = scrollWidth - clientWidth - scrollLeft\n              break\n          }\n        }\n\n        states.value = {\n          ..._states,\n          isScrolling: true,\n          scrollLeft: _scrollLeft,\n          scrollTop: Math.max(\n            0,\n            Math.min(scrollTop, scrollHeight - clientHeight)\n          ),\n          updateRequested: true,\n          xAxisScrollDir: getScrollDir(_states.scrollLeft, _scrollLeft),\n          yAxisScrollDir: getScrollDir(_states.scrollTop, scrollTop),\n        }\n\n        nextTick(() => resetIsScrolling())\n\n        onUpdated()\n        emitEvents()\n      }\n\n      const onVerticalScroll = (distance: number, totalSteps: number) => {\n        const height = unref(parsedHeight)\n        const offset =\n          ((estimatedTotalHeight.value - height) / totalSteps) * distance\n        scrollTo({\n          scrollTop: Math.min(estimatedTotalHeight.value - height, offset),\n        })\n      }\n\n      const onHorizontalScroll = (distance: number, totalSteps: number) => {\n        const width = unref(parsedWidth)\n        const offset =\n          ((estimatedTotalWidth.value - width) / totalSteps) * distance\n        scrollTo({\n          scrollLeft: Math.min(estimatedTotalWidth.value - width, offset),\n        })\n      }\n\n      const { onWheel } = useGridWheel(\n        {\n          atXStartEdge: computed(() => states.value.scrollLeft <= 0),\n          atXEndEdge: computed(\n            () =>\n              states.value.scrollLeft >=\n              estimatedTotalWidth.value - unref(parsedWidth)\n          ),\n          atYStartEdge: computed(() => states.value.scrollTop <= 0),\n          atYEndEdge: computed(\n            () =>\n              states.value.scrollTop >=\n              estimatedTotalHeight.value - unref(parsedHeight)\n          ),\n        },\n        (x: number, y: number) => {\n          hScrollbar.value?.onMouseUp?.()\n          vScrollbar.value?.onMouseUp?.()\n          const width = unref(parsedWidth)\n          const height = unref(parsedHeight)\n          scrollTo({\n            scrollLeft: Math.min(\n              states.value.scrollLeft + x,\n              estimatedTotalWidth.value - width\n            ),\n            scrollTop: Math.min(\n              states.value.scrollTop + y,\n              estimatedTotalHeight.value - height\n            ),\n          })\n        }\n      )\n\n      useEventListener(windowRef, 'wheel', onWheel, {\n        passive: false,\n      })\n\n      const scrollTo = ({\n        scrollLeft = states.value.scrollLeft,\n        scrollTop = states.value.scrollTop,\n      }: GridScrollOptions) => {\n        scrollLeft = Math.max(scrollLeft, 0)\n        scrollTop = Math.max(scrollTop, 0)\n        const _states = unref(states)\n        if (\n          scrollTop === _states.scrollTop &&\n          scrollLeft === _states.scrollLeft\n        ) {\n          return\n        }\n\n        states.value = {\n          ..._states,\n          xAxisScrollDir: getScrollDir(_states.scrollLeft, scrollLeft),\n          yAxisScrollDir: getScrollDir(_states.scrollTop, scrollTop),\n          scrollLeft,\n          scrollTop,\n          updateRequested: true,\n        }\n\n        nextTick(() => resetIsScrolling())\n\n        onUpdated()\n        emitEvents()\n      }\n\n      const { touchStartX, touchStartY, handleTouchStart, handleTouchMove } =\n        useGridTouch(\n          windowRef,\n          states,\n          scrollTo,\n          estimatedTotalWidth,\n          estimatedTotalHeight,\n          parsedWidth,\n          parsedHeight\n        )\n\n      const scrollToItem = (\n        rowIndex = 0,\n        columnIdx = 0,\n        alignment: Alignment = AUTO_ALIGNMENT\n      ) => {\n        const _states = unref(states)\n        columnIdx = Math.max(0, Math.min(columnIdx, props.totalColumn! - 1))\n        rowIndex = Math.max(0, Math.min(rowIndex, props.totalRow! - 1))\n        const scrollBarWidth = getScrollBarWidth(ns.namespace.value)\n\n        const _cache = unref(cache)\n        const estimatedHeight = getEstimatedTotalHeight(props, _cache)\n        const estimatedWidth = getEstimatedTotalWidth(props, _cache)\n\n        scrollTo({\n          scrollLeft: getColumnOffset(\n            props,\n            columnIdx,\n            alignment,\n            _states.scrollLeft,\n            _cache,\n            estimatedWidth > (props.width as number) ? scrollBarWidth : 0\n          ),\n          scrollTop: getRowOffset(\n            props,\n            rowIndex,\n            alignment,\n            _states.scrollTop,\n            _cache,\n            estimatedHeight > (props.height as number) ? scrollBarWidth : 0\n          ),\n        })\n      }\n\n      const getItemStyle = (rowIndex: number, columnIndex: number) => {\n        const { columnWidth, direction, rowHeight } = props\n        const itemStyleCache = getItemStyleCache.value(\n          clearCache && columnWidth,\n          clearCache && rowHeight,\n          clearCache && direction\n        )\n        // since there was no need to introduce an nested array into cache object\n        // we use row,column to construct the key for indexing the map.\n        const key = `${rowIndex},${columnIndex}`\n\n        if (hasOwn(itemStyleCache, key)) {\n          return itemStyleCache[key] as CSSProperties\n        } else {\n          const [, left] = getColumnPosition(props, columnIndex, unref(cache))\n          const _cache = unref(cache)\n\n          const rtl = isRTL(direction)\n          const [height, top] = getRowPosition(props, rowIndex, _cache)\n          const [width] = getColumnPosition(props, columnIndex, _cache)\n\n          itemStyleCache[key] = {\n            position: 'absolute',\n            left: rtl ? undefined : `${left}px`,\n            right: rtl ? `${left}px` : undefined,\n            top: `${top}px`,\n            height: `${height}px`,\n            width: `${width}px`,\n          }\n\n          return itemStyleCache[key] as CSSProperties\n        }\n      }\n\n      // TODO: debounce setting is scrolling.\n\n      const resetIsScrolling = () => {\n        states.value.isScrolling = false\n        nextTick(() => {\n          getItemStyleCache.value(-1, null, null)\n        })\n      }\n\n      // life cycles\n      onMounted(() => {\n        // for SSR\n        if (!isClient) return\n        const { initScrollLeft, initScrollTop } = props\n        const windowElement = unref(windowRef)\n        if (windowElement) {\n          if (isNumber(initScrollLeft)) {\n            windowElement.scrollLeft = initScrollLeft\n          }\n          if (isNumber(initScrollTop)) {\n            windowElement.scrollTop = initScrollTop\n          }\n        }\n        emitEvents()\n      })\n\n      const onUpdated = () => {\n        const { direction } = props\n        const { scrollLeft, scrollTop, updateRequested } = unref(states)\n\n        const windowElement = unref(windowRef)\n        if (updateRequested && windowElement) {\n          if (direction === RTL) {\n            switch (getRTLOffsetType()) {\n              case RTL_OFFSET_NAG: {\n                windowElement.scrollLeft = -scrollLeft\n                break\n              }\n              case RTL_OFFSET_POS_ASC: {\n                windowElement.scrollLeft = scrollLeft\n                break\n              }\n              default: {\n                const { clientWidth, scrollWidth } = windowElement\n                windowElement.scrollLeft =\n                  scrollWidth - clientWidth - scrollLeft\n                break\n              }\n            }\n          } else {\n            windowElement.scrollLeft = Math.max(0, scrollLeft)\n          }\n\n          windowElement.scrollTop = Math.max(0, scrollTop)\n        }\n      }\n\n      const { resetAfterColumnIndex, resetAfterRowIndex, resetAfter } =\n        instance.proxy as DynamicSizeGridInstance\n\n      expose({\n        windowRef,\n        innerRef,\n        getItemStyleCache,\n        touchStartX,\n        touchStartY,\n        handleTouchStart,\n        handleTouchMove,\n        scrollTo,\n        scrollToItem,\n        states,\n        resetAfterColumnIndex,\n        resetAfterRowIndex,\n        resetAfter,\n      })\n\n      // rendering part\n\n      const renderScrollbars = () => {\n        const {\n          scrollbarAlwaysOn,\n          scrollbarStartGap,\n          scrollbarEndGap,\n          totalColumn,\n          totalRow,\n        } = props\n\n        const width = unref(parsedWidth)\n        const height = unref(parsedHeight)\n        const estimatedWidth = unref(estimatedTotalWidth)\n        const estimatedHeight = unref(estimatedTotalHeight)\n        const { scrollLeft, scrollTop } = unref(states)\n        const horizontalScrollbar = h(Scrollbar, {\n          ref: hScrollbar,\n          alwaysOn: scrollbarAlwaysOn,\n          startGap: scrollbarStartGap,\n          endGap: scrollbarEndGap,\n          class: ns.e('horizontal'),\n          clientSize: width,\n          layout: 'horizontal',\n          onScroll: onHorizontalScroll,\n          ratio: (width * 100) / estimatedWidth,\n          scrollFrom: scrollLeft / (estimatedWidth - width),\n          total: totalRow,\n          visible: true,\n        })\n\n        const verticalScrollbar = h(Scrollbar, {\n          ref: vScrollbar,\n          alwaysOn: scrollbarAlwaysOn,\n          startGap: scrollbarStartGap,\n          endGap: scrollbarEndGap,\n          class: ns.e('vertical'),\n          clientSize: height,\n          layout: 'vertical',\n          onScroll: onVerticalScroll,\n          ratio: (height * 100) / estimatedHeight,\n          scrollFrom: scrollTop / (estimatedHeight - height),\n\n          total: totalColumn,\n          visible: true,\n        })\n\n        return {\n          horizontalScrollbar,\n          verticalScrollbar,\n        }\n      }\n\n      const renderItems = () => {\n        const [columnStart, columnEnd] = unref(columnsToRender)\n        const [rowStart, rowEnd] = unref(rowsToRender)\n        const { data, totalColumn, totalRow, useIsScrolling, itemKey } = props\n        const children: VNodeChild[] = []\n        if (totalRow > 0 && totalColumn > 0) {\n          for (let row = rowStart; row <= rowEnd; row++) {\n            for (let column = columnStart; column <= columnEnd; column++) {\n              const key = itemKey({ columnIndex: column, data, rowIndex: row })\n              children.push(\n                h(\n                  Fragment,\n                  { key },\n                  slots.default?.({\n                    columnIndex: column,\n                    data,\n                    isScrolling: useIsScrolling\n                      ? unref(states).isScrolling\n                      : undefined,\n                    style: getItemStyle(row, column),\n                    rowIndex: row,\n                  })\n                )\n              )\n            }\n          }\n        }\n        return children\n      }\n\n      const renderInner = () => {\n        const Inner = resolveDynamicComponent(props.innerElement) as VNode\n        const children = renderItems()\n        return [\n          h(\n            Inner,\n            mergeProps(props.innerProps, {\n              style: unref(innerStyle),\n              ref: innerRef,\n            }),\n            !isString(Inner)\n              ? {\n                  default: () => children,\n                }\n              : children\n          ),\n        ]\n      }\n\n      const renderWindow = () => {\n        const Container = resolveDynamicComponent(\n          props.containerElement\n        ) as VNode\n        const { horizontalScrollbar, verticalScrollbar } = renderScrollbars()\n        const Inner = renderInner()\n\n        return h(\n          'div',\n          {\n            key: 0,\n            class: ns.e('wrapper'),\n            role: props.role,\n          },\n          [\n            h(\n              Container,\n              {\n                class: props.className,\n                style: unref(windowStyle),\n                onScroll,\n                ref: windowRef,\n              },\n              !isString(Container) ? { default: () => Inner } : Inner\n            ),\n            horizontalScrollbar,\n            verticalScrollbar,\n          ]\n        )\n      }\n\n      return renderWindow\n    },\n  })\n}\n\nexport default createGrid\n\nexport type GridInstance = InstanceType<ReturnType<typeof createGrid>> &\n  UnwrapRef<{\n    windowRef: Ref<HTMLElement>\n    innerRef: Ref<HTMLElement>\n    getItemStyleCache: ReturnType<typeof useCache>\n    scrollTo: (scrollOptions: GridScrollOptions) => void\n    scrollToItem: (\n      rowIndex: number,\n      columnIndex: number,\n      alignment: Alignment\n    ) => void\n    states: Ref<GridStates>\n  }>\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}