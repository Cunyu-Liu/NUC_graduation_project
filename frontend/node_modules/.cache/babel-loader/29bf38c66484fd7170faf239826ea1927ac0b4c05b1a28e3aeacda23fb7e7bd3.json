{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.find.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.iterator.some.js\";\nimport { reactive } from 'vue';\nimport { isNil } from 'lodash-unified';\nimport { markNodeData, NODE_KEY } from './util.mjs';\nimport { hasOwn, isArray, isFunction, isString } from '@vue/shared';\nimport { isBoolean, isUndefined } from '../../../../utils/types.mjs';\nconst getChildState = node => {\n  let all = true;\n  let none = true;\n  let allWithoutDisable = true;\n  let isEffectivelyChecked = true;\n  for (let i = 0, j = node.length; i < j; i++) {\n    const n = node[i];\n    if (n.checked !== true || n.indeterminate) {\n      all = false;\n      if (!n.disabled) {\n        allWithoutDisable = false;\n      }\n    }\n    if (n.checked !== false || n.indeterminate) {\n      none = false;\n    }\n    if (!n.isEffectivelyChecked) {\n      isEffectivelyChecked = false;\n    }\n  }\n  return {\n    all,\n    none,\n    allWithoutDisable,\n    half: !all && !none,\n    isEffectivelyChecked\n  };\n};\nconst reInitChecked = function (node) {\n  if (node.childNodes.length === 0 || node.loading) {\n    node.isEffectivelyChecked = node.disabled || node.checked;\n    return;\n  }\n  const {\n    all,\n    none,\n    half,\n    isEffectivelyChecked\n  } = getChildState(node.childNodes);\n  node.isEffectivelyChecked = isEffectivelyChecked;\n  if (all) {\n    node.checked = true;\n    node.indeterminate = false;\n  } else if (half) {\n    node.checked = false;\n    node.indeterminate = true;\n  } else if (none) {\n    node.checked = false;\n    node.indeterminate = false;\n  }\n  const parent = node.parent;\n  if (!parent || parent.level === 0) return;\n  if (!node.store.checkStrictly) {\n    reInitChecked(parent);\n  }\n};\nconst getPropertyFromData = function (node, prop) {\n  const props = node.store.props;\n  const data = node.data || {};\n  const config = props[prop];\n  if (isFunction(config)) {\n    return config(data, node);\n  } else if (isString(config)) {\n    return data[config];\n  } else if (isUndefined(config)) {\n    const dataProp = data[prop];\n    return isUndefined(dataProp) ? \"\" : dataProp;\n  }\n};\nconst setCanFocus = function (childNodes, focus) {\n  childNodes.forEach(item => {\n    item.canFocus = focus;\n    setCanFocus(item.childNodes, focus);\n  });\n};\nlet nodeIdSeed = 0;\nclass Node {\n  constructor(options) {\n    this.isLeafByUser = void 0;\n    this.isLeaf = void 0;\n    this.isEffectivelyChecked = false;\n    this.id = nodeIdSeed++;\n    this.text = null;\n    this.checked = false;\n    this.indeterminate = false;\n    this.data = null;\n    this.expanded = false;\n    this.parent = null;\n    this.visible = true;\n    this.isCurrent = false;\n    this.canFocus = false;\n    for (const name in options) {\n      if (hasOwn(options, name)) {\n        this[name] = options[name];\n      }\n    }\n    this.level = 0;\n    this.loaded = false;\n    this.childNodes = [];\n    this.loading = false;\n    if (this.parent) {\n      this.level = this.parent.level + 1;\n    }\n  }\n  initialize() {\n    var _a;\n    const store = this.store;\n    if (!store) {\n      throw new Error(\"[Node]store is required!\");\n    }\n    store.registerNode(this);\n    const props = store.props;\n    if (props && typeof props.isLeaf !== \"undefined\") {\n      const isLeaf = getPropertyFromData(this, \"isLeaf\");\n      if (isBoolean(isLeaf)) {\n        this.isLeafByUser = isLeaf;\n      }\n    }\n    if (store.lazy !== true && this.data) {\n      this.setData(this.data);\n      if (store.defaultExpandAll) {\n        this.expanded = true;\n        this.canFocus = true;\n      }\n    } else if (this.level > 0 && store.lazy && store.defaultExpandAll && !this.isLeafByUser) {\n      this.expand();\n    }\n    if (!isArray(this.data)) {\n      markNodeData(this, this.data);\n    }\n    if (!this.data) return;\n    const defaultExpandedKeys = store.defaultExpandedKeys;\n    const key = store.key;\n    if (key && !isNil(this.key) && defaultExpandedKeys && defaultExpandedKeys.includes(this.key)) {\n      this.expand(null, store.autoExpandParent);\n    }\n    if (key && store.currentNodeKey !== void 0 && this.key === store.currentNodeKey) {\n      store.currentNode && (store.currentNode.isCurrent = false);\n      store.currentNode = this;\n      store.currentNode.isCurrent = true;\n    }\n    if (store.lazy) {\n      store._initDefaultCheckedNode(this);\n    }\n    this.updateLeafState();\n    if (this.level === 1 || ((_a = this.parent) == null ? void 0 : _a.expanded) === true) this.canFocus = true;\n  }\n  setData(data) {\n    if (!isArray(data)) {\n      markNodeData(this, data);\n    }\n    this.data = data;\n    this.childNodes = [];\n    let children;\n    if (this.level === 0 && isArray(this.data)) {\n      children = this.data;\n    } else {\n      children = getPropertyFromData(this, \"children\") || [];\n    }\n    for (let i = 0, j = children.length; i < j; i++) {\n      this.insertChild({\n        data: children[i]\n      });\n    }\n  }\n  get label() {\n    return getPropertyFromData(this, \"label\");\n  }\n  get key() {\n    const nodeKey = this.store.key;\n    if (this.data) return this.data[nodeKey];\n    return null;\n  }\n  get disabled() {\n    return getPropertyFromData(this, \"disabled\");\n  }\n  get nextSibling() {\n    const parent = this.parent;\n    if (parent) {\n      const index = parent.childNodes.indexOf(this);\n      if (index > -1) {\n        return parent.childNodes[index + 1];\n      }\n    }\n    return null;\n  }\n  get previousSibling() {\n    const parent = this.parent;\n    if (parent) {\n      const index = parent.childNodes.indexOf(this);\n      if (index > -1) {\n        return index > 0 ? parent.childNodes[index - 1] : null;\n      }\n    }\n    return null;\n  }\n  contains(target, deep = true) {\n    return (this.childNodes || []).some(child => child === target || deep && child.contains(target));\n  }\n  remove() {\n    const parent = this.parent;\n    if (parent) {\n      parent.removeChild(this);\n    }\n  }\n  insertChild(child, index, batch) {\n    if (!child) throw new Error(\"InsertChild error: child is required.\");\n    if (!(child instanceof Node)) {\n      if (!batch) {\n        const children = this.getChildren(true);\n        if (!(children == null ? void 0 : children.includes(child.data))) {\n          if (isUndefined(index) || index < 0) {\n            children == null ? void 0 : children.push(child.data);\n          } else {\n            children == null ? void 0 : children.splice(index, 0, child.data);\n          }\n        }\n      }\n      Object.assign(child, {\n        parent: this,\n        store: this.store\n      });\n      child = reactive(new Node(child));\n      if (child instanceof Node) {\n        child.initialize();\n      }\n    }\n    child.level = this.level + 1;\n    if (isUndefined(index) || index < 0) {\n      this.childNodes.push(child);\n    } else {\n      this.childNodes.splice(index, 0, child);\n    }\n    this.updateLeafState();\n  }\n  insertBefore(child, ref) {\n    let index;\n    if (ref) {\n      index = this.childNodes.indexOf(ref);\n    }\n    this.insertChild(child, index);\n  }\n  insertAfter(child, ref) {\n    let index;\n    if (ref) {\n      index = this.childNodes.indexOf(ref);\n      if (index !== -1) index += 1;\n    }\n    this.insertChild(child, index);\n  }\n  removeChild(child) {\n    const children = this.getChildren() || [];\n    const dataIndex = children.indexOf(child.data);\n    if (dataIndex > -1) {\n      children.splice(dataIndex, 1);\n    }\n    const index = this.childNodes.indexOf(child);\n    if (index > -1) {\n      this.store && this.store.deregisterNode(child);\n      child.parent = null;\n      this.childNodes.splice(index, 1);\n    }\n    this.updateLeafState();\n  }\n  removeChildByData(data) {\n    const targetNode = this.childNodes.find(child => child.data === data);\n    if (targetNode) {\n      this.removeChild(targetNode);\n    }\n  }\n  expand(callback, expandParent) {\n    const done = () => {\n      if (expandParent) {\n        let parent = this.parent;\n        while (parent && parent.level > 0) {\n          parent.expanded = true;\n          parent = parent.parent;\n        }\n      }\n      this.expanded = true;\n      if (callback) callback();\n      setCanFocus(this.childNodes, true);\n    };\n    if (this.shouldLoadData()) {\n      this.loadData(data => {\n        if (isArray(data)) {\n          if (this.checked) {\n            this.setChecked(true, true);\n          } else if (!this.store.checkStrictly) {\n            reInitChecked(this);\n          }\n          done();\n        }\n      });\n    } else {\n      done();\n    }\n  }\n  doCreateChildren(array, defaultProps = {}) {\n    array.forEach(item => {\n      this.insertChild(Object.assign({\n        data: item\n      }, defaultProps), void 0, true);\n    });\n  }\n  collapse() {\n    this.expanded = false;\n    setCanFocus(this.childNodes, false);\n  }\n  shouldLoadData() {\n    return Boolean(this.store.lazy === true && this.store.load && !this.loaded);\n  }\n  updateLeafState() {\n    if (this.store.lazy === true && this.loaded !== true && typeof this.isLeafByUser !== \"undefined\") {\n      this.isLeaf = this.isLeafByUser;\n      this.isEffectivelyChecked = this.isLeaf && this.disabled;\n      return;\n    }\n    const childNodes = this.childNodes;\n    if (!this.store.lazy || this.store.lazy === true && this.loaded === true) {\n      this.isLeaf = !childNodes || childNodes.length === 0;\n      this.isEffectivelyChecked = this.isLeaf && this.disabled;\n      return;\n    }\n    this.isLeaf = false;\n  }\n  setChecked(value, deep, recursion, passValue) {\n    this.indeterminate = value === \"half\";\n    this.checked = value === true;\n    this.isEffectivelyChecked = !this.childNodes.length && (this.disabled || this.checked);\n    if (this.store.checkStrictly) return;\n    if (!(this.shouldLoadData() && !this.store.checkDescendants)) {\n      const handleDescendants = () => {\n        if (deep) {\n          const childNodes = this.childNodes;\n          for (let i = 0, j = childNodes.length; i < j; i++) {\n            const child = childNodes[i];\n            passValue = passValue || value !== false;\n            const isCheck = child.disabled && child.isLeaf ? child.checked : passValue;\n            child.setChecked(isCheck, deep, true, passValue);\n          }\n          const {\n            half,\n            all,\n            isEffectivelyChecked\n          } = getChildState(childNodes);\n          if (!all) {\n            this.checked = all;\n            this.indeterminate = half;\n          }\n          this.isEffectivelyChecked = !this.childNodes.length ? this.disabled || this.checked : isEffectivelyChecked;\n        }\n      };\n      if (this.shouldLoadData()) {\n        this.loadData(() => {\n          handleDescendants();\n          reInitChecked(this);\n        }, {\n          checked: value !== false\n        });\n        return;\n      } else {\n        handleDescendants();\n      }\n    }\n    const parent = this.parent;\n    if (!parent || parent.level === 0) return;\n    if (!recursion) {\n      reInitChecked(parent);\n    }\n  }\n  getChildren(forceInit = false) {\n    if (this.level === 0) return this.data;\n    const data = this.data;\n    if (!data) return null;\n    const props = this.store.props;\n    let children = \"children\";\n    if (props) {\n      children = props.children || \"children\";\n    }\n    if (isUndefined(data[children])) {\n      data[children] = null;\n    }\n    if (forceInit && !data[children]) {\n      data[children] = [];\n    }\n    return data[children];\n  }\n  updateChildren() {\n    const newData = this.getChildren() || [];\n    const oldData = this.childNodes.map(node => node.data);\n    const newDataMap = {};\n    const newNodes = [];\n    newData.forEach((item, index) => {\n      const key = item[NODE_KEY];\n      const isNodeExists = !!key && oldData.some(data => (data == null ? void 0 : data[NODE_KEY]) === key);\n      if (isNodeExists) {\n        newDataMap[key] = {\n          index,\n          data: item\n        };\n      } else {\n        newNodes.push({\n          index,\n          data: item\n        });\n      }\n    });\n    if (!this.store.lazy) {\n      oldData.forEach(item => {\n        if (!newDataMap[item == null ? void 0 : item[NODE_KEY]]) this.removeChildByData(item);\n      });\n    }\n    newNodes.forEach(({\n      index,\n      data\n    }) => {\n      this.insertChild({\n        data\n      }, index);\n    });\n    this.updateLeafState();\n  }\n  loadData(callback, defaultProps = {}) {\n    if (this.store.lazy === true && this.store.load && !this.loaded && (!this.loading || Object.keys(defaultProps).length)) {\n      this.loading = true;\n      const resolve = children => {\n        this.childNodes = [];\n        this.doCreateChildren(children, defaultProps);\n        this.loaded = true;\n        this.loading = false;\n        this.updateLeafState();\n        if (callback) {\n          callback.call(this, children);\n        }\n      };\n      const reject = () => {\n        this.loading = false;\n      };\n      this.store.load(this, resolve, reject);\n    } else {\n      if (callback) {\n        callback.call(this);\n      }\n    }\n  }\n  eachNode(callback) {\n    const arr = [this];\n    while (arr.length) {\n      const node = arr.shift();\n      arr.unshift(...node.childNodes);\n      callback(node);\n    }\n  }\n  reInitChecked() {\n    if (this.store.checkStrictly) return;\n    reInitChecked(this);\n  }\n}\nexport { Node as default, getChildState };","map":{"version":3,"names":["getChildState","node","all","none","allWithoutDisable","isEffectivelyChecked","i","j","length","n","checked","indeterminate","disabled","half","reInitChecked","childNodes","loading","parent","level","store","checkStrictly","getPropertyFromData","prop","props","data","config","isFunction","isString","isUndefined","dataProp","setCanFocus","focus","forEach","item","canFocus","nodeIdSeed","Node","constructor","options","isLeafByUser","isLeaf","id","text","expanded","visible","isCurrent","name","hasOwn","loaded","initialize","_a","Error","registerNode","isBoolean","lazy","setData","defaultExpandAll","expand","isArray","markNodeData","defaultExpandedKeys","key","isNil","includes","autoExpandParent","currentNodeKey","currentNode","_initDefaultCheckedNode","updateLeafState","children","insertChild","label","nodeKey","nextSibling","index","indexOf","previousSibling","contains","target","deep","some","child","remove","removeChild","batch","getChildren","push","splice","Object","assign","reactive","insertBefore","ref","insertAfter","dataIndex","deregisterNode","removeChildByData","targetNode","find","callback","expandParent","done","shouldLoadData","loadData","setChecked","doCreateChildren","array","defaultProps","collapse","Boolean","load","value","recursion","passValue","checkDescendants","handleDescendants","isCheck","forceInit","updateChildren","newData","oldData","map","newDataMap","newNodes","NODE_KEY","isNodeExists","keys","resolve","call","reject","eachNode","arr","shift","unshift"],"sources":["../../../../../../../packages/components/tree/src/model/node.ts"],"sourcesContent":["import { reactive } from 'vue'\nimport { isNil } from 'lodash-unified'\nimport {\n  hasOwn,\n  isArray,\n  isBoolean,\n  isFunction,\n  isString,\n  isUndefined,\n} from '@element-plus/utils'\nimport { NODE_KEY, markNodeData } from './util'\n\nimport type TreeStore from './tree-store'\nimport type { Nullable } from '@element-plus/utils'\nimport type {\n  FakeNode,\n  TreeKey,\n  TreeNodeChildState,\n  TreeNodeData,\n  TreeNodeLoadedDefaultProps,\n  TreeNodeOptions,\n} from '../tree.type'\n\nexport const getChildState = (node: Node[]): TreeNodeChildState => {\n  let all = true\n  let none = true\n  let allWithoutDisable = true\n  let isEffectivelyChecked = true\n  for (let i = 0, j = node.length; i < j; i++) {\n    const n = node[i]\n    if (n.checked !== true || n.indeterminate) {\n      all = false\n      if (!n.disabled) {\n        allWithoutDisable = false\n      }\n    }\n    if (n.checked !== false || n.indeterminate) {\n      none = false\n    }\n    if (!n.isEffectivelyChecked) {\n      isEffectivelyChecked = false\n    }\n  }\n\n  return {\n    all,\n    none,\n    allWithoutDisable,\n    half: !all && !none,\n    isEffectivelyChecked,\n  }\n}\n\nconst reInitChecked = function (node: Node): void {\n  if (node.childNodes.length === 0 || node.loading) {\n    node.isEffectivelyChecked = node.disabled || node.checked\n    return\n  }\n\n  const { all, none, half, isEffectivelyChecked } = getChildState(\n    node.childNodes\n  )\n  node.isEffectivelyChecked = isEffectivelyChecked\n  if (all) {\n    node.checked = true\n    node.indeterminate = false\n  } else if (half) {\n    node.checked = false\n    node.indeterminate = true\n  } else if (none) {\n    node.checked = false\n    node.indeterminate = false\n  }\n\n  const parent = node.parent\n  if (!parent || parent.level === 0) return\n\n  if (!node.store.checkStrictly) {\n    reInitChecked(parent)\n  }\n}\n\nconst getPropertyFromData = function (node: Node, prop: string): any {\n  const props = node.store.props\n  const data = node.data || {}\n  const config = (props as any)[prop]\n\n  if (isFunction(config)) {\n    return config(data, node)\n  } else if (isString(config)) {\n    return data[config]\n  } else if (isUndefined(config)) {\n    const dataProp = data[prop]\n    return isUndefined(dataProp) ? '' : dataProp\n  }\n}\n\nconst setCanFocus = function (childNodes: Node[], focus: boolean): void {\n  childNodes.forEach((item) => {\n    item.canFocus = focus\n    setCanFocus(item.childNodes, focus)\n  })\n}\n\nlet nodeIdSeed = 0\n\nclass Node {\n  id: number\n  text: string | null\n  checked: boolean\n  indeterminate: boolean\n  data: TreeNodeData\n  expanded: boolean\n  parent: Node | null\n  visible: boolean\n  isCurrent: boolean\n  store!: TreeStore\n  isLeafByUser: boolean | undefined = undefined\n  isLeaf: boolean | undefined = undefined\n  canFocus: boolean\n\n  level: number\n  loaded: boolean\n  childNodes: Node[]\n  loading: boolean\n\n  /**\n   * Determines whether the current tree node is effectively checked.\n   *\n   * Rules:\n   * 1. A disabled leaf node is always considered checked.\n   * 2. A non-disabled leaf node reflects its actual checked state.\n   * 3. A non-leaf node is considered checked only when:\n   *    - All of its child nodes are effectively checked, and\n   *    - Each child follows the same evaluation rules:\n   *      - Disabled leaf nodes follow rule #1.\n   *      - Non-leaf child nodes are recursively evaluated under this rule (#3).\n   */\n  isEffectivelyChecked: boolean = false\n\n  constructor(options: TreeNodeOptions) {\n    this.id = nodeIdSeed++\n    this.text = null\n    this.checked = false\n    this.indeterminate = false\n    this.data = null as unknown as TreeNodeData\n    this.expanded = false\n    this.parent = null as Node | null\n    this.visible = true\n    this.isCurrent = false\n    this.canFocus = false\n\n    for (const name in options) {\n      if (hasOwn(options, name)) {\n        this[name] = options[name]\n      }\n    }\n\n    // internal\n    this.level = 0\n    this.loaded = false\n    this.childNodes = []\n    this.loading = false\n\n    if (this.parent) {\n      this.level = this.parent.level + 1\n    }\n  }\n\n  initialize() {\n    const store = this.store\n    if (!store) {\n      throw new Error('[Node]store is required!')\n    }\n    store.registerNode(this)\n\n    const props = store.props\n    if (props && typeof props.isLeaf !== 'undefined') {\n      const isLeaf = getPropertyFromData(this, 'isLeaf')\n      if (isBoolean(isLeaf)) {\n        this.isLeafByUser = isLeaf\n      }\n    }\n\n    if (store.lazy !== true && this.data) {\n      this.setData(this.data)\n\n      if (store.defaultExpandAll) {\n        this.expanded = true\n        this.canFocus = true\n      }\n    } else if (\n      this.level > 0 &&\n      store.lazy &&\n      store.defaultExpandAll &&\n      !this.isLeafByUser\n    ) {\n      this.expand()\n    }\n    if (!isArray(this.data)) {\n      markNodeData(this, this.data)\n    }\n    if (!this.data) return\n\n    const defaultExpandedKeys = store.defaultExpandedKeys\n    const key = store.key\n\n    if (\n      key &&\n      !isNil(this.key) &&\n      defaultExpandedKeys &&\n      defaultExpandedKeys.includes(this.key)\n    ) {\n      this.expand(null, store.autoExpandParent)\n    }\n\n    if (\n      key &&\n      store.currentNodeKey !== undefined &&\n      this.key === store.currentNodeKey\n    ) {\n      store.currentNode && (store.currentNode.isCurrent = false)\n      store.currentNode = this\n      store.currentNode.isCurrent = true\n    }\n\n    if (store.lazy) {\n      store._initDefaultCheckedNode(this)\n    }\n\n    this.updateLeafState()\n    if (this.level === 1 || this.parent?.expanded === true) this.canFocus = true\n  }\n\n  setData(data: TreeNodeData): void {\n    if (!isArray(data)) {\n      markNodeData(this, data)\n    }\n\n    this.data = data\n    this.childNodes = []\n\n    let children\n    if (this.level === 0 && isArray(this.data)) {\n      children = this.data\n    } else {\n      children = getPropertyFromData(this, 'children') || []\n    }\n\n    for (let i = 0, j = children.length; i < j; i++) {\n      this.insertChild({ data: children[i] })\n    }\n  }\n\n  get label(): string {\n    return getPropertyFromData(this, 'label')\n  }\n\n  get key(): TreeKey | null | undefined {\n    const nodeKey = this.store.key\n    if (this.data) return this.data[nodeKey]\n    return null\n  }\n\n  get disabled(): boolean {\n    return getPropertyFromData(this, 'disabled')\n  }\n\n  get nextSibling(): Nullable<Node> {\n    const parent = this.parent\n    if (parent) {\n      const index = parent.childNodes.indexOf(this)\n      if (index > -1) {\n        return parent.childNodes[index + 1]\n      }\n    }\n    return null\n  }\n\n  get previousSibling(): Nullable<Node> {\n    const parent = this.parent\n    if (parent) {\n      const index = parent.childNodes.indexOf(this)\n      if (index > -1) {\n        return index > 0 ? parent.childNodes[index - 1] : null\n      }\n    }\n    return null\n  }\n\n  contains(target: Node, deep = true): boolean {\n    return (this.childNodes || []).some(\n      (child) => child === target || (deep && child.contains(target))\n    )\n  }\n\n  remove(): void {\n    const parent = this.parent\n    if (parent) {\n      parent.removeChild(this)\n    }\n  }\n\n  insertChild(child?: FakeNode | Node, index?: number, batch?: boolean): void {\n    if (!child) throw new Error('InsertChild error: child is required.')\n\n    if (!(child instanceof Node)) {\n      if (!batch) {\n        const children = this.getChildren(true)\n        if (!children?.includes(child.data)) {\n          if (isUndefined(index) || index < 0) {\n            children?.push(child.data)\n          } else {\n            children?.splice(index, 0, child.data)\n          }\n        }\n      }\n      Object.assign(child, {\n        parent: this,\n        store: this.store,\n      })\n      child = reactive(new Node(child as TreeNodeOptions))\n      if (child instanceof Node) {\n        child.initialize()\n      }\n    }\n\n    ;(child as Node).level = this.level + 1\n\n    if (isUndefined(index) || index < 0) {\n      this.childNodes.push(child as Node)\n    } else {\n      this.childNodes.splice(index, 0, child as Node)\n    }\n\n    this.updateLeafState()\n  }\n\n  insertBefore(child: FakeNode | Node, ref: Node): void {\n    let index\n    if (ref) {\n      index = this.childNodes.indexOf(ref)\n    }\n    this.insertChild(child, index)\n  }\n\n  insertAfter(child: FakeNode | Node, ref: Node): void {\n    let index\n    if (ref) {\n      index = this.childNodes.indexOf(ref)\n      if (index !== -1) index += 1\n    }\n    this.insertChild(child, index)\n  }\n\n  removeChild(child: Node): void {\n    const children = this.getChildren() || []\n    const dataIndex = children.indexOf(child.data)\n    if (dataIndex > -1) {\n      children.splice(dataIndex, 1)\n    }\n\n    const index = this.childNodes.indexOf(child)\n\n    if (index > -1) {\n      this.store && this.store.deregisterNode(child)\n      child.parent = null\n      this.childNodes.splice(index, 1)\n    }\n\n    this.updateLeafState()\n  }\n\n  removeChildByData(data: TreeNodeData | null): void {\n    const targetNode = this.childNodes.find((child) => child.data === data)\n\n    if (targetNode) {\n      this.removeChild(targetNode)\n    }\n  }\n\n  expand(callback?: (() => void) | null, expandParent?: boolean): void {\n    const done = () => {\n      if (expandParent) {\n        let parent = this.parent\n        while (parent && parent.level > 0) {\n          parent.expanded = true\n          parent = parent.parent\n        }\n      }\n      this.expanded = true\n      if (callback) callback()\n      setCanFocus(this.childNodes, true)\n    }\n\n    if (this.shouldLoadData()) {\n      this.loadData((data) => {\n        if (isArray(data)) {\n          if (this.checked) {\n            this.setChecked(true, true)\n          } else if (!this.store.checkStrictly) {\n            reInitChecked(this)\n          }\n          done()\n        }\n      })\n    } else {\n      done()\n    }\n  }\n\n  doCreateChildren(\n    array: TreeNodeData[],\n    defaultProps: TreeNodeLoadedDefaultProps = {}\n  ): void {\n    array.forEach((item) => {\n      this.insertChild(\n        Object.assign({ data: item }, defaultProps),\n        undefined,\n        true\n      )\n    })\n  }\n\n  collapse(): void {\n    this.expanded = false\n    setCanFocus(this.childNodes, false)\n  }\n\n  shouldLoadData() {\n    return Boolean(this.store.lazy === true && this.store.load && !this.loaded)\n  }\n\n  updateLeafState(): void {\n    if (\n      this.store.lazy === true &&\n      this.loaded !== true &&\n      typeof this.isLeafByUser !== 'undefined'\n    ) {\n      this.isLeaf = this.isLeafByUser\n      this.isEffectivelyChecked = this.isLeaf && this.disabled\n      return\n    }\n    const childNodes = this.childNodes\n    if (\n      !this.store.lazy ||\n      (this.store.lazy === true && this.loaded === true)\n    ) {\n      this.isLeaf = !childNodes || childNodes.length === 0\n      this.isEffectivelyChecked = this.isLeaf && this.disabled\n      return\n    }\n    this.isLeaf = false\n  }\n\n  setChecked(\n    value?: boolean | string,\n    deep?: boolean,\n    recursion?: boolean,\n    passValue?: boolean\n  ) {\n    this.indeterminate = value === 'half'\n    this.checked = value === true\n    this.isEffectivelyChecked =\n      !this.childNodes.length && (this.disabled || this.checked)\n\n    if (this.store.checkStrictly) return\n\n    if (!(this.shouldLoadData() && !this.store.checkDescendants)) {\n      const handleDescendants = (): void => {\n        if (deep) {\n          const childNodes = this.childNodes\n          for (let i = 0, j = childNodes.length; i < j; i++) {\n            const child = childNodes[i]\n            passValue = passValue || value !== false\n            const isCheck =\n              child.disabled && child.isLeaf ? child.checked : passValue\n            child.setChecked(isCheck, deep, true, passValue)\n          }\n          const { half, all, isEffectivelyChecked } = getChildState(childNodes)\n          if (!all) {\n            this.checked = all\n            this.indeterminate = half\n          }\n          this.isEffectivelyChecked = !this.childNodes.length\n            ? this.disabled || this.checked\n            : isEffectivelyChecked\n        }\n      }\n\n      if (this.shouldLoadData()) {\n        // Only work on lazy load data.\n        this.loadData(\n          () => {\n            handleDescendants()\n            reInitChecked(this)\n          },\n          {\n            checked: value !== false,\n          }\n        )\n        return\n      } else {\n        handleDescendants()\n      }\n    }\n\n    const parent = this.parent\n    if (!parent || parent.level === 0) return\n\n    if (!recursion) {\n      reInitChecked(parent)\n    }\n  }\n\n  getChildren(forceInit = false): TreeNodeData | TreeNodeData[] | null {\n    // this is data\n    if (this.level === 0) return this.data\n    const data = this.data\n    if (!data) return null\n\n    const props = this.store.props\n    let children = 'children'\n    if (props) {\n      children = props.children || 'children'\n    }\n\n    if (isUndefined(data[children])) {\n      data[children] = null\n    }\n\n    if (forceInit && !data[children]) {\n      data[children] = []\n    }\n\n    return data[children]\n  }\n\n  updateChildren(): void {\n    const newData = (this.getChildren() || []) as TreeNodeData[]\n    const oldData = this.childNodes.map((node) => node.data)\n\n    const newDataMap: Record<TreeKey, TreeNodeData> = {}\n    const newNodes: TreeNodeData[] = []\n\n    newData.forEach((item, index) => {\n      const key = item[NODE_KEY]\n      const isNodeExists =\n        !!key && oldData.some((data) => data?.[NODE_KEY] === key)\n      if (isNodeExists) {\n        newDataMap[key] = { index, data: item }\n      } else {\n        newNodes.push({ index, data: item })\n      }\n    })\n\n    if (!this.store.lazy) {\n      oldData.forEach((item) => {\n        if (!newDataMap[item?.[NODE_KEY]]) this.removeChildByData(item)\n      })\n    }\n\n    newNodes.forEach(({ index, data }) => {\n      this.insertChild({ data }, index)\n    })\n\n    this.updateLeafState()\n  }\n\n  loadData(\n    callback: (data?: TreeNodeData[]) => void,\n    defaultProps: TreeNodeLoadedDefaultProps = {}\n  ) {\n    if (\n      this.store.lazy === true &&\n      this.store.load &&\n      !this.loaded &&\n      (!this.loading || Object.keys(defaultProps).length)\n    ) {\n      this.loading = true\n\n      const resolve = (children: TreeNodeData[]) => {\n        this.childNodes = []\n\n        this.doCreateChildren(children, defaultProps)\n        this.loaded = true\n        this.loading = false\n\n        this.updateLeafState()\n        if (callback) {\n          callback.call(this, children)\n        }\n      }\n      const reject = () => {\n        this.loading = false\n      }\n\n      this.store.load(this, resolve, reject)\n    } else {\n      if (callback) {\n        callback.call(this)\n      }\n    }\n  }\n\n  eachNode(callback: (node: Node) => void) {\n    const arr: Node[] = [this]\n    while (arr.length) {\n      const node = arr.shift()!\n      arr.unshift(...node.childNodes)\n      callback(node)\n    }\n  }\n\n  reInitChecked() {\n    if (this.store.checkStrictly) return\n    reInitChecked(this)\n  }\n}\n\nexport default Node\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}