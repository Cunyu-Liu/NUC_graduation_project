{"ast":null,"code":"import { watch, unref, nextTick } from 'vue';\nconst useDelayedRender = ({\n  indicator,\n  intermediateIndicator,\n  shouldSetIntermediate = () => true,\n  beforeShow,\n  afterShow,\n  afterHide,\n  beforeHide\n}) => {\n  watch(() => unref(indicator), val => {\n    if (val) {\n      beforeShow == null ? void 0 : beforeShow();\n      nextTick(() => {\n        if (!unref(indicator)) return;\n        if (shouldSetIntermediate(\"show\")) {\n          intermediateIndicator.value = true;\n        }\n      });\n    } else {\n      beforeHide == null ? void 0 : beforeHide();\n      nextTick(() => {\n        if (unref(indicator)) return;\n        if (shouldSetIntermediate(\"hide\")) {\n          intermediateIndicator.value = false;\n        }\n      });\n    }\n  });\n  watch(() => intermediateIndicator.value, val => {\n    if (val) {\n      afterShow == null ? void 0 : afterShow();\n    } else {\n      afterHide == null ? void 0 : afterHide();\n    }\n  });\n};\nexport { useDelayedRender };","map":{"version":3,"names":["useDelayedRender","indicator","intermediateIndicator","shouldSetIntermediate","beforeShow","afterShow","afterHide","beforeHide","watch","unref","val","nextTick","value"],"sources":["../../../../../packages/hooks/use-intermediate-render/index.ts"],"sourcesContent":["import { nextTick, unref, watch } from 'vue'\n\nimport type { Ref } from 'vue'\n\nexport type UseDelayedRenderProps = {\n  indicator: Ref<boolean>\n  intermediateIndicator: Ref<boolean>\n  shouldSetIntermediate?: (step: 'show' | 'hide') => boolean\n  beforeShow?: () => void\n  beforeHide?: () => void\n  afterShow?: () => void\n  afterHide?: () => void\n}\n\nexport const useDelayedRender = ({\n  indicator,\n  intermediateIndicator,\n  shouldSetIntermediate = () => true,\n  beforeShow,\n  afterShow,\n  afterHide,\n  beforeHide,\n}: UseDelayedRenderProps) => {\n  watch(\n    () => unref(indicator),\n    (val) => {\n      if (val) {\n        beforeShow?.()\n        nextTick(() => {\n          if (!unref(indicator)) return\n          if (shouldSetIntermediate('show')) {\n            intermediateIndicator.value = true\n          }\n        })\n      } else {\n        beforeHide?.()\n        nextTick(() => {\n          if (unref(indicator)) return\n\n          if (shouldSetIntermediate('hide')) {\n            intermediateIndicator.value = false\n          }\n        })\n      }\n    }\n  )\n\n  // because we don't always set the value ourselves, so that we\n  // simply watch the value's state, then invoke the corresponding hook.\n  watch(\n    () => intermediateIndicator.value,\n    (val) => {\n      if (val) {\n        afterShow?.()\n      } else {\n        afterHide?.()\n      }\n    }\n  )\n}\n"],"mappings":";AAcO,MAAMA,gBAAA,GAAmBA,CAAC;EAC/BC,SAAA;EACAC,qBAAA;EACAC,qBAAA,GAAwBA,CAAA,KAAM;EAC9BC,UAAA;EACAC,SAAA;EACAC,SAAA;EACAC;AACF,CAA6B;EAC3BC,KAAA,CACE,MAAMC,KAAA,CAAMR,SAAS,GACpBS,GAAQ;IACP,IAAIA,GAAK;MACPN,UAAA,oBAAAA,UAAA;MACAO,QAAA,CAAS,MAAM;QACT,KAACF,KAAA,CAAMR,SAAS,GAAG;QACnB,IAAAE,qBAAA,CAAsB,MAAM,CAAG;UACjCD,qBAAA,CAAsBU,KAAQ;QAAA;MAChC,CACD;IAAA,CACI;MACLL,UAAA,oBAAAA,UAAA;MACAI,QAAA,CAAS,MAAM;QACb,IAAIF,KAAA,CAAMR,SAAS,GAAG;QAElB,IAAAE,qBAAA,CAAsB,MAAM,CAAG;UACjCD,qBAAA,CAAsBU,KAAQ;QAAA;MAChC,CACD;IAAA;EACH,CACF,CACF;EAIAJ,KAAA,CACE,MAAMN,qBAAsB,CAAAU,KAAA,EAC3BF,GAAQ;IACP,IAAIA,GAAK;MACPL,SAAA,oBAAAA,SAAA;IAAA,CACK;MACLC,SAAA,oBAAAA,SAAA;IAAA;EACF,CACF,CACF;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}