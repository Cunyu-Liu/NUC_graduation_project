{"ast":null,"code":"import { defineComponent, shallowRef, ref, computed, watch, onMounted, watchEffect, openBlock, createElementBlock, normalizeClass, unref, normalizeStyle, createVNode, withCtx, createElementVNode, renderSlot, nextTick } from 'vue';\nimport { useWindowSize, useElementBounding, useEventListener } from '@vueuse/core';\nimport { ElTeleport } from '../../teleport/index.mjs';\nimport { affixProps, affixEmits } from './affix.mjs';\nimport _export_sfc from '../../../_virtual/plugin-vue_export-helper.mjs';\nimport { useNamespace } from '../../../hooks/use-namespace/index.mjs';\nimport { getScrollContainer } from '../../../utils/dom/scroll.mjs';\nimport { addUnit } from '../../../utils/dom/style.mjs';\nimport { CHANGE_EVENT } from '../../../constants/event.mjs';\nimport { throwError } from '../../../utils/error.mjs';\nconst COMPONENT_NAME = \"ElAffix\";\nconst _sfc_main = defineComponent({\n  ...{\n    name: COMPONENT_NAME\n  },\n  __name: \"affix\",\n  props: affixProps,\n  emits: affixEmits,\n  setup(__props, {\n    expose: __expose,\n    emit: __emit\n  }) {\n    const props = __props;\n    const emit = __emit;\n    const ns = useNamespace(\"affix\");\n    const target = shallowRef();\n    const root = shallowRef();\n    const scrollContainer = shallowRef();\n    const {\n      height: windowHeight\n    } = useWindowSize();\n    const {\n      height: rootHeight,\n      width: rootWidth,\n      top: rootTop,\n      bottom: rootBottom,\n      left: rootLeft,\n      update: updateRoot\n    } = useElementBounding(root, {\n      windowScroll: false\n    });\n    const targetRect = useElementBounding(target);\n    const fixed = ref(false);\n    const scrollTop = ref(0);\n    const transform = ref(0);\n    const teleportDisabled = computed(() => {\n      return !props.teleported || !fixed.value;\n    });\n    const rootStyle = computed(() => {\n      return {\n        height: fixed.value ? `${rootHeight.value}px` : \"\",\n        width: fixed.value ? `${rootWidth.value}px` : \"\"\n      };\n    });\n    const affixStyle = computed(() => {\n      if (!fixed.value) return {};\n      const offset = addUnit(props.offset);\n      return {\n        height: `${rootHeight.value}px`,\n        width: `${rootWidth.value}px`,\n        top: props.position === \"top\" ? offset : \"\",\n        bottom: props.position === \"bottom\" ? offset : \"\",\n        left: props.teleported ? `${rootLeft.value}px` : \"\",\n        transform: transform.value ? `translateY(${transform.value}px)` : \"\",\n        zIndex: props.zIndex\n      };\n    });\n    const update = () => {\n      if (!scrollContainer.value) return;\n      scrollTop.value = scrollContainer.value instanceof Window ? document.documentElement.scrollTop : scrollContainer.value.scrollTop || 0;\n      const {\n        position,\n        target: target2,\n        offset\n      } = props;\n      const rootHeightOffset = offset + rootHeight.value;\n      if (position === \"top\") {\n        if (target2) {\n          const difference = targetRect.bottom.value - rootHeightOffset;\n          fixed.value = offset > rootTop.value && targetRect.bottom.value > 0;\n          transform.value = difference < 0 ? difference : 0;\n        } else {\n          fixed.value = offset > rootTop.value;\n        }\n      } else if (target2) {\n        const difference = windowHeight.value - targetRect.top.value - rootHeightOffset;\n        fixed.value = windowHeight.value - offset < rootBottom.value && windowHeight.value > targetRect.top.value;\n        transform.value = difference < 0 ? -difference : 0;\n      } else {\n        fixed.value = windowHeight.value - offset < rootBottom.value;\n      }\n    };\n    const updateRootRect = async () => {\n      if (!fixed.value) {\n        updateRoot();\n        return;\n      }\n      fixed.value = false;\n      await nextTick();\n      updateRoot();\n      fixed.value = true;\n    };\n    const handleScroll = async () => {\n      updateRoot();\n      await nextTick();\n      emit(\"scroll\", {\n        scrollTop: scrollTop.value,\n        fixed: fixed.value\n      });\n    };\n    watch(fixed, val => emit(CHANGE_EVENT, val));\n    onMounted(() => {\n      var _a;\n      if (props.target) {\n        target.value = (_a = document.querySelector(props.target)) != null ? _a : void 0;\n        if (!target.value) throwError(COMPONENT_NAME, `Target does not exist: ${props.target}`);\n      } else {\n        target.value = document.documentElement;\n      }\n      scrollContainer.value = getScrollContainer(root.value, true);\n      updateRoot();\n    });\n    useEventListener(scrollContainer, \"scroll\", handleScroll);\n    watchEffect(update);\n    __expose({\n      update,\n      updateRoot: updateRootRect\n    });\n    return (_ctx, _cache) => {\n      return openBlock(), createElementBlock(\"div\", {\n        ref_key: \"root\",\n        ref: root,\n        class: normalizeClass(unref(ns).b()),\n        style: normalizeStyle(rootStyle.value)\n      }, [createVNode(unref(ElTeleport), {\n        disabled: teleportDisabled.value,\n        to: _ctx.appendTo\n      }, {\n        default: withCtx(() => [createElementVNode(\"div\", {\n          class: normalizeClass({\n            [unref(ns).m(\"fixed\")]: fixed.value\n          }),\n          style: normalizeStyle(affixStyle.value)\n        }, [renderSlot(_ctx.$slots, \"default\")], 6)]),\n        _: 3\n      }, 8, [\"disabled\", \"to\"])], 6);\n    };\n  }\n});\nvar Affix = /* @__PURE__ */_export_sfc(_sfc_main, [[\"__file\", \"/home/runner/work/element-plus/element-plus/packages/components/affix/src/affix.vue\"]]);\nexport { Affix as default };","map":{"version":3,"names":["COMPONENT_NAME","props","__props","emit","__emit","ns","useNamespace","target","shallowRef","root","scrollContainer","height","windowHeight","useWindowSize","rootHeight","width","rootWidth","top","rootTop","bottom","rootBottom","left","rootLeft","update","updateRoot","useElementBounding","windowScroll","targetRect","fixed","ref","scrollTop","transform","teleportDisabled","computed","teleported","value","rootStyle","affixStyle","offset","addUnit","position","zIndex","Window","document","documentElement","target2","rootHeightOffset","difference","updateRootRect","nextTick","handleScroll","watch","val","CHANGE_EVENT","onMounted","_a","querySelector","throwError","getScrollContainer","useEventListener","watchEffect","__expose","openBlock","createElementBlock","ref_key","class","normalizeClass","unref","b","style","normalizeStyle","createVNode","ElTeleport","disabled","to","_ctx","appendTo","default","withCtx","createElementVNode","m","renderSlot","$slots"],"sources":["../../../../../../packages/components/affix/src/affix.vue"],"sourcesContent":["<template>\n  <div ref=\"root\" :class=\"ns.b()\" :style=\"rootStyle\">\n    <el-teleport :disabled=\"teleportDisabled\" :to=\"appendTo\">\n      <div :class=\"{ [ns.m('fixed')]: fixed }\" :style=\"affixStyle\">\n        <slot />\n      </div>\n    </el-teleport>\n  </div>\n</template>\n\n<script lang=\"ts\" setup>\nimport {\n  computed,\n  nextTick,\n  onMounted,\n  ref,\n  shallowRef,\n  watch,\n  watchEffect,\n} from 'vue'\nimport {\n  useElementBounding,\n  useEventListener,\n  useWindowSize,\n} from '@vueuse/core'\nimport ElTeleport from '@element-plus/components/teleport'\nimport { addUnit, getScrollContainer, throwError } from '@element-plus/utils'\nimport { useNamespace } from '@element-plus/hooks'\nimport { CHANGE_EVENT } from '@element-plus/constants'\nimport { affixEmits, affixProps } from './affix'\n\nimport type { CSSProperties } from 'vue'\n\nconst COMPONENT_NAME = 'ElAffix'\ndefineOptions({\n  name: COMPONENT_NAME,\n})\nconst props = defineProps(affixProps)\nconst emit = defineEmits(affixEmits)\n\nconst ns = useNamespace('affix')\n\nconst target = shallowRef<HTMLElement>()\nconst root = shallowRef<HTMLDivElement>()\nconst scrollContainer = shallowRef<HTMLElement | Window>()\nconst { height: windowHeight } = useWindowSize()\nconst {\n  height: rootHeight,\n  width: rootWidth,\n  top: rootTop,\n  bottom: rootBottom,\n  left: rootLeft,\n  update: updateRoot,\n} = useElementBounding(root, { windowScroll: false })\nconst targetRect = useElementBounding(target)\n\nconst fixed = ref(false)\nconst scrollTop = ref(0)\nconst transform = ref(0)\n\nconst teleportDisabled = computed(() => {\n  return !props.teleported || !fixed.value\n})\n\nconst rootStyle = computed<CSSProperties>(() => {\n  return {\n    height: fixed.value ? `${rootHeight.value}px` : '',\n    width: fixed.value ? `${rootWidth.value}px` : '',\n  }\n})\n\nconst affixStyle = computed<CSSProperties>(() => {\n  if (!fixed.value) return {}\n\n  const offset = addUnit(props.offset)\n  return {\n    height: `${rootHeight.value}px`,\n    width: `${rootWidth.value}px`,\n    top: props.position === 'top' ? offset : '',\n    bottom: props.position === 'bottom' ? offset : '',\n    left: props.teleported ? `${rootLeft.value}px` : '',\n    transform: transform.value ? `translateY(${transform.value}px)` : '',\n    zIndex: props.zIndex,\n  }\n})\n\nconst update = () => {\n  if (!scrollContainer.value) return\n\n  scrollTop.value =\n    scrollContainer.value instanceof Window\n      ? document.documentElement.scrollTop\n      : scrollContainer.value.scrollTop || 0\n\n  const { position, target, offset } = props\n  const rootHeightOffset = offset + rootHeight.value\n\n  if (position === 'top') {\n    if (target) {\n      const difference = targetRect.bottom.value - rootHeightOffset\n      fixed.value = offset > rootTop.value && targetRect.bottom.value > 0\n      transform.value = difference < 0 ? difference : 0\n    } else {\n      fixed.value = offset > rootTop.value\n    }\n  } else if (target) {\n    const difference =\n      windowHeight.value - targetRect.top.value - rootHeightOffset\n    fixed.value =\n      windowHeight.value - offset < rootBottom.value &&\n      windowHeight.value > targetRect.top.value\n    transform.value = difference < 0 ? -difference : 0\n  } else {\n    fixed.value = windowHeight.value - offset < rootBottom.value\n  }\n}\n\nconst updateRootRect = async () => {\n  if (!fixed.value) {\n    updateRoot()\n    return\n  }\n\n  fixed.value = false\n  await nextTick()\n  updateRoot()\n  fixed.value = true\n}\n\nconst handleScroll = async () => {\n  updateRoot()\n  await nextTick()\n  emit('scroll', {\n    scrollTop: scrollTop.value,\n    fixed: fixed.value,\n  })\n}\n\nwatch(fixed, (val) => emit(CHANGE_EVENT, val))\n\nonMounted(() => {\n  if (props.target) {\n    target.value =\n      document.querySelector<HTMLElement>(props.target) ?? undefined\n    if (!target.value)\n      throwError(COMPONENT_NAME, `Target does not exist: ${props.target}`)\n  } else {\n    target.value = document.documentElement\n  }\n  scrollContainer.value = getScrollContainer(root.value!, true)\n  updateRoot()\n})\n\nuseEventListener(scrollContainer, 'scroll', handleScroll)\nwatchEffect(update)\n\ndefineExpose({\n  /** @description update affix status */\n  update,\n  /** @description update rootRect info */\n  updateRoot: updateRootRect,\n})\n</script>\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}