{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\nimport { ref, shallowRef, computed, watch } from 'vue';\nimport { TreeOptionsEnum, NODE_CLICK, NODE_DROP, CURRENT_CHANGE, NODE_EXPAND, NODE_COLLAPSE } from '../virtual-tree.mjs';\nimport { useCheck } from './useCheck.mjs';\nimport { useFilter } from './useFilter.mjs';\nimport { isObject } from '@vue/shared';\nfunction useTree(props, emit) {\n  const expandedKeySet = ref(/* @__PURE__ */new Set());\n  const currentKey = ref();\n  const tree = shallowRef();\n  const listRef = ref();\n  const {\n    isIndeterminate,\n    isChecked,\n    toggleCheckbox,\n    getCheckedKeys,\n    getCheckedNodes,\n    getHalfCheckedKeys,\n    getHalfCheckedNodes,\n    setChecked,\n    setCheckedKeys\n  } = useCheck(props, tree);\n  const {\n    doFilter,\n    hiddenNodeKeySet,\n    isForceHiddenExpandIcon\n  } = useFilter(props, tree);\n  const valueKey = computed(() => {\n    var _a;\n    return ((_a = props.props) == null ? void 0 : _a.value) || TreeOptionsEnum.KEY;\n  });\n  const childrenKey = computed(() => {\n    var _a;\n    return ((_a = props.props) == null ? void 0 : _a.children) || TreeOptionsEnum.CHILDREN;\n  });\n  const disabledKey = computed(() => {\n    var _a;\n    return ((_a = props.props) == null ? void 0 : _a.disabled) || TreeOptionsEnum.DISABLED;\n  });\n  const labelKey = computed(() => {\n    var _a;\n    return ((_a = props.props) == null ? void 0 : _a.label) || TreeOptionsEnum.LABEL;\n  });\n  const flattenTree = computed(() => {\n    var _a;\n    const expandedKeys = expandedKeySet.value;\n    const hiddenKeys = hiddenNodeKeySet.value;\n    const flattenNodes = [];\n    const nodes = ((_a = tree.value) == null ? void 0 : _a.treeNodes) || [];\n    const stack = [];\n    for (let i = nodes.length - 1; i >= 0; --i) {\n      stack.push(nodes[i]);\n    }\n    while (stack.length) {\n      const node = stack.pop();\n      if (hiddenKeys.has(node.key)) continue;\n      flattenNodes.push(node);\n      if (node.children && expandedKeys.has(node.key)) {\n        for (let i = node.children.length - 1; i >= 0; --i) {\n          stack.push(node.children[i]);\n        }\n      }\n    }\n    return flattenNodes;\n  });\n  const isNotEmpty = computed(() => {\n    return flattenTree.value.length > 0;\n  });\n  function createTree(data) {\n    const treeNodeMap = /* @__PURE__ */new Map();\n    const levelTreeNodeMap = /* @__PURE__ */new Map();\n    let maxLevel = 1;\n    function traverse(nodes, level = 1, parent = void 0) {\n      var _a;\n      const siblings = [];\n      for (const rawNode of nodes) {\n        const value = getKey(rawNode);\n        const node = {\n          level,\n          key: value,\n          data: rawNode\n        };\n        node.label = getLabel(rawNode);\n        node.parent = parent;\n        const children = getChildren(rawNode);\n        node.disabled = getDisabled(rawNode);\n        node.isLeaf = !children || children.length === 0;\n        node.expanded = expandedKeySet.value.has(value);\n        if (children && children.length) {\n          node.children = traverse(children, level + 1, node);\n        }\n        siblings.push(node);\n        treeNodeMap.set(value, node);\n        if (!levelTreeNodeMap.has(level)) {\n          levelTreeNodeMap.set(level, []);\n        }\n        (_a = levelTreeNodeMap.get(level)) == null ? void 0 : _a.push(node);\n      }\n      if (level > maxLevel) {\n        maxLevel = level;\n      }\n      return siblings;\n    }\n    const treeNodes = traverse(data);\n    return {\n      treeNodeMap,\n      levelTreeNodeMap,\n      maxLevel,\n      treeNodes\n    };\n  }\n  function filter(query) {\n    const keys = doFilter(query);\n    if (keys) {\n      expandedKeySet.value = keys;\n    }\n  }\n  function getChildren(node) {\n    return node[childrenKey.value];\n  }\n  function getKey(node) {\n    if (!node) {\n      return \"\";\n    }\n    return node[valueKey.value];\n  }\n  function getDisabled(node) {\n    return node[disabledKey.value];\n  }\n  function getLabel(node) {\n    return node[labelKey.value];\n  }\n  function toggleExpand(node) {\n    const expandedKeys = expandedKeySet.value;\n    if (expandedKeys.has(node.key)) {\n      collapseNode(node);\n    } else {\n      expandNode(node);\n    }\n  }\n  function setExpandedKeys(keys) {\n    const expandedKeys = /* @__PURE__ */new Set();\n    const nodeMap = tree.value.treeNodeMap;\n    expandedKeySet.value.forEach(key => {\n      const node = nodeMap.get(key);\n      expandedKeySet.value.delete(node.key);\n      node.expanded = false;\n    });\n    keys.forEach(k => {\n      let node = nodeMap.get(k);\n      while (node && !expandedKeys.has(node.key)) {\n        expandedKeys.add(node.key);\n        node.expanded = true;\n        node = node.parent;\n      }\n    });\n    expandedKeySet.value = expandedKeys;\n  }\n  function handleNodeClick(node, e) {\n    emit(NODE_CLICK, node.data, node, e);\n    handleCurrentChange(node);\n    if (props.expandOnClickNode) {\n      toggleExpand(node);\n    }\n    if (props.showCheckbox && (props.checkOnClickNode || node.isLeaf && props.checkOnClickLeaf) && !node.disabled) {\n      toggleCheckbox(node, !isChecked(node), true);\n    }\n  }\n  function handleNodeDrop(node, e) {\n    emit(NODE_DROP, node.data, node, e);\n  }\n  function handleCurrentChange(node) {\n    if (!isCurrent(node)) {\n      currentKey.value = node.key;\n      emit(CURRENT_CHANGE, node.data, node);\n    }\n  }\n  function handleNodeCheck(node, checked) {\n    toggleCheckbox(node, checked);\n  }\n  function expandNode(node) {\n    const keySet = expandedKeySet.value;\n    if (tree.value && props.accordion) {\n      const {\n        treeNodeMap\n      } = tree.value;\n      keySet.forEach(key => {\n        const treeNode = treeNodeMap.get(key);\n        if (node && node.level === (treeNode == null ? void 0 : treeNode.level)) {\n          keySet.delete(key);\n          treeNode.expanded = false;\n        }\n      });\n    }\n    keySet.add(node.key);\n    const _node = getNode(node.key);\n    if (_node) {\n      _node.expanded = true;\n      emit(NODE_EXPAND, _node.data, _node);\n    }\n  }\n  function collapseNode(node) {\n    expandedKeySet.value.delete(node.key);\n    const _node = getNode(node.key);\n    if (_node) {\n      _node.expanded = false;\n      emit(NODE_COLLAPSE, _node.data, _node);\n    }\n  }\n  function isDisabled(node) {\n    return !!node.disabled;\n  }\n  function isCurrent(node) {\n    const current = currentKey.value;\n    return current !== void 0 && current === node.key;\n  }\n  function getCurrentNode() {\n    var _a, _b;\n    if (!currentKey.value) return void 0;\n    return (_b = (_a = tree.value) == null ? void 0 : _a.treeNodeMap.get(currentKey.value)) == null ? void 0 : _b.data;\n  }\n  function getCurrentKey() {\n    return currentKey.value;\n  }\n  function setCurrentKey(key) {\n    currentKey.value = key;\n  }\n  function setData(data) {\n    tree.value = createTree(data);\n  }\n  function getNode(data) {\n    var _a;\n    const key = isObject(data) ? getKey(data) : data;\n    return (_a = tree.value) == null ? void 0 : _a.treeNodeMap.get(key);\n  }\n  function scrollToNode(key, strategy = \"auto\") {\n    const node = getNode(key);\n    if (node && listRef.value) {\n      listRef.value.scrollToItem(flattenTree.value.indexOf(node), strategy);\n    }\n  }\n  function scrollTo(offset) {\n    var _a;\n    (_a = listRef.value) == null ? void 0 : _a.scrollTo(offset);\n  }\n  watch(() => props.currentNodeKey, key => {\n    currentKey.value = key;\n  }, {\n    immediate: true\n  });\n  watch(() => props.defaultExpandedKeys, key => {\n    expandedKeySet.value = new Set(key);\n  }, {\n    immediate: true\n  });\n  watch(() => props.data, data => {\n    setData(data);\n  }, {\n    immediate: true\n  });\n  return {\n    tree,\n    flattenTree,\n    isNotEmpty,\n    listRef,\n    getKey,\n    getChildren,\n    toggleExpand,\n    toggleCheckbox,\n    isChecked,\n    isIndeterminate,\n    isDisabled,\n    isCurrent,\n    isForceHiddenExpandIcon,\n    handleNodeClick,\n    handleNodeDrop,\n    handleNodeCheck,\n    getCurrentNode,\n    getCurrentKey,\n    setCurrentKey,\n    getCheckedKeys,\n    getCheckedNodes,\n    getHalfCheckedKeys,\n    getHalfCheckedNodes,\n    setChecked,\n    setCheckedKeys,\n    filter,\n    setData,\n    getNode,\n    expandNode,\n    collapseNode,\n    setExpandedKeys,\n    scrollToNode,\n    scrollTo\n  };\n}\nexport { useTree };","map":{"version":3,"names":["useTree","props","emit","expandedKeySet","ref","Set","currentKey","tree","shallowRef","listRef","isIndeterminate","isChecked","toggleCheckbox","getCheckedKeys","getCheckedNodes","getHalfCheckedKeys","getHalfCheckedNodes","setChecked","setCheckedKeys","useCheck","doFilter","hiddenNodeKeySet","isForceHiddenExpandIcon","useFilter","valueKey","computed","_a","value","TreeOptionsEnum","KEY","childrenKey","children","CHILDREN","disabledKey","disabled","DISABLED","labelKey","label","LABEL","flattenTree","expandedKeys","hiddenKeys","flattenNodes","nodes","treeNodes","stack","i","length","push","node","pop","has","key","isNotEmpty","createTree","data","treeNodeMap","Map","levelTreeNodeMap","maxLevel","traverse","level","parent","siblings","rawNode","getKey","getLabel","getChildren","getDisabled","isLeaf","expanded","set","get","filter","query","keys","toggleExpand","collapseNode","expandNode","setExpandedKeys","nodeMap","forEach","delete","k","add","handleNodeClick","e","NODE_CLICK","handleCurrentChange","expandOnClickNode","showCheckbox","checkOnClickNode","checkOnClickLeaf","handleNodeDrop","NODE_DROP","isCurrent","CURRENT_CHANGE","handleNodeCheck","checked","keySet","accordion","treeNode","_node","getNode","NODE_EXPAND","NODE_COLLAPSE","isDisabled","current","getCurrentNode","_b","getCurrentKey","setCurrentKey","setData","isObject","scrollToNode","strategy","scrollToItem","indexOf","scrollTo","offset","watch","currentNodeKey","immediate","defaultExpandedKeys"],"sources":["../../../../../../../packages/components/tree-v2/src/composables/useTree.ts"],"sourcesContent":["import { computed, ref, shallowRef, watch } from 'vue'\nimport { isObject } from '@element-plus/utils'\nimport {\n  CURRENT_CHANGE,\n  NODE_CLICK,\n  NODE_COLLAPSE,\n  NODE_DROP,\n  NODE_EXPAND,\n  TreeOptionsEnum,\n} from '../virtual-tree'\nimport { useCheck } from './useCheck'\nimport { useFilter } from './useFilter'\n\nimport type {\n  FixedSizeList,\n  Alignment as ScrollStrategy,\n} from '@element-plus/components/virtual-list'\nimport type { SetupContext } from 'vue'\nimport type { treeEmits } from '../virtual-tree'\nimport type { CheckboxValueType } from '@element-plus/components/checkbox'\nimport type {\n  Tree,\n  TreeData,\n  TreeKey,\n  TreeNode,\n  TreeNodeData,\n  TreeProps,\n} from '../types'\n\nexport function useTree(\n  props: TreeProps,\n  emit: SetupContext<typeof treeEmits>['emit']\n) {\n  const expandedKeySet = ref<Set<TreeKey>>(new Set())\n  const currentKey = ref<TreeKey | undefined>()\n  const tree = shallowRef<Tree | undefined>()\n  const listRef = ref<typeof FixedSizeList | undefined>()\n\n  const {\n    isIndeterminate,\n    isChecked,\n    toggleCheckbox,\n    getCheckedKeys,\n    getCheckedNodes,\n    getHalfCheckedKeys,\n    getHalfCheckedNodes,\n    setChecked,\n    setCheckedKeys,\n  } = useCheck(props, tree)\n\n  const { doFilter, hiddenNodeKeySet, isForceHiddenExpandIcon } = useFilter(\n    props,\n    tree\n  )\n\n  const valueKey = computed(() => {\n    return props.props?.value || TreeOptionsEnum.KEY\n  })\n  const childrenKey = computed(() => {\n    return props.props?.children || TreeOptionsEnum.CHILDREN\n  })\n  const disabledKey = computed(() => {\n    return props.props?.disabled || TreeOptionsEnum.DISABLED\n  })\n  const labelKey = computed(() => {\n    return props.props?.label || TreeOptionsEnum.LABEL\n  })\n\n  const flattenTree = computed(() => {\n    const expandedKeys = expandedKeySet.value\n    const hiddenKeys = hiddenNodeKeySet.value\n    const flattenNodes: TreeNode[] = []\n    const nodes = tree.value?.treeNodes || []\n\n    const stack: TreeNode[] = []\n    for (let i = nodes.length - 1; i >= 0; --i) {\n      stack.push(nodes[i])\n    }\n    while (stack.length) {\n      const node = stack.pop()!\n      if (hiddenKeys.has(node.key)) continue\n\n      flattenNodes.push(node)\n      if (node.children && expandedKeys.has(node.key)) {\n        for (let i = node.children.length - 1; i >= 0; --i) {\n          stack.push(node.children[i])\n        }\n      }\n    }\n\n    return flattenNodes\n  })\n\n  const isNotEmpty = computed(() => {\n    return flattenTree.value.length > 0\n  })\n\n  function createTree(data: TreeData): Tree {\n    const treeNodeMap: Map<TreeKey, TreeNode> = new Map()\n    const levelTreeNodeMap: Map<number, TreeNode[]> = new Map()\n    let maxLevel = 1\n    function traverse(\n      nodes: TreeData,\n      level = 1,\n      parent: TreeNode | undefined = undefined\n    ) {\n      const siblings: TreeNode[] = []\n      for (const rawNode of nodes) {\n        const value = getKey(rawNode)\n        const node: TreeNode = {\n          level,\n          key: value,\n          data: rawNode,\n        }\n        node.label = getLabel(rawNode)\n        node.parent = parent\n        const children = getChildren(rawNode)\n        node.disabled = getDisabled(rawNode)\n        node.isLeaf = !children || children.length === 0\n        node.expanded = expandedKeySet.value.has(value)\n        if (children && children.length) {\n          node.children = traverse(children, level + 1, node)\n        }\n        siblings.push(node)\n        treeNodeMap.set(value, node)\n        if (!levelTreeNodeMap.has(level)) {\n          levelTreeNodeMap.set(level, [])\n        }\n        levelTreeNodeMap.get(level)?.push(node)\n      }\n      if (level > maxLevel) {\n        maxLevel = level\n      }\n      return siblings\n    }\n    const treeNodes: TreeNode[] = traverse(data)\n    return {\n      treeNodeMap,\n      levelTreeNodeMap,\n      maxLevel,\n      treeNodes,\n    }\n  }\n\n  function filter(query: string) {\n    const keys = doFilter(query)\n    if (keys) {\n      expandedKeySet.value = keys\n    }\n  }\n\n  function getChildren(node: TreeNodeData): TreeNodeData[] {\n    return node[childrenKey.value]\n  }\n\n  function getKey(node: TreeNodeData): TreeKey {\n    if (!node) {\n      return ''\n    }\n    return node[valueKey.value]\n  }\n\n  function getDisabled(node: TreeNodeData): boolean {\n    return node[disabledKey.value]\n  }\n\n  function getLabel(node: TreeNodeData): string {\n    return node[labelKey.value]\n  }\n\n  function toggleExpand(node: TreeNode) {\n    const expandedKeys = expandedKeySet.value\n    if (expandedKeys.has(node.key)) {\n      collapseNode(node)\n    } else {\n      expandNode(node)\n    }\n  }\n\n  function setExpandedKeys(keys: TreeKey[]) {\n    const expandedKeys = new Set<TreeKey>()\n    const nodeMap = tree.value!.treeNodeMap\n\n    expandedKeySet.value.forEach((key) => {\n      const node = nodeMap.get(key)!\n      expandedKeySet.value.delete(node.key)\n      node.expanded = false\n    })\n\n    keys.forEach((k) => {\n      let node = nodeMap.get(k)\n      while (node && !expandedKeys.has(node.key)) {\n        expandedKeys.add(node.key)\n        node.expanded = true\n        node = node.parent\n      }\n    })\n\n    expandedKeySet.value = expandedKeys\n  }\n\n  function handleNodeClick(node: TreeNode, e: MouseEvent) {\n    emit(NODE_CLICK, node.data, node, e)\n    handleCurrentChange(node)\n    if (props.expandOnClickNode) {\n      toggleExpand(node)\n    }\n    if (\n      props.showCheckbox &&\n      (props.checkOnClickNode || (node.isLeaf && props.checkOnClickLeaf)) &&\n      !node.disabled\n    ) {\n      toggleCheckbox(node, !isChecked(node), true)\n    }\n  }\n\n  function handleNodeDrop(node: TreeNode, e: DragEvent) {\n    emit(NODE_DROP, node.data, node, e)\n  }\n\n  function handleCurrentChange(node: TreeNode) {\n    if (!isCurrent(node)) {\n      currentKey.value = node.key\n      emit(CURRENT_CHANGE, node.data, node)\n    }\n  }\n\n  function handleNodeCheck(node: TreeNode, checked: CheckboxValueType) {\n    toggleCheckbox(node, checked)\n  }\n\n  function expandNode(node: TreeNode) {\n    const keySet = expandedKeySet.value\n    if (tree.value && props.accordion) {\n      // whether only one node among the same level can be expanded at one time\n      const { treeNodeMap } = tree.value\n      keySet.forEach((key) => {\n        const treeNode = treeNodeMap.get(key)\n        if (node && node.level === treeNode?.level) {\n          keySet.delete(key)\n          treeNode.expanded = false\n        }\n      })\n    }\n    keySet.add(node.key)\n    const _node = getNode(node.key)\n    if (_node) {\n      _node.expanded = true\n      emit(NODE_EXPAND, _node.data, _node)\n    }\n  }\n\n  function collapseNode(node: TreeNode) {\n    expandedKeySet.value.delete(node.key)\n    const _node = getNode(node.key)\n    if (_node) {\n      _node.expanded = false\n      emit(NODE_COLLAPSE, _node.data, _node)\n    }\n  }\n\n  function isDisabled(node: TreeNode): boolean {\n    return !!node.disabled\n  }\n\n  function isCurrent(node: TreeNode): boolean {\n    const current = currentKey.value\n    return current !== undefined && current === node.key\n  }\n\n  function getCurrentNode(): TreeNodeData | undefined {\n    if (!currentKey.value) return undefined\n    return tree.value?.treeNodeMap.get(currentKey.value)?.data\n  }\n\n  function getCurrentKey(): TreeKey | undefined {\n    return currentKey.value\n  }\n\n  function setCurrentKey(key: TreeKey): void {\n    currentKey.value = key\n  }\n\n  function setData(data: TreeData) {\n    tree.value = createTree(data)\n  }\n\n  function getNode(data: TreeKey | TreeNodeData) {\n    const key = isObject(data) ? getKey(data) : data\n    return tree.value?.treeNodeMap.get(key)\n  }\n\n  function scrollToNode(key: TreeKey, strategy: ScrollStrategy = 'auto') {\n    const node = getNode(key)\n    if (node && listRef.value) {\n      listRef.value.scrollToItem(flattenTree.value.indexOf(node), strategy)\n    }\n  }\n\n  function scrollTo(offset: number) {\n    listRef.value?.scrollTo(offset)\n  }\n\n  watch(\n    () => props.currentNodeKey,\n    (key) => {\n      currentKey.value = key\n    },\n    {\n      immediate: true,\n    }\n  )\n\n  watch(\n    () => props.defaultExpandedKeys,\n    (key) => {\n      expandedKeySet.value = new Set<TreeKey>(key)\n    },\n    {\n      immediate: true,\n    }\n  )\n\n  watch(\n    () => props.data,\n    (data: TreeData) => {\n      setData(data)\n    },\n    {\n      immediate: true,\n    }\n  )\n\n  return {\n    tree,\n    flattenTree,\n    isNotEmpty,\n    listRef,\n    getKey,\n    getChildren,\n    toggleExpand,\n    toggleCheckbox,\n    isChecked,\n    isIndeterminate,\n    isDisabled,\n    isCurrent,\n    isForceHiddenExpandIcon,\n    handleNodeClick,\n    handleNodeDrop,\n    handleNodeCheck,\n    // expose\n    getCurrentNode,\n    getCurrentKey,\n    setCurrentKey,\n    getCheckedKeys,\n    getCheckedNodes,\n    getHalfCheckedKeys,\n    getHalfCheckedNodes,\n    setChecked,\n    setCheckedKeys,\n    filter,\n    setData,\n    getNode,\n    expandNode,\n    collapseNode,\n    setExpandedKeys,\n    scrollToNode,\n    scrollTo,\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}