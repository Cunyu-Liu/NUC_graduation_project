{"ast":null,"code":"import { inject, ref, computed, watch, nextTick } from 'vue';\nimport { debounce, clamp } from 'lodash-unified';\nimport { useEventListener } from '@vueuse/core';\nimport { sliderContextKey } from '../constants.mjs';\nimport { getEventCode } from '../../../../utils/dom/event.mjs';\nimport { EVENT_CODE } from '../../../../constants/aria.mjs';\nimport { UPDATE_MODEL_EVENT } from '../../../../constants/event.mjs';\nconst useTooltip = (props, formatTooltip, showTooltip) => {\n  const tooltip = ref();\n  const tooltipVisible = ref(false);\n  const enableFormat = computed(() => {\n    return formatTooltip.value instanceof Function;\n  });\n  const formatValue = computed(() => {\n    return enableFormat.value && formatTooltip.value(props.modelValue) || props.modelValue;\n  });\n  const displayTooltip = debounce(() => {\n    showTooltip.value && (tooltipVisible.value = true);\n  }, 50);\n  const hideTooltip = debounce(() => {\n    showTooltip.value && (tooltipVisible.value = false);\n  }, 50);\n  return {\n    tooltip,\n    tooltipVisible,\n    formatValue,\n    displayTooltip,\n    hideTooltip\n  };\n};\nconst useSliderButton = (props, initData, emit) => {\n  const {\n    disabled,\n    min,\n    max,\n    step,\n    showTooltip,\n    persistent,\n    precision,\n    sliderSize,\n    formatTooltip,\n    emitChange,\n    resetSize,\n    updateDragging\n  } = inject(sliderContextKey);\n  const {\n    tooltip,\n    tooltipVisible,\n    formatValue,\n    displayTooltip,\n    hideTooltip\n  } = useTooltip(props, formatTooltip, showTooltip);\n  const button = ref();\n  const currentPosition = computed(() => {\n    return `${(props.modelValue - min.value) / (max.value - min.value) * 100}%`;\n  });\n  const wrapperStyle = computed(() => {\n    return props.vertical ? {\n      bottom: currentPosition.value\n    } : {\n      left: currentPosition.value\n    };\n  });\n  const handleMouseEnter = () => {\n    initData.hovering = true;\n    displayTooltip();\n  };\n  const handleMouseLeave = () => {\n    initData.hovering = false;\n    if (!initData.dragging) {\n      hideTooltip();\n    }\n  };\n  const onButtonDown = event => {\n    if (disabled.value) return;\n    event.preventDefault();\n    onDragStart(event);\n    window.addEventListener(\"mousemove\", onDragging);\n    window.addEventListener(\"touchmove\", onDragging);\n    window.addEventListener(\"mouseup\", onDragEnd);\n    window.addEventListener(\"touchend\", onDragEnd);\n    window.addEventListener(\"contextmenu\", onDragEnd);\n    button.value.focus();\n  };\n  const incrementPosition = amount => {\n    if (disabled.value) return;\n    initData.newPosition = Number.parseFloat(currentPosition.value) + amount / (max.value - min.value) * 100;\n    setPosition(initData.newPosition);\n    emitChange();\n  };\n  const onLeftKeyDown = () => {\n    incrementPosition(-step.value);\n  };\n  const onRightKeyDown = () => {\n    incrementPosition(step.value);\n  };\n  const onPageDownKeyDown = () => {\n    incrementPosition(-step.value * 4);\n  };\n  const onPageUpKeyDown = () => {\n    incrementPosition(step.value * 4);\n  };\n  const onHomeKeyDown = () => {\n    if (disabled.value) return;\n    setPosition(0);\n    emitChange();\n  };\n  const onEndKeyDown = () => {\n    if (disabled.value) return;\n    setPosition(100);\n    emitChange();\n  };\n  const onKeyDown = event => {\n    const code = getEventCode(event);\n    let isPreventDefault = true;\n    switch (code) {\n      case EVENT_CODE.left:\n      case EVENT_CODE.down:\n        onLeftKeyDown();\n        break;\n      case EVENT_CODE.right:\n      case EVENT_CODE.up:\n        onRightKeyDown();\n        break;\n      case EVENT_CODE.home:\n        onHomeKeyDown();\n        break;\n      case EVENT_CODE.end:\n        onEndKeyDown();\n        break;\n      case EVENT_CODE.pageDown:\n        onPageDownKeyDown();\n        break;\n      case EVENT_CODE.pageUp:\n        onPageUpKeyDown();\n        break;\n      default:\n        isPreventDefault = false;\n        break;\n    }\n    isPreventDefault && event.preventDefault();\n  };\n  const getClientXY = event => {\n    let clientX;\n    let clientY;\n    if (event.type.startsWith(\"touch\")) {\n      clientY = event.touches[0].clientY;\n      clientX = event.touches[0].clientX;\n    } else {\n      clientY = event.clientY;\n      clientX = event.clientX;\n    }\n    return {\n      clientX,\n      clientY\n    };\n  };\n  const onDragStart = event => {\n    initData.dragging = true;\n    initData.isClick = true;\n    const {\n      clientX,\n      clientY\n    } = getClientXY(event);\n    if (props.vertical) {\n      initData.startY = clientY;\n    } else {\n      initData.startX = clientX;\n    }\n    initData.startPosition = Number.parseFloat(currentPosition.value);\n    initData.newPosition = initData.startPosition;\n  };\n  const onDragging = event => {\n    if (initData.dragging) {\n      initData.isClick = false;\n      displayTooltip();\n      resetSize();\n      let diff;\n      const {\n        clientX,\n        clientY\n      } = getClientXY(event);\n      if (props.vertical) {\n        initData.currentY = clientY;\n        diff = (initData.startY - initData.currentY) / sliderSize.value * 100;\n      } else {\n        initData.currentX = clientX;\n        diff = (initData.currentX - initData.startX) / sliderSize.value * 100;\n      }\n      initData.newPosition = initData.startPosition + diff;\n      setPosition(initData.newPosition);\n    }\n  };\n  const onDragEnd = () => {\n    if (initData.dragging) {\n      setTimeout(() => {\n        initData.dragging = false;\n        if (!initData.hovering) {\n          hideTooltip();\n        }\n        if (!initData.isClick) {\n          setPosition(initData.newPosition);\n        }\n        emitChange();\n      }, 0);\n      window.removeEventListener(\"mousemove\", onDragging);\n      window.removeEventListener(\"touchmove\", onDragging);\n      window.removeEventListener(\"mouseup\", onDragEnd);\n      window.removeEventListener(\"touchend\", onDragEnd);\n      window.removeEventListener(\"contextmenu\", onDragEnd);\n    }\n  };\n  const setPosition = async newPosition => {\n    if (newPosition === null || Number.isNaN(+newPosition)) return;\n    newPosition = clamp(newPosition, 0, 100);\n    const fullSteps = Math.floor((max.value - min.value) / step.value);\n    const fullRangePercentage = fullSteps * step.value / (max.value - min.value) * 100;\n    const threshold = fullRangePercentage + (100 - fullRangePercentage) / 2;\n    let value;\n    if (newPosition < fullRangePercentage) {\n      const valueBetween = fullRangePercentage / fullSteps;\n      const steps = Math.round(newPosition / valueBetween);\n      value = min.value + steps * step.value;\n    } else if (newPosition < threshold) {\n      value = min.value + fullSteps * step.value;\n    } else {\n      value = max.value;\n    }\n    value = Number.parseFloat(value.toFixed(precision.value));\n    if (value !== props.modelValue) {\n      emit(UPDATE_MODEL_EVENT, value);\n    }\n    if (!initData.dragging && props.modelValue !== initData.oldValue) {\n      initData.oldValue = props.modelValue;\n    }\n    await nextTick();\n    initData.dragging && displayTooltip();\n    tooltip.value.updatePopper();\n  };\n  watch(() => initData.dragging, val => {\n    updateDragging(val);\n  });\n  useEventListener(button, \"touchstart\", onButtonDown, {\n    passive: false\n  });\n  return {\n    disabled,\n    button,\n    tooltip,\n    tooltipVisible,\n    showTooltip,\n    persistent,\n    wrapperStyle,\n    formatValue,\n    handleMouseEnter,\n    handleMouseLeave,\n    onButtonDown,\n    onKeyDown,\n    setPosition\n  };\n};\nexport { useSliderButton };","map":{"version":3,"names":["useTooltip","props","formatTooltip","showTooltip","tooltip","ref","tooltipVisible","enableFormat","computed","value","Function","formatValue","modelValue","displayTooltip","debounce","hideTooltip","useSliderButton","initData","emit","disabled","min","max","step","persistent","precision","sliderSize","emitChange","resetSize","updateDragging","inject","sliderContextKey","button","currentPosition","wrapperStyle","vertical","bottom","left","handleMouseEnter","hovering","handleMouseLeave","dragging","onButtonDown","event","preventDefault","onDragStart","window","addEventListener","onDragging","onDragEnd","focus","incrementPosition","amount","newPosition","Number","parseFloat","setPosition","onLeftKeyDown","onRightKeyDown","onPageDownKeyDown","onPageUpKeyDown","onHomeKeyDown","onEndKeyDown","onKeyDown","code","getEventCode","isPreventDefault","EVENT_CODE","down","right","up","home","end","pageDown","pageUp","getClientXY","clientX","clientY","type","startsWith","touches","isClick","startY","startX","startPosition","diff","currentY","currentX","setTimeout","removeEventListener","isNaN","clamp","fullSteps","Math","floor","fullRangePercentage","threshold","valueBetween","steps","round","toFixed","UPDATE_MODEL_EVENT","oldValue","nextTick","updatePopper","watch","val","useEventListener","passive"],"sources":["../../../../../../../packages/components/slider/src/composables/use-slider-button.ts"],"sourcesContent":["import { computed, inject, nextTick, ref, watch } from 'vue'\nimport { clamp, debounce } from 'lodash-unified'\nimport { useEventListener } from '@vueuse/core'\nimport { EVENT_CODE, UPDATE_MODEL_EVENT } from '@element-plus/constants'\nimport { getEventCode } from '@element-plus/utils'\nimport { sliderContextKey } from '../constants'\n\nimport type { CSSProperties, ComputedRef, Ref, SetupContext } from 'vue'\nimport type { SliderProps } from '../slider'\nimport type {\n  SliderButtonEmits,\n  SliderButtonInitData,\n  SliderButtonProps,\n} from '../button'\nimport type { TooltipInstance } from '@element-plus/components/tooltip'\n\nconst useTooltip = (\n  props: SliderButtonProps,\n  formatTooltip: Ref<SliderProps['formatTooltip']>,\n  showTooltip: Ref<SliderProps['showTooltip']>\n) => {\n  const tooltip = ref<TooltipInstance>()\n\n  const tooltipVisible = ref(false)\n\n  const enableFormat = computed(() => {\n    return formatTooltip.value instanceof Function\n  })\n\n  const formatValue = computed(() => {\n    return (\n      (enableFormat.value && formatTooltip.value!(props.modelValue)) ||\n      props.modelValue\n    )\n  })\n\n  const displayTooltip = debounce(() => {\n    showTooltip.value && (tooltipVisible.value = true)\n  }, 50)\n\n  const hideTooltip = debounce(() => {\n    showTooltip.value && (tooltipVisible.value = false)\n  }, 50)\n\n  return {\n    tooltip,\n    tooltipVisible,\n    formatValue,\n    displayTooltip,\n    hideTooltip,\n  }\n}\n\nexport const useSliderButton = (\n  props: SliderButtonProps,\n  initData: SliderButtonInitData,\n  emit: SetupContext<SliderButtonEmits>['emit']\n) => {\n  const {\n    disabled,\n    min,\n    max,\n    step,\n    showTooltip,\n    persistent,\n    precision,\n    sliderSize,\n    formatTooltip,\n    emitChange,\n    resetSize,\n    updateDragging,\n  } = inject(sliderContextKey)!\n\n  const { tooltip, tooltipVisible, formatValue, displayTooltip, hideTooltip } =\n    useTooltip(props, formatTooltip!, showTooltip)\n\n  const button = ref<HTMLDivElement>()\n\n  const currentPosition = computed(() => {\n    return `${\n      ((props.modelValue - min.value) / (max.value - min.value)) * 100\n    }%`\n  })\n\n  const wrapperStyle: ComputedRef<CSSProperties> = computed(() => {\n    return props.vertical\n      ? { bottom: currentPosition.value }\n      : { left: currentPosition.value }\n  })\n\n  const handleMouseEnter = () => {\n    initData.hovering = true\n    displayTooltip()\n  }\n\n  const handleMouseLeave = () => {\n    initData.hovering = false\n    if (!initData.dragging) {\n      hideTooltip()\n    }\n  }\n\n  const onButtonDown = (event: MouseEvent | TouchEvent) => {\n    if (disabled.value) return\n    event.preventDefault()\n    onDragStart(event)\n    window.addEventListener('mousemove', onDragging)\n    window.addEventListener('touchmove', onDragging)\n    window.addEventListener('mouseup', onDragEnd)\n    window.addEventListener('touchend', onDragEnd)\n    window.addEventListener('contextmenu', onDragEnd)\n    button.value!.focus()\n  }\n\n  const incrementPosition = (amount: number) => {\n    if (disabled.value) return\n    initData.newPosition =\n      Number.parseFloat(currentPosition.value) +\n      (amount / (max.value - min.value)) * 100\n    setPosition(initData.newPosition)\n    emitChange()\n  }\n\n  const onLeftKeyDown = () => {\n    incrementPosition(-step.value)\n  }\n\n  const onRightKeyDown = () => {\n    incrementPosition(step.value)\n  }\n\n  const onPageDownKeyDown = () => {\n    incrementPosition(-step.value * 4)\n  }\n\n  const onPageUpKeyDown = () => {\n    incrementPosition(step.value * 4)\n  }\n\n  const onHomeKeyDown = () => {\n    if (disabled.value) return\n    setPosition(0)\n    emitChange()\n  }\n\n  const onEndKeyDown = () => {\n    if (disabled.value) return\n    setPosition(100)\n    emitChange()\n  }\n\n  const onKeyDown = (event: KeyboardEvent) => {\n    const code = getEventCode(event)\n    let isPreventDefault = true\n\n    switch (code) {\n      case EVENT_CODE.left:\n      case EVENT_CODE.down:\n        onLeftKeyDown()\n        break\n      case EVENT_CODE.right:\n      case EVENT_CODE.up:\n        onRightKeyDown()\n        break\n      case EVENT_CODE.home:\n        onHomeKeyDown()\n        break\n      case EVENT_CODE.end:\n        onEndKeyDown()\n        break\n      case EVENT_CODE.pageDown:\n        onPageDownKeyDown()\n        break\n      case EVENT_CODE.pageUp:\n        onPageUpKeyDown()\n        break\n      default:\n        isPreventDefault = false\n        break\n    }\n\n    isPreventDefault && event.preventDefault()\n  }\n\n  const getClientXY = (event: MouseEvent | TouchEvent) => {\n    let clientX: number\n    let clientY: number\n    if (event.type.startsWith('touch')) {\n      clientY = (event as TouchEvent).touches[0].clientY\n      clientX = (event as TouchEvent).touches[0].clientX\n    } else {\n      clientY = (event as MouseEvent).clientY\n      clientX = (event as MouseEvent).clientX\n    }\n    return {\n      clientX,\n      clientY,\n    }\n  }\n\n  const onDragStart = (event: MouseEvent | TouchEvent) => {\n    initData.dragging = true\n    initData.isClick = true\n    const { clientX, clientY } = getClientXY(event)\n    if (props.vertical) {\n      initData.startY = clientY\n    } else {\n      initData.startX = clientX\n    }\n    initData.startPosition = Number.parseFloat(currentPosition.value)\n    initData.newPosition = initData.startPosition\n  }\n\n  const onDragging = (event: MouseEvent | TouchEvent) => {\n    if (initData.dragging) {\n      initData.isClick = false\n      displayTooltip()\n      resetSize()\n      let diff: number\n      const { clientX, clientY } = getClientXY(event)\n      if (props.vertical) {\n        initData.currentY = clientY\n        diff = ((initData.startY - initData.currentY) / sliderSize.value) * 100\n      } else {\n        initData.currentX = clientX\n        diff = ((initData.currentX - initData.startX) / sliderSize.value) * 100\n      }\n      initData.newPosition = initData.startPosition + diff\n      setPosition(initData.newPosition)\n    }\n  }\n\n  const onDragEnd = () => {\n    if (initData.dragging) {\n      /*\n       * 防止在 mouseup 后立即触发 click，导致滑块有几率产生一小段位移\n       * 不使用 preventDefault 是因为 mouseup 和 click 没有注册在同一个 DOM 上\n       */\n      setTimeout(() => {\n        initData.dragging = false\n        if (!initData.hovering) {\n          hideTooltip()\n        }\n        if (!initData.isClick) {\n          setPosition(initData.newPosition)\n        }\n        emitChange()\n      }, 0)\n      window.removeEventListener('mousemove', onDragging)\n      window.removeEventListener('touchmove', onDragging)\n      window.removeEventListener('mouseup', onDragEnd)\n      window.removeEventListener('touchend', onDragEnd)\n      window.removeEventListener('contextmenu', onDragEnd)\n    }\n  }\n\n  const setPosition = async (newPosition: number) => {\n    if (newPosition === null || Number.isNaN(+newPosition)) return\n\n    newPosition = clamp(newPosition, 0, 100)\n    const fullSteps = Math.floor((max.value - min.value) / step.value)\n    const fullRangePercentage =\n      ((fullSteps * step.value) / (max.value - min.value)) * 100\n    const threshold = fullRangePercentage + (100 - fullRangePercentage) / 2\n    let value\n    if (newPosition < fullRangePercentage) {\n      const valueBetween = fullRangePercentage / fullSteps\n      const steps = Math.round(newPosition / valueBetween)\n      value = min.value + steps * step.value\n    } else if (newPosition < threshold) {\n      value = min.value + fullSteps * step.value\n    } else {\n      value = max.value\n    }\n    value = Number.parseFloat(value.toFixed(precision.value))\n\n    if (value !== props.modelValue) {\n      emit(UPDATE_MODEL_EVENT, value)\n    }\n\n    if (!initData.dragging && props.modelValue !== initData.oldValue) {\n      initData.oldValue = props.modelValue\n    }\n\n    await nextTick()\n    initData.dragging && displayTooltip()\n    tooltip.value!.updatePopper()\n  }\n\n  watch(\n    () => initData.dragging,\n    (val) => {\n      updateDragging(val)\n    }\n  )\n\n  useEventListener(button, 'touchstart', onButtonDown, { passive: false })\n\n  return {\n    disabled,\n    button,\n    tooltip,\n    tooltipVisible,\n    showTooltip,\n    persistent,\n    wrapperStyle,\n    formatValue,\n    handleMouseEnter,\n    handleMouseLeave,\n    onButtonDown,\n    onKeyDown,\n    setPosition,\n  }\n}\n"],"mappings":";;;;;;;AAgBA,MAAMA,UAAa,GAAAA,CACjBC,KACA,EAAAC,aAAA,EACAC,WACG;EACH,MAAMC,OAAA,GAAUC,GAAqB;EAE/B,MAAAC,cAAA,GAAiBD,GAAA,CAAI,KAAK;EAE1B,MAAAE,YAAA,GAAeC,QAAA,CAAS,MAAM;IAClC,OAAON,aAAA,CAAcO,KAAiB,YAAAC,QAAA;EAAA,CACvC;EAEK,MAAAC,WAAA,GAAcH,QAAA,CAAS,MAAM;IACjC,OACGD,YAAA,CAAaE,KAAS,IAAAP,aAAA,CAAcO,KAAA,CAAOR,KAAM,CAAAW,UAAU,KAC5DX,KAAM,CAAAW,UAAA;EAAA,CAET;EAEK,MAAAC,cAAA,GAAiBC,QAAA,CAAS,MAAM;IACxBX,WAAA,CAAAM,KAAA,KAAUH,cAAA,CAAeG,KAAQ;EAAA,GAC5C,EAAE;EAEC,MAAAM,WAAA,GAAcD,QAAA,CAAS,MAAM;IACrBX,WAAA,CAAAM,KAAA,KAAUH,cAAA,CAAeG,KAAQ;EAAA,GAC5C,EAAE;EAEE;IACLL,OAAA;IACAE,cAAA;IACAK,WAAA;IACAE,cAAA;IACAE;EAAA,CACF;AACF;AAEO,MAAMC,eAAkB,GAAAA,CAC7Bf,KACA,EAAAgB,QAAA,EACAC,IACG;EACG;IACJC,QAAA;IACAC,GAAA;IACAC,GAAA;IACAC,IAAA;IACAnB,WAAA;IACAoB,UAAA;IACAC,SAAA;IACAC,UAAA;IACAvB,aAAA;IACAwB,UAAA;IACAC,SAAA;IACAC;EAAA,CACF,GAAIC,MAAA,CAAOC,gBAAgB;EAErB;IAAE1B,OAAS;IAAAE,cAAA;IAAgBK,WAAa;IAAAE,cAAA;IAAgBE;EAAA,CAC5D,GAAAf,UAAA,CAAWC,KAAO,EAAAC,aAAA,EAAgBC,WAAW;EAE/C,MAAM4B,MAAA,GAAS1B,GAAoB;EAE7B,MAAA2B,eAAA,GAAkBxB,QAAA,CAAS,MAAM;IAC9B,WACHP,KAAA,CAAMW,UAAa,GAAAQ,GAAA,CAAIX,KAAA,KAAUY,GAAI,CAAAZ,KAAA,GAAQW,GAAA,CAAIX,KAAU;EAAA,CAEhE;EAEK,MAAAwB,YAAA,GAA2CzB,QAAA,CAAS,MAAM;IACvD,OAAAP,KAAA,CAAMiC,QACT;MAAEC,MAAQ,EAAAH,eAAA,CAAgBvB;IAAA,CAC1B;MAAE2B,IAAM,EAAAJ,eAAA,CAAgBvB;IAAM;EAAA,CACnC;EAED,MAAM4B,gBAAA,GAAmBA,CAAA,KAAM;IAC7BpB,QAAA,CAASqB,QAAW;IACLzB,cAAA;EAAA,CACjB;EAEA,MAAM0B,gBAAA,GAAmBA,CAAA,KAAM;IAC7BtB,QAAA,CAASqB,QAAW;IAChB,KAACrB,QAAA,CAASuB,QAAU;MACVzB,WAAA;IAAA;EACd,CACF;EAEM,MAAA0B,YAAA,GAAgBC,KAAmC;IACvD,IAAIvB,QAAS,CAAAV,KAAA,EAAO;IACpBiC,KAAA,CAAMC,cAAe;IACrBC,WAAA,CAAYF,KAAK;IACVG,MAAA,CAAAC,gBAAA,CAAiB,aAAaC,UAAU;IACxCF,MAAA,CAAAC,gBAAA,CAAiB,aAAaC,UAAU;IACxCF,MAAA,CAAAC,gBAAA,CAAiB,WAAWE,SAAS;IACrCH,MAAA,CAAAC,gBAAA,CAAiB,YAAYE,SAAS;IACtCH,MAAA,CAAAC,gBAAA,CAAiB,eAAeE,SAAS;IAChDjB,MAAA,CAAOtB,KAAA,CAAOwC,KAAM;EAAA,CACtB;EAEM,MAAAC,iBAAA,GAAqBC,MAAmB;IAC5C,IAAIhC,QAAS,CAAAV,KAAA,EAAO;IACXQ,QAAA,CAAAmC,WAAA,GACPC,MAAO,CAAAC,UAAA,CAAWtB,eAAgB,CAAAvB,KAAK,IACtC0C,MAAU,IAAA9B,GAAA,CAAIZ,KAAQ,GAAAW,GAAA,CAAIX,KAAU;IACvC8C,WAAA,CAAYtC,QAAA,CAASmC,WAAW;IACrB1B,UAAA;EAAA,CACb;EAEA,MAAM8B,aAAA,GAAgBA,CAAA,KAAM;IACRN,iBAAA,EAAC5B,IAAA,CAAKb,KAAK;EAAA,CAC/B;EAEA,MAAMgD,cAAA,GAAiBA,CAAA,KAAM;IAC3BP,iBAAA,CAAkB5B,IAAA,CAAKb,KAAK;EAAA,CAC9B;EAEA,MAAMiD,iBAAA,GAAoBA,CAAA,KAAM;IACZR,iBAAA,EAAC5B,IAAK,CAAAb,KAAA,GAAQ,CAAC;EAAA,CACnC;EAEA,MAAMkD,eAAA,GAAkBA,CAAA,KAAM;IACVT,iBAAA,CAAA5B,IAAA,CAAKb,KAAA,GAAQ,CAAC;EAAA,CAClC;EAEA,MAAMmD,aAAA,GAAgBA,CAAA,KAAM;IAC1B,IAAIzC,QAAS,CAAAV,KAAA,EAAO;IACpB8C,WAAA,CAAY,CAAC;IACF7B,UAAA;EAAA,CACb;EAEA,MAAMmC,YAAA,GAAeA,CAAA,KAAM;IACzB,IAAI1C,QAAS,CAAAV,KAAA,EAAO;IACpB8C,WAAA,CAAY,GAAG;IACJ7B,UAAA;EAAA,CACb;EAEM,MAAAoC,SAAA,GAAapB,KAAyB;IACpC,MAAAqB,IAAA,GAAOC,YAAA,CAAatB,KAAK;IAC/B,IAAIuB,gBAAmB;IAEf,QAAAF,IAAA;MAAA,KACDG,UAAW,CAAA9B,IAAA;MAAA,KACX8B,UAAW,CAAAC,IAAA;QACAX,aAAA;QACd;MAAA,KACGU,UAAW,CAAAE,KAAA;MAAA,KACXF,UAAW,CAAAG,EAAA;QACCZ,cAAA;QACf;MAAA,KACGS,UAAW,CAAAI,IAAA;QACAV,aAAA;QACd;MAAA,KACGM,UAAW,CAAAK,GAAA;QACDV,YAAA;QACb;MAAA,KACGK,UAAW,CAAAM,QAAA;QACId,iBAAA;QAClB;MAAA,KACGQ,UAAW,CAAAO,MAAA;QACEd,eAAA;QAChB;MAAA;QAEmBM,gBAAA;QACnB;IAAA;IAGJA,gBAAA,IAAoBvB,KAAA,CAAMC,cAAe;EAAA,CAC3C;EAEM,MAAA+B,WAAA,GAAehC,KAAmC;IAClD,IAAAiC,OAAA;IACA,IAAAC,OAAA;IACJ,IAAIlC,KAAM,CAAAmC,IAAA,CAAKC,UAAW,QAAO,CAAG;MACvBF,OAAA,GAAAlC,KAAA,CAAqBqC,OAAA,CAAQ,CAAG,EAAAH,OAAA;MAChCD,OAAA,GAAAjC,KAAA,CAAqBqC,OAAA,CAAQ,CAAG,EAAAJ,OAAA;IAAA,CACtC;MACLC,OAAA,GAAWlC,KAAqB,CAAAkC,OAAA;MAChCD,OAAA,GAAWjC,KAAqB,CAAAiC,OAAA;IAAA;IAE3B;MACLA,OAAA;MACAC;IAAA,CACF;EAAA,CACF;EAEM,MAAAhC,WAAA,GAAeF,KAAmC;IACtDzB,QAAA,CAASuB,QAAW;IACpBvB,QAAA,CAAS+D,OAAU;IACnB,MAAM;MAAEL,OAAA;MAASC;IAAQ,IAAIF,WAAA,CAAYhC,KAAK;IAC9C,IAAIzC,KAAA,CAAMiC,QAAU;MAClBjB,QAAA,CAASgE,MAAS,GAAAL,OAAA;IAAA,CACb;MACL3D,QAAA,CAASiE,MAAS,GAAAP,OAAA;IAAA;IAEpB1D,QAAA,CAASkE,aAAgB,GAAA9B,MAAA,CAAOC,UAAW,CAAAtB,eAAA,CAAgBvB,KAAK;IAChEQ,QAAA,CAASmC,WAAA,GAAcnC,QAAS,CAAAkE,aAAA;EAAA,CAClC;EAEM,MAAApC,UAAA,GAAcL,KAAmC;IACrD,IAAIzB,QAAA,CAASuB,QAAU;MACrBvB,QAAA,CAAS+D,OAAU;MACJnE,cAAA;MACLc,SAAA;MACN,IAAAyD,IAAA;MACJ,MAAM;QAAET,OAAA;QAASC;MAAQ,IAAIF,WAAA,CAAYhC,KAAK;MAC9C,IAAIzC,KAAA,CAAMiC,QAAU;QAClBjB,QAAA,CAASoE,QAAW,GAAAT,OAAA;QACpBQ,IAAA,IAASnE,QAAS,CAAAgE,MAAA,GAAShE,QAAS,CAAAoE,QAAA,IAAY5D,UAAA,CAAWhB,KAAS;MAAA,CAC/D;QACLQ,QAAA,CAASqE,QAAW,GAAAX,OAAA;QACpBS,IAAA,IAASnE,QAAS,CAAAqE,QAAA,GAAWrE,QAAS,CAAAiE,MAAA,IAAUzD,UAAA,CAAWhB,KAAS;MAAA;MAE7DQ,QAAA,CAAAmC,WAAA,GAAcnC,QAAA,CAASkE,aAAgB,GAAAC,IAAA;MAChD7B,WAAA,CAAYtC,QAAA,CAASmC,WAAW;IAAA;EAClC,CACF;EAEA,MAAMJ,SAAA,GAAYA,CAAA,KAAM;IACtB,IAAI/B,QAAA,CAASuB,QAAU;MAKrB+C,UAAA,CAAW,MAAM;QACftE,QAAA,CAASuB,QAAW;QAChB,KAACvB,QAAA,CAASqB,QAAU;UACVvB,WAAA;QAAA;QAEV,KAACE,QAAA,CAAS+D,OAAS;UACrBzB,WAAA,CAAYtC,QAAA,CAASmC,WAAW;QAAA;QAEvB1B,UAAA;MAAA,GACV,CAAC;MACGmB,MAAA,CAAA2C,mBAAA,CAAoB,aAAazC,UAAU;MAC3CF,MAAA,CAAA2C,mBAAA,CAAoB,aAAazC,UAAU;MAC3CF,MAAA,CAAA2C,mBAAA,CAAoB,WAAWxC,SAAS;MACxCH,MAAA,CAAA2C,mBAAA,CAAoB,YAAYxC,SAAS;MACzCH,MAAA,CAAA2C,mBAAA,CAAoB,eAAexC,SAAS;IAAA;EACrD,CACF;EAEM,MAAAO,WAAA,GAAc,MAAOH,WAAwB;IACjD,IAAIA,WAAgB,aAAQC,MAAO,CAAAoC,KAAA,CAAM,CAACrC,WAAW,GAAG;IAE1CA,WAAA,GAAAsC,KAAA,CAAMtC,WAAa,KAAG,GAAG;IACjC,MAAAuC,SAAA,GAAYC,IAAA,CAAKC,KAAO,EAAAxE,GAAA,CAAIZ,KAAA,GAAQW,GAAI,CAAAX,KAAA,IAASa,IAAA,CAAKb,KAAK;IACjE,MAAMqF,mBAAA,GACFH,SAAY,GAAArE,IAAA,CAAKb,KAAA,IAAUY,GAAI,CAAAZ,KAAA,GAAQW,GAAA,CAAIX,KAAU;IACnD,MAAAsF,SAAA,GAAYD,mBAAuB,UAAMA,mBAAuB;IAClE,IAAArF,KAAA;IACJ,IAAI2C,WAAA,GAAc0C,mBAAqB;MACrC,MAAME,YAAA,GAAeF,mBAAsB,GAAAH,SAAA;MAC3C,MAAMM,KAAQ,GAAAL,IAAA,CAAKM,KAAM,CAAA9C,WAAA,GAAc4C,YAAY;MAC3CvF,KAAA,GAAAW,GAAA,CAAIX,KAAQ,GAAAwF,KAAA,GAAQ3E,IAAK,CAAAb,KAAA;IAAA,CACnC,UAAW2C,WAAA,GAAc2C,SAAW;MAC1BtF,KAAA,GAAAW,GAAA,CAAIX,KAAQ,GAAAkF,SAAA,GAAYrE,IAAK,CAAAb,KAAA;IAAA,CAChC;MACLA,KAAA,GAAQY,GAAI,CAAAZ,KAAA;IAAA;IAEdA,KAAA,GAAQ4C,MAAA,CAAOC,UAAW,CAAA7C,KAAA,CAAM0F,OAAQ,CAAA3E,SAAA,CAAUf,KAAK,CAAC;IAEpD,IAAAA,KAAA,KAAUR,KAAA,CAAMW,UAAY;MAC9BM,IAAA,CAAKkF,kBAAA,EAAoB3F,KAAK;IAAA;IAGhC,IAAI,CAACQ,QAAS,CAAAuB,QAAA,IAAYvC,KAAM,CAAAW,UAAA,KAAeK,QAAA,CAASoF,QAAU;MAChEpF,QAAA,CAASoF,QAAA,GAAWpG,KAAM,CAAAW,UAAA;IAAA;IAG5B,MAAM0F,QAAS;IACfrF,QAAA,CAASuB,QAAA,IAAY3B,cAAe;IACpCT,OAAA,CAAQK,KAAA,CAAO8F,YAAa;EAAA,CAC9B;EAEAC,KAAA,CACE,MAAMvF,QAAS,CAAAuB,QAAA,EACdiE,GAAQ;IACP7E,cAAA,CAAe6E,GAAG;EAAA,CACpB,CACF;EAEAC,gBAAA,CAAiB3E,MAAA,EAAQ,YAAc,EAAAU,YAAA,EAAc;IAAEkE,OAAA,EAAS;EAAA,CAAO;EAEhE;IACLxF,QAAA;IACAY,MAAA;IACA3B,OAAA;IACAE,cAAA;IACAH,WAAA;IACAoB,UAAA;IACAU,YAAA;IACAtB,WAAA;IACA0B,gBAAA;IACAE,gBAAA;IACAE,YAAA;IACAqB,SAAA;IACAP;EAAA,CACF;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}