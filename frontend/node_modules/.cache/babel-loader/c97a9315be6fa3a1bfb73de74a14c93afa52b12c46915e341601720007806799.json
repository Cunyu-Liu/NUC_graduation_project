{"ast":null,"code":"import \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport { isVNode, render, markRaw, createVNode } from 'vue';\nimport MessageBoxConstructor from './index.mjs';\nimport { isClient } from '@vueuse/core';\nimport { isString, isObject, hasOwn, isFunction } from '@vue/shared';\nimport { isUndefined, isElement } from '../../../utils/types.mjs';\nimport { debugWarn } from '../../../utils/error.mjs';\nconst messageInstance = /* @__PURE__ */new Map();\nconst getAppendToElement = props => {\n  let appendTo = document.body;\n  if (props.appendTo) {\n    if (isString(props.appendTo)) {\n      appendTo = document.querySelector(props.appendTo);\n    }\n    if (isElement(props.appendTo)) {\n      appendTo = props.appendTo;\n    }\n    if (!isElement(appendTo)) {\n      debugWarn(\"ElMessageBox\", \"the appendTo option is not an HTMLElement. Falling back to document.body.\");\n      appendTo = document.body;\n    }\n  }\n  return appendTo;\n};\nconst initInstance = (props, container, appContext = null) => {\n  const vnode = createVNode(MessageBoxConstructor, props, isFunction(props.message) || isVNode(props.message) ? {\n    default: isFunction(props.message) ? props.message : () => props.message\n  } : null);\n  vnode.appContext = appContext;\n  render(vnode, container);\n  getAppendToElement(props).appendChild(container.firstElementChild);\n  return vnode.component;\n};\nconst genContainer = () => {\n  return document.createElement(\"div\");\n};\nconst showMessage = (options, appContext) => {\n  const container = genContainer();\n  options.onVanish = () => {\n    render(null, container);\n    messageInstance.delete(vm);\n  };\n  options.onAction = action => {\n    const currentMsg = messageInstance.get(vm);\n    let resolve;\n    if (options.showInput) {\n      resolve = {\n        value: vm.inputValue,\n        action\n      };\n    } else {\n      resolve = action;\n    }\n    if (options.callback) {\n      options.callback(resolve, instance.proxy);\n    } else {\n      if (action === \"cancel\" || action === \"close\") {\n        if (options.distinguishCancelAndClose && action !== \"cancel\") {\n          currentMsg.reject(\"close\");\n        } else {\n          currentMsg.reject(\"cancel\");\n        }\n      } else {\n        currentMsg.resolve(resolve);\n      }\n    }\n  };\n  const instance = initInstance(options, container, appContext);\n  const vm = instance.proxy;\n  for (const prop in options) {\n    if (hasOwn(options, prop) && !hasOwn(vm.$props, prop)) {\n      if (prop === \"closeIcon\" && isObject(options[prop])) {\n        vm[prop] = markRaw(options[prop]);\n      } else {\n        vm[prop] = options[prop];\n      }\n    }\n  }\n  vm.visible = true;\n  return vm;\n};\nfunction MessageBox(options, appContext = null) {\n  if (!isClient) return Promise.reject();\n  let callback;\n  if (isString(options) || isVNode(options)) {\n    options = {\n      message: options\n    };\n  } else {\n    callback = options.callback;\n  }\n  return new Promise((resolve, reject) => {\n    const vm = showMessage(options, appContext != null ? appContext : MessageBox._context);\n    messageInstance.set(vm, {\n      options,\n      callback,\n      resolve,\n      reject\n    });\n  });\n}\nconst MESSAGE_BOX_VARIANTS = [\"alert\", \"confirm\", \"prompt\"];\nconst MESSAGE_BOX_DEFAULT_OPTS = {\n  alert: {\n    closeOnPressEscape: false,\n    closeOnClickModal: false\n  },\n  confirm: {\n    showCancelButton: true\n  },\n  prompt: {\n    showCancelButton: true,\n    showInput: true\n  }\n};\nMESSAGE_BOX_VARIANTS.forEach(boxType => {\n  MessageBox[boxType] = messageBoxFactory(boxType);\n});\nfunction messageBoxFactory(boxType) {\n  return (message, title, options, appContext) => {\n    let titleOrOpts = \"\";\n    if (isObject(title)) {\n      options = title;\n      titleOrOpts = \"\";\n    } else if (isUndefined(title)) {\n      titleOrOpts = \"\";\n    } else {\n      titleOrOpts = title;\n    }\n    return MessageBox(Object.assign({\n      title: titleOrOpts,\n      message,\n      type: \"\",\n      ...MESSAGE_BOX_DEFAULT_OPTS[boxType]\n    }, options, {\n      boxType\n    }), appContext);\n  };\n}\nMessageBox.close = () => {\n  messageInstance.forEach((_, vm) => {\n    vm.doClose();\n  });\n  messageInstance.clear();\n};\nMessageBox._context = null;\nexport { MessageBox as default };","map":{"version":3,"names":["messageInstance","Map","getAppendToElement","props","appendTo","document","body","isString","querySelector","isElement","debugWarn","initInstance","container","appContext","vnode","createVNode","MessageBoxConstructor","isFunction","message","isVNode","default","render","appendChild","firstElementChild","component","genContainer","createElement","showMessage","options","onVanish","delete","vm","onAction","action","currentMsg","get","resolve","showInput","value","inputValue","callback","instance","proxy","distinguishCancelAndClose","reject","prop","hasOwn","$props","isObject","markRaw","visible","MessageBox","isClient","Promise","_context","set","MESSAGE_BOX_VARIANTS","MESSAGE_BOX_DEFAULT_OPTS","alert","closeOnPressEscape","closeOnClickModal","confirm","showCancelButton","prompt","forEach","boxType","messageBoxFactory","title","titleOrOpts","isUndefined","Object","assign","type","close","_","doClose","clear"],"sources":["../../../../../../packages/components/message-box/src/messageBox.ts"],"sourcesContent":["import { createVNode, isVNode, markRaw, render } from 'vue'\nimport {\n  debugWarn,\n  hasOwn,\n  isClient,\n  isElement,\n  isFunction,\n  isObject,\n  isString,\n  isUndefined,\n} from '@element-plus/utils'\nimport MessageBoxConstructor from './index.vue'\n\nimport type { AppContext, ComponentPublicInstance, VNode } from 'vue'\nimport type {\n  Action,\n  Callback,\n  ElMessageBoxOptions,\n  ElMessageBoxShortcutMethod,\n  IElMessageBox,\n  MessageBoxData,\n  MessageBoxState,\n} from './message-box.type'\n\n// component default merge props & data\n\nconst messageInstance = new Map<\n  ComponentPublicInstance<{ doClose: () => void }>, // marking doClose as function\n  {\n    options: any\n    callback: Callback | undefined\n    resolve: (res: any) => void\n    reject: (reason?: any) => void\n  }\n>()\n\nconst getAppendToElement = (props: any): HTMLElement => {\n  let appendTo: HTMLElement | null = document.body\n  if (props.appendTo) {\n    if (isString(props.appendTo)) {\n      appendTo = document.querySelector<HTMLElement>(props.appendTo)\n    }\n    if (isElement(props.appendTo)) {\n      appendTo = props.appendTo\n    }\n\n    // should fallback to default value with a warning\n    if (!isElement(appendTo)) {\n      debugWarn(\n        'ElMessageBox',\n        'the appendTo option is not an HTMLElement. Falling back to document.body.'\n      )\n      appendTo = document.body\n    }\n  }\n  return appendTo\n}\n\nconst initInstance = (\n  props: any,\n  container: HTMLElement,\n  appContext: AppContext | null = null\n) => {\n  const vnode = createVNode(\n    MessageBoxConstructor,\n    props,\n    isFunction(props.message) || isVNode(props.message)\n      ? {\n          default: isFunction(props.message)\n            ? props.message\n            : () => props.message,\n        }\n      : null\n  )\n  vnode.appContext = appContext\n  render(vnode, container)\n  getAppendToElement(props).appendChild(container.firstElementChild!)\n  return vnode.component\n}\n\nconst genContainer = () => {\n  return document.createElement('div')\n}\n\nconst showMessage = (options: any, appContext?: AppContext | null) => {\n  const container = genContainer()\n  // Adding destruct method.\n  // when transition leaves emitting `vanish` evt. so that we can do the clean job.\n  options.onVanish = () => {\n    // not sure if this causes mem leak, need proof to verify that.\n    // maybe calling out like 1000 msg-box then close them all.\n    render(null, container)\n    messageInstance.delete(vm) // Remove vm to avoid mem leak.\n    // here we were suppose to call document.body.removeChild(container.firstElementChild)\n    // but render(null, container) did that job for us. so that we do not call that directly\n  }\n\n  options.onAction = (action: Action) => {\n    const currentMsg = messageInstance.get(vm)!\n    let resolve: Action | { value: string; action: Action }\n    if (options.showInput) {\n      resolve = { value: vm.inputValue, action }\n    } else {\n      resolve = action\n    }\n    if (options.callback) {\n      options.callback(resolve, instance.proxy)\n    } else {\n      if (action === 'cancel' || action === 'close') {\n        if (options.distinguishCancelAndClose && action !== 'cancel') {\n          currentMsg.reject('close')\n        } else {\n          currentMsg.reject('cancel')\n        }\n      } else {\n        currentMsg.resolve(resolve)\n      }\n    }\n  }\n\n  const instance = initInstance(options, container, appContext)!\n\n  // This is how we use message box programmatically.\n  // Maybe consider releasing a template version?\n  // get component instance like v2.\n  const vm = instance.proxy as ComponentPublicInstance<\n    {\n      visible: boolean\n      doClose: () => void\n    } & MessageBoxState\n  >\n\n  for (const prop in options) {\n    if (hasOwn(options, prop) && !hasOwn(vm.$props, prop)) {\n      if (prop === 'closeIcon' && isObject(options[prop])) {\n        vm[prop as keyof ComponentPublicInstance] = markRaw(options[prop])\n      } else {\n        vm[prop as keyof ComponentPublicInstance] = options[prop]\n      }\n    }\n  }\n\n  // change visibility after everything is settled\n  vm.visible = true\n  return vm\n}\n\nasync function MessageBox(\n  options: ElMessageBoxOptions,\n  appContext?: AppContext | null\n): Promise<MessageBoxData>\nfunction MessageBox(\n  options: ElMessageBoxOptions | string | VNode,\n  appContext: AppContext | null = null\n): Promise<{ value: string; action: Action } | Action> {\n  if (!isClient) return Promise.reject()\n  let callback: Callback | undefined\n  if (isString(options) || isVNode(options)) {\n    options = {\n      message: options,\n    }\n  } else {\n    callback = options.callback\n  }\n\n  return new Promise((resolve, reject) => {\n    const vm = showMessage(\n      options,\n      appContext ?? (MessageBox as IElMessageBox)._context\n    )\n    // collect this vm in order to handle upcoming events.\n    messageInstance.set(vm, {\n      options,\n      callback,\n      resolve,\n      reject,\n    })\n  })\n}\n\nconst MESSAGE_BOX_VARIANTS = ['alert', 'confirm', 'prompt'] as const\nconst MESSAGE_BOX_DEFAULT_OPTS: Record<\n  (typeof MESSAGE_BOX_VARIANTS)[number],\n  Partial<ElMessageBoxOptions>\n> = {\n  alert: { closeOnPressEscape: false, closeOnClickModal: false },\n  confirm: { showCancelButton: true },\n  prompt: { showCancelButton: true, showInput: true },\n}\n\nMESSAGE_BOX_VARIANTS.forEach((boxType) => {\n  ;(MessageBox as IElMessageBox)[boxType] = messageBoxFactory(\n    boxType\n  ) as ElMessageBoxShortcutMethod\n})\n\nfunction messageBoxFactory(boxType: (typeof MESSAGE_BOX_VARIANTS)[number]) {\n  return (\n    message: string | VNode,\n    title: string | ElMessageBoxOptions,\n    options?: ElMessageBoxOptions,\n    appContext?: AppContext | null\n  ) => {\n    let titleOrOpts = ''\n    if (isObject(title)) {\n      options = title as ElMessageBoxOptions\n      titleOrOpts = ''\n    } else if (isUndefined(title)) {\n      titleOrOpts = ''\n    } else {\n      titleOrOpts = title as string\n    }\n\n    return MessageBox(\n      Object.assign(\n        {\n          title: titleOrOpts,\n          message,\n          type: '',\n          ...MESSAGE_BOX_DEFAULT_OPTS[boxType],\n        },\n        options,\n        {\n          boxType,\n        }\n      ),\n      appContext\n    )\n  }\n}\n\nMessageBox.close = () => {\n  // instance.setupInstall.doClose()\n  // instance.setupInstall.state.visible = false\n\n  messageInstance.forEach((_, vm) => {\n    vm.doClose()\n  })\n\n  messageInstance.clear()\n}\n;(MessageBox as IElMessageBox)._context = null\n\nexport default MessageBox as IElMessageBox\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}