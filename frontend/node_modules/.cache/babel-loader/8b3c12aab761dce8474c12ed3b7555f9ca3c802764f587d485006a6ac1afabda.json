{"ast":null,"code":"import \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.some.js\";\nimport { getCurrentInstance, useSlots, ref, computed, unref, watch, shallowRef, onMounted, onBeforeUnmount, provide, isVNode } from 'vue';\nimport { throttle } from 'lodash-unified';\nimport { useResizeObserver } from '@vueuse/core';\nimport { carouselContextKey, CAROUSEL_ITEM_NAME } from './constants.mjs';\nimport { useOrderedChildren } from '../../../hooks/use-ordered-children/index.mjs';\nimport { isString } from '@vue/shared';\nimport { debugWarn } from '../../../utils/error.mjs';\nimport { CHANGE_EVENT } from '../../../constants/event.mjs';\nimport { flattedChildren } from '../../../utils/vue/vnode.mjs';\nconst THROTTLE_TIME = 300;\nconst useCarousel = (props, emit, componentName) => {\n  const {\n    children: items,\n    addChild: addItem,\n    removeChild: removeItem,\n    ChildrenSorter: ItemsSorter\n  } = useOrderedChildren(getCurrentInstance(), CAROUSEL_ITEM_NAME);\n  const slots = useSlots();\n  const activeIndex = ref(-1);\n  const timer = ref(null);\n  const hover = ref(false);\n  const root = ref();\n  const containerHeight = ref(0);\n  const isItemsTwoLength = ref(true);\n  const arrowDisplay = computed(() => props.arrow !== \"never\" && !unref(isVertical));\n  const hasLabel = computed(() => {\n    return items.value.some(item => item.props.label.toString().length > 0);\n  });\n  const isCardType = computed(() => props.type === \"card\");\n  const isVertical = computed(() => props.direction === \"vertical\");\n  const containerStyle = computed(() => {\n    if (props.height !== \"auto\") {\n      return {\n        height: props.height\n      };\n    }\n    return {\n      height: `${containerHeight.value}px`,\n      overflow: \"hidden\"\n    };\n  });\n  const throttledArrowClick = throttle(index => {\n    setActiveItem(index);\n  }, THROTTLE_TIME, {\n    trailing: true\n  });\n  const throttledIndicatorHover = throttle(index => {\n    handleIndicatorHover(index);\n  }, THROTTLE_TIME);\n  const isTwoLengthShow = index => {\n    if (!isItemsTwoLength.value) return true;\n    return activeIndex.value <= 1 ? index <= 1 : index > 1;\n  };\n  function pauseTimer() {\n    if (timer.value) {\n      clearInterval(timer.value);\n      timer.value = null;\n    }\n  }\n  function startTimer() {\n    if (props.interval <= 0 || !props.autoplay || timer.value) return;\n    timer.value = setInterval(() => playSlides(), props.interval);\n  }\n  const playSlides = () => {\n    if (activeIndex.value < items.value.length - 1) {\n      activeIndex.value = activeIndex.value + 1;\n    } else if (props.loop) {\n      activeIndex.value = 0;\n    }\n  };\n  function setActiveItem(index) {\n    if (isString(index)) {\n      const filteredItems = items.value.filter(item => item.props.name === index);\n      if (filteredItems.length > 0) {\n        index = items.value.indexOf(filteredItems[0]);\n      }\n    }\n    index = Number(index);\n    if (Number.isNaN(index) || index !== Math.floor(index)) {\n      debugWarn(componentName, \"index must be integer.\");\n      return;\n    }\n    const itemCount = items.value.length;\n    const oldIndex = activeIndex.value;\n    if (index < 0) {\n      activeIndex.value = props.loop ? itemCount - 1 : 0;\n    } else if (index >= itemCount) {\n      activeIndex.value = props.loop ? 0 : itemCount - 1;\n    } else {\n      activeIndex.value = index;\n    }\n    if (oldIndex === activeIndex.value) {\n      resetItemPosition(oldIndex);\n    }\n    resetTimer();\n  }\n  function resetItemPosition(oldIndex) {\n    items.value.forEach((item, index) => {\n      item.translateItem(index, activeIndex.value, oldIndex);\n    });\n  }\n  function itemInStage(item, index) {\n    var _a, _b, _c, _d;\n    const _items = unref(items);\n    const itemCount = _items.length;\n    if (itemCount === 0 || !item.states.inStage) return false;\n    const nextItemIndex = index + 1;\n    const prevItemIndex = index - 1;\n    const lastItemIndex = itemCount - 1;\n    const isLastItemActive = _items[lastItemIndex].states.active;\n    const isFirstItemActive = _items[0].states.active;\n    const isNextItemActive = (_b = (_a = _items[nextItemIndex]) == null ? void 0 : _a.states) == null ? void 0 : _b.active;\n    const isPrevItemActive = (_d = (_c = _items[prevItemIndex]) == null ? void 0 : _c.states) == null ? void 0 : _d.active;\n    if (index === lastItemIndex && isFirstItemActive || isNextItemActive) {\n      return \"left\";\n    } else if (index === 0 && isLastItemActive || isPrevItemActive) {\n      return \"right\";\n    }\n    return false;\n  }\n  function handleMouseEnter() {\n    hover.value = true;\n    if (props.pauseOnHover) {\n      pauseTimer();\n    }\n  }\n  function handleMouseLeave() {\n    hover.value = false;\n    startTimer();\n  }\n  function handleButtonEnter(arrow) {\n    if (unref(isVertical)) return;\n    items.value.forEach((item, index) => {\n      if (arrow === itemInStage(item, index)) {\n        item.states.hover = true;\n      }\n    });\n  }\n  function handleButtonLeave() {\n    if (unref(isVertical)) return;\n    items.value.forEach(item => {\n      item.states.hover = false;\n    });\n  }\n  function handleIndicatorClick(index) {\n    activeIndex.value = index;\n  }\n  function handleIndicatorHover(index) {\n    if (props.trigger === \"hover\" && index !== activeIndex.value) {\n      activeIndex.value = index;\n    }\n  }\n  function prev() {\n    setActiveItem(activeIndex.value - 1);\n  }\n  function next() {\n    setActiveItem(activeIndex.value + 1);\n  }\n  function resetTimer() {\n    pauseTimer();\n    if (!props.pauseOnHover) startTimer();\n  }\n  function setContainerHeight(height) {\n    if (props.height !== \"auto\") return;\n    containerHeight.value = height;\n  }\n  function PlaceholderItem() {\n    var _a;\n    const defaultSlots = (_a = slots.default) == null ? void 0 : _a.call(slots);\n    if (!defaultSlots) return null;\n    const flatSlots = flattedChildren(defaultSlots);\n    const normalizeSlots = flatSlots.filter(slot => {\n      return isVNode(slot) && slot.type.name === CAROUSEL_ITEM_NAME;\n    });\n    if ((normalizeSlots == null ? void 0 : normalizeSlots.length) === 2 && props.loop && !isCardType.value) {\n      isItemsTwoLength.value = true;\n      return normalizeSlots;\n    }\n    isItemsTwoLength.value = false;\n    return null;\n  }\n  watch(() => activeIndex.value, (current, prev2) => {\n    resetItemPosition(prev2);\n    if (isItemsTwoLength.value) {\n      current = current % 2;\n      prev2 = prev2 % 2;\n    }\n    if (prev2 > -1) {\n      emit(CHANGE_EVENT, current, prev2);\n    }\n  });\n  const exposeActiveIndex = computed({\n    get: () => {\n      return isItemsTwoLength.value ? activeIndex.value % 2 : activeIndex.value;\n    },\n    set: value => activeIndex.value = value\n  });\n  watch(() => props.autoplay, autoplay => {\n    autoplay ? startTimer() : pauseTimer();\n  });\n  watch(() => props.loop, () => {\n    setActiveItem(activeIndex.value);\n  });\n  watch(() => props.interval, () => {\n    resetTimer();\n  });\n  const resizeObserver = shallowRef();\n  onMounted(() => {\n    watch(() => items.value, () => {\n      if (items.value.length > 0) setActiveItem(props.initialIndex);\n    }, {\n      immediate: true\n    });\n    resizeObserver.value = useResizeObserver(root.value, () => {\n      resetItemPosition();\n    });\n    startTimer();\n  });\n  onBeforeUnmount(() => {\n    pauseTimer();\n    if (root.value && resizeObserver.value) resizeObserver.value.stop();\n  });\n  provide(carouselContextKey, {\n    root,\n    isCardType,\n    isVertical,\n    items,\n    loop: props.loop,\n    cardScale: props.cardScale,\n    addItem,\n    removeItem,\n    setActiveItem,\n    setContainerHeight\n  });\n  return {\n    root,\n    activeIndex,\n    exposeActiveIndex,\n    arrowDisplay,\n    hasLabel,\n    hover,\n    isCardType,\n    items,\n    isVertical,\n    containerStyle,\n    isItemsTwoLength,\n    handleButtonEnter,\n    handleButtonLeave,\n    handleIndicatorClick,\n    handleMouseEnter,\n    handleMouseLeave,\n    setActiveItem,\n    prev,\n    next,\n    PlaceholderItem,\n    isTwoLengthShow,\n    ItemsSorter,\n    throttledArrowClick,\n    throttledIndicatorHover\n  };\n};\nexport { useCarousel };","map":{"version":3,"names":["THROTTLE_TIME","useCarousel","props","emit","componentName","children","items","addChild","addItem","removeChild","removeItem","ChildrenSorter","ItemsSorter","useOrderedChildren","getCurrentInstance","CAROUSEL_ITEM_NAME","slots","useSlots","activeIndex","ref","timer","hover","root","containerHeight","isItemsTwoLength","arrowDisplay","computed","arrow","unref","isVertical","hasLabel","value","some","item","label","toString","length","isCardType","type","direction","containerStyle","height","overflow","throttledArrowClick","throttle","index","setActiveItem","trailing","throttledIndicatorHover","handleIndicatorHover","isTwoLengthShow","pauseTimer","clearInterval","startTimer","interval","autoplay","setInterval","playSlides","loop","isString","filteredItems","filter","name","indexOf","Number","isNaN","Math","floor","debugWarn","itemCount","oldIndex","resetItemPosition","resetTimer","forEach","translateItem","itemInStage","_a","_b","_c","_d","_items","states","inStage","nextItemIndex","prevItemIndex","lastItemIndex","isLastItemActive","active","isFirstItemActive","isNextItemActive","isPrevItemActive","handleMouseEnter","pauseOnHover","handleMouseLeave","handleButtonEnter","handleButtonLeave","handleIndicatorClick","trigger","prev","next","setContainerHeight","PlaceholderItem","defaultSlots","default","call","flatSlots","flattedChildren","normalizeSlots","slot","isVNode","watch","current","prev2","CHANGE_EVENT","exposeActiveIndex","get","set","resizeObserver","shallowRef","onMounted","initialIndex","immediate","useResizeObserver","onBeforeUnmount","stop","provide","carouselContextKey","cardScale"],"sources":["../../../../../../packages/components/carousel/src/use-carousel.ts"],"sourcesContent":["import {\n  computed,\n  getCurrentInstance,\n  isVNode,\n  onBeforeUnmount,\n  onMounted,\n  provide,\n  ref,\n  shallowRef,\n  unref,\n  useSlots,\n  watch,\n} from 'vue'\nimport { throttle } from 'lodash-unified'\nimport { useResizeObserver } from '@vueuse/core'\nimport { debugWarn, flattedChildren, isString } from '@element-plus/utils'\nimport { useOrderedChildren } from '@element-plus/hooks'\nimport { CHANGE_EVENT } from '@element-plus/constants'\nimport { CAROUSEL_ITEM_NAME, carouselContextKey } from './constants'\n\nimport type { SetupContext } from 'vue'\nimport type { CarouselItemContext } from './constants'\nimport type { CarouselEmits, CarouselProps } from './carousel'\n\nconst THROTTLE_TIME = 300\n\nexport const useCarousel = (\n  props: CarouselProps,\n  emit: SetupContext<CarouselEmits>['emit'],\n  componentName: string\n) => {\n  const {\n    children: items,\n    addChild: addItem,\n    removeChild: removeItem,\n    ChildrenSorter: ItemsSorter,\n  } = useOrderedChildren<CarouselItemContext>(\n    getCurrentInstance()!,\n    CAROUSEL_ITEM_NAME\n  )\n\n  const slots = useSlots()\n\n  // refs\n  const activeIndex = ref(-1)\n  const timer = ref<ReturnType<typeof setInterval> | null>(null)\n  const hover = ref(false)\n  const root = ref<HTMLDivElement>()\n  const containerHeight = ref<number>(0)\n  const isItemsTwoLength = ref(true)\n\n  // computed\n  const arrowDisplay = computed(\n    () => props.arrow !== 'never' && !unref(isVertical)\n  )\n\n  const hasLabel = computed(() => {\n    return items.value.some((item) => item.props.label.toString().length > 0)\n  })\n\n  const isCardType = computed(() => props.type === 'card')\n  const isVertical = computed(() => props.direction === 'vertical')\n\n  const containerStyle = computed(() => {\n    if (props.height !== 'auto') {\n      return {\n        height: props.height,\n      }\n    }\n    return {\n      height: `${containerHeight.value}px`,\n      overflow: 'hidden',\n    }\n  })\n\n  // methods\n  const throttledArrowClick = throttle(\n    (index: number) => {\n      setActiveItem(index)\n    },\n    THROTTLE_TIME,\n    { trailing: true }\n  )\n\n  const throttledIndicatorHover = throttle((index: number) => {\n    handleIndicatorHover(index)\n  }, THROTTLE_TIME)\n\n  const isTwoLengthShow = (index: number) => {\n    if (!isItemsTwoLength.value) return true\n    return activeIndex.value <= 1 ? index <= 1 : index > 1\n  }\n\n  function pauseTimer() {\n    if (timer.value) {\n      clearInterval(timer.value)\n      timer.value = null\n    }\n  }\n\n  function startTimer() {\n    if (props.interval <= 0 || !props.autoplay || timer.value) return\n    timer.value = setInterval(() => playSlides(), props.interval)\n  }\n\n  const playSlides = () => {\n    if (activeIndex.value < items.value.length - 1) {\n      activeIndex.value = activeIndex.value + 1\n    } else if (props.loop) {\n      activeIndex.value = 0\n    }\n  }\n\n  function setActiveItem(index: number | string) {\n    if (isString(index)) {\n      const filteredItems = items.value.filter(\n        (item) => item.props.name === index\n      )\n      if (filteredItems.length > 0) {\n        index = items.value.indexOf(filteredItems[0])\n      }\n    }\n    index = Number(index)\n    if (Number.isNaN(index) || index !== Math.floor(index)) {\n      debugWarn(componentName, 'index must be integer.')\n      return\n    }\n    const itemCount = items.value.length\n    const oldIndex = activeIndex.value\n    if (index < 0) {\n      activeIndex.value = props.loop ? itemCount - 1 : 0\n    } else if (index >= itemCount) {\n      activeIndex.value = props.loop ? 0 : itemCount - 1\n    } else {\n      activeIndex.value = index\n    }\n    if (oldIndex === activeIndex.value) {\n      resetItemPosition(oldIndex)\n    }\n    resetTimer()\n  }\n\n  function resetItemPosition(oldIndex?: number) {\n    items.value.forEach((item, index) => {\n      item.translateItem(index, activeIndex.value, oldIndex)\n    })\n  }\n\n  function itemInStage(item: CarouselItemContext, index: number) {\n    const _items = unref(items)\n    const itemCount = _items.length\n    if (itemCount === 0 || !item.states.inStage) return false\n    const nextItemIndex = index + 1\n    const prevItemIndex = index - 1\n    const lastItemIndex = itemCount - 1\n    const isLastItemActive = _items[lastItemIndex].states.active\n    const isFirstItemActive = _items[0].states.active\n    const isNextItemActive = _items[nextItemIndex]?.states?.active\n    const isPrevItemActive = _items[prevItemIndex]?.states?.active\n\n    if ((index === lastItemIndex && isFirstItemActive) || isNextItemActive) {\n      return 'left'\n    } else if ((index === 0 && isLastItemActive) || isPrevItemActive) {\n      return 'right'\n    }\n    return false\n  }\n\n  function handleMouseEnter() {\n    hover.value = true\n    if (props.pauseOnHover) {\n      pauseTimer()\n    }\n  }\n\n  function handleMouseLeave() {\n    hover.value = false\n    startTimer()\n  }\n\n  function handleButtonEnter(arrow: 'left' | 'right') {\n    if (unref(isVertical)) return\n    items.value.forEach((item, index) => {\n      if (arrow === itemInStage(item, index)) {\n        item.states.hover = true\n      }\n    })\n  }\n\n  function handleButtonLeave() {\n    if (unref(isVertical)) return\n    items.value.forEach((item) => {\n      item.states.hover = false\n    })\n  }\n\n  function handleIndicatorClick(index: number) {\n    activeIndex.value = index\n  }\n\n  function handleIndicatorHover(index: number) {\n    if (props.trigger === 'hover' && index !== activeIndex.value) {\n      activeIndex.value = index\n    }\n  }\n\n  function prev() {\n    setActiveItem(activeIndex.value - 1)\n  }\n\n  function next() {\n    setActiveItem(activeIndex.value + 1)\n  }\n\n  function resetTimer() {\n    pauseTimer()\n    if (!props.pauseOnHover) startTimer()\n  }\n\n  function setContainerHeight(height: number) {\n    if (props.height !== 'auto') return\n    containerHeight.value = height\n  }\n\n  function PlaceholderItem() {\n    // fix: https://github.com/element-plus/element-plus/issues/12139\n    const defaultSlots = slots.default?.()\n    if (!defaultSlots) return null\n\n    const flatSlots = flattedChildren(defaultSlots)\n\n    const normalizeSlots = flatSlots.filter((slot) => {\n      return isVNode(slot) && (slot.type as any).name === CAROUSEL_ITEM_NAME\n    })\n\n    if (normalizeSlots?.length === 2 && props.loop && !isCardType.value) {\n      isItemsTwoLength.value = true\n      return normalizeSlots\n    }\n    isItemsTwoLength.value = false\n    return null\n  }\n\n  // watch\n  watch(\n    () => activeIndex.value,\n    (current, prev) => {\n      resetItemPosition(prev)\n      if (isItemsTwoLength.value) {\n        current = current % 2\n        prev = prev % 2\n      }\n      if (prev > -1) {\n        emit(CHANGE_EVENT, current, prev)\n      }\n    }\n  )\n\n  const exposeActiveIndex = computed({\n    get: () => {\n      return isItemsTwoLength.value ? activeIndex.value % 2 : activeIndex.value\n    },\n    set: (value) => (activeIndex.value = value),\n  })\n\n  watch(\n    () => props.autoplay,\n    (autoplay) => {\n      autoplay ? startTimer() : pauseTimer()\n    }\n  )\n  watch(\n    () => props.loop,\n    () => {\n      setActiveItem(activeIndex.value)\n    }\n  )\n\n  watch(\n    () => props.interval,\n    () => {\n      resetTimer()\n    }\n  )\n\n  const resizeObserver = shallowRef<ReturnType<typeof useResizeObserver>>()\n  // lifecycle\n  onMounted(() => {\n    watch(\n      () => items.value,\n      () => {\n        if (items.value.length > 0) setActiveItem(props.initialIndex)\n      },\n      {\n        immediate: true,\n      }\n    )\n\n    resizeObserver.value = useResizeObserver(root.value, () => {\n      resetItemPosition()\n    })\n    startTimer()\n  })\n\n  onBeforeUnmount(() => {\n    pauseTimer()\n    if (root.value && resizeObserver.value) resizeObserver.value.stop()\n  })\n\n  // provide\n  provide(carouselContextKey, {\n    root,\n    isCardType,\n    isVertical,\n    items,\n    loop: props.loop,\n    cardScale: props.cardScale,\n    addItem,\n    removeItem,\n    setActiveItem,\n    setContainerHeight,\n  })\n\n  return {\n    root,\n    activeIndex,\n    exposeActiveIndex,\n    arrowDisplay,\n    hasLabel,\n    hover,\n    isCardType,\n    items,\n    isVertical,\n    containerStyle,\n    isItemsTwoLength,\n    handleButtonEnter,\n    handleButtonLeave,\n    handleIndicatorClick,\n    handleMouseEnter,\n    handleMouseLeave,\n    setActiveItem,\n    prev,\n    next,\n    PlaceholderItem,\n    isTwoLengthShow,\n    ItemsSorter,\n    throttledArrowClick,\n    throttledIndicatorHover,\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}