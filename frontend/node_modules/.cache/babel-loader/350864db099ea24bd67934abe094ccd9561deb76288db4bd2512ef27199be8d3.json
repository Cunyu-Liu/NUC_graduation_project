{"ast":null,"code":"import \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport { defineComponent, computed, shallowRef, ref, onMounted, watch, onBeforeUnmount, openBlock, createElementBlock, normalizeStyle, renderSlot } from 'vue';\nimport { useMutationObserver } from '@vueuse/core';\nimport { watermarkProps } from './watermark.mjs';\nimport { reRendering, getStyleStr, getPixelRatio } from './utils.mjs';\nimport useClips from './useClips.mjs';\nimport _export_sfc from '../../../_virtual/plugin-vue_export-helper.mjs';\nimport { isArray } from '@vue/shared';\nimport { isUndefined } from '../../../utils/types.mjs';\nconst _sfc_main = defineComponent({\n  ...{\n    name: \"ElWatermark\"\n  },\n  __name: \"watermark\",\n  props: watermarkProps,\n  setup(__props) {\n    const style = {\n      position: \"relative\"\n    };\n    const props = __props;\n    const fontGap = computed(() => {\n      var _a, _b;\n      return (_b = (_a = props.font) == null ? void 0 : _a.fontGap) != null ? _b : 3;\n    });\n    const color = computed(() => {\n      var _a, _b;\n      return (_b = (_a = props.font) == null ? void 0 : _a.color) != null ? _b : \"rgba(0,0,0,.15)\";\n    });\n    const fontSize = computed(() => {\n      var _a, _b;\n      return (_b = (_a = props.font) == null ? void 0 : _a.fontSize) != null ? _b : 16;\n    });\n    const fontWeight = computed(() => {\n      var _a, _b;\n      return (_b = (_a = props.font) == null ? void 0 : _a.fontWeight) != null ? _b : \"normal\";\n    });\n    const fontStyle = computed(() => {\n      var _a, _b;\n      return (_b = (_a = props.font) == null ? void 0 : _a.fontStyle) != null ? _b : \"normal\";\n    });\n    const fontFamily = computed(() => {\n      var _a, _b;\n      return (_b = (_a = props.font) == null ? void 0 : _a.fontFamily) != null ? _b : \"sans-serif\";\n    });\n    const textAlign = computed(() => {\n      var _a, _b;\n      return (_b = (_a = props.font) == null ? void 0 : _a.textAlign) != null ? _b : \"center\";\n    });\n    const textBaseline = computed(() => {\n      var _a, _b;\n      return (_b = (_a = props.font) == null ? void 0 : _a.textBaseline) != null ? _b : \"hanging\";\n    });\n    const gapX = computed(() => props.gap[0]);\n    const gapY = computed(() => props.gap[1]);\n    const gapXCenter = computed(() => gapX.value / 2);\n    const gapYCenter = computed(() => gapY.value / 2);\n    const offsetLeft = computed(() => {\n      var _a, _b;\n      return (_b = (_a = props.offset) == null ? void 0 : _a[0]) != null ? _b : gapXCenter.value;\n    });\n    const offsetTop = computed(() => {\n      var _a, _b;\n      return (_b = (_a = props.offset) == null ? void 0 : _a[1]) != null ? _b : gapYCenter.value;\n    });\n    const getMarkStyle = () => {\n      const markStyle = {\n        zIndex: props.zIndex,\n        position: \"absolute\",\n        left: 0,\n        top: 0,\n        width: \"100%\",\n        height: \"100%\",\n        pointerEvents: \"none\",\n        backgroundRepeat: \"repeat\"\n      };\n      let positionLeft = offsetLeft.value - gapXCenter.value;\n      let positionTop = offsetTop.value - gapYCenter.value;\n      if (positionLeft > 0) {\n        markStyle.left = `${positionLeft}px`;\n        markStyle.width = `calc(100% - ${positionLeft}px)`;\n        positionLeft = 0;\n      }\n      if (positionTop > 0) {\n        markStyle.top = `${positionTop}px`;\n        markStyle.height = `calc(100% - ${positionTop}px)`;\n        positionTop = 0;\n      }\n      markStyle.backgroundPosition = `${positionLeft}px ${positionTop}px`;\n      return markStyle;\n    };\n    const containerRef = shallowRef(null);\n    const watermarkRef = shallowRef();\n    const stopObservation = ref(false);\n    const destroyWatermark = () => {\n      if (watermarkRef.value) {\n        watermarkRef.value.remove();\n        watermarkRef.value = void 0;\n      }\n    };\n    const appendWatermark = (base64Url, markWidth) => {\n      var _a;\n      if (containerRef.value && watermarkRef.value) {\n        stopObservation.value = true;\n        watermarkRef.value.setAttribute(\"style\", getStyleStr({\n          ...getMarkStyle(),\n          backgroundImage: `url('${base64Url}')`,\n          backgroundSize: `${Math.floor(markWidth)}px`\n        }));\n        (_a = containerRef.value) == null ? void 0 : _a.append(watermarkRef.value);\n        setTimeout(() => {\n          stopObservation.value = false;\n        });\n      }\n    };\n    const getMarkSize = ctx => {\n      let defaultWidth = 120;\n      let defaultHeight = 64;\n      let space = 0;\n      const {\n        image,\n        content,\n        width,\n        height,\n        rotate\n      } = props;\n      if (!image && ctx.measureText) {\n        ctx.font = `${Number(fontSize.value)}px ${fontFamily.value}`;\n        const contents = isArray(content) ? content : [content];\n        let maxWidth = 0;\n        let maxHeight = 0;\n        contents.forEach(item => {\n          const {\n            width: width2,\n            fontBoundingBoxAscent,\n            fontBoundingBoxDescent,\n            actualBoundingBoxAscent,\n            actualBoundingBoxDescent\n          } = ctx.measureText(item);\n          const height2 = isUndefined(fontBoundingBoxAscent) ? actualBoundingBoxAscent + actualBoundingBoxDescent : fontBoundingBoxAscent + fontBoundingBoxDescent;\n          if (width2 > maxWidth) maxWidth = Math.ceil(width2);\n          if (height2 > maxHeight) maxHeight = Math.ceil(height2);\n        });\n        defaultWidth = maxWidth;\n        defaultHeight = maxHeight * contents.length + (contents.length - 1) * fontGap.value;\n        const angle = Math.PI / 180 * Number(rotate);\n        space = Math.ceil(Math.abs(Math.sin(angle) * defaultHeight) / 2);\n        defaultWidth += space;\n      }\n      return [width != null ? width : defaultWidth, height != null ? height : defaultHeight, space];\n    };\n    const getClips = useClips();\n    const renderWatermark = () => {\n      const canvas = document.createElement(\"canvas\");\n      const ctx = canvas.getContext(\"2d\");\n      const image = props.image;\n      const content = props.content;\n      const rotate = props.rotate;\n      if (ctx) {\n        if (!watermarkRef.value) {\n          watermarkRef.value = document.createElement(\"div\");\n        }\n        const ratio = getPixelRatio();\n        const [markWidth, markHeight, space] = getMarkSize(ctx);\n        const drawCanvas = drawContent => {\n          const [textClips, clipWidth] = getClips(drawContent || \"\", rotate, ratio, markWidth, markHeight, {\n            color: color.value,\n            fontSize: fontSize.value,\n            fontStyle: fontStyle.value,\n            fontWeight: fontWeight.value,\n            fontFamily: fontFamily.value,\n            fontGap: fontGap.value,\n            textAlign: textAlign.value,\n            textBaseline: textBaseline.value\n          }, gapX.value, gapY.value, space);\n          appendWatermark(textClips, clipWidth);\n        };\n        if (image) {\n          const img = new Image();\n          img.onload = () => {\n            drawCanvas(img);\n          };\n          img.onerror = () => {\n            drawCanvas(content);\n          };\n          img.crossOrigin = \"anonymous\";\n          img.referrerPolicy = \"no-referrer\";\n          img.src = image;\n        } else {\n          drawCanvas(content);\n        }\n      }\n    };\n    onMounted(() => {\n      renderWatermark();\n    });\n    watch(() => props, () => {\n      renderWatermark();\n    }, {\n      deep: true,\n      flush: \"post\"\n    });\n    onBeforeUnmount(() => {\n      destroyWatermark();\n    });\n    const onMutate = mutations => {\n      if (stopObservation.value) {\n        return;\n      }\n      mutations.forEach(mutation => {\n        if (reRendering(mutation, watermarkRef.value)) {\n          destroyWatermark();\n          renderWatermark();\n        }\n      });\n    };\n    useMutationObserver(containerRef, onMutate, {\n      attributes: true,\n      subtree: true,\n      childList: true\n    });\n    return (_ctx, _cache) => {\n      return openBlock(), createElementBlock(\"div\", {\n        ref_key: \"containerRef\",\n        ref: containerRef,\n        style: normalizeStyle([style])\n      }, [renderSlot(_ctx.$slots, \"default\")], 4);\n    };\n  }\n});\nvar Watermark = /* @__PURE__ */_export_sfc(_sfc_main, [[\"__file\", \"/home/runner/work/element-plus/element-plus/packages/components/watermark/src/watermark.vue\"]]);\nexport { Watermark as default };","map":{"version":3,"names":["style","position","props","__props","fontGap","computed","_b","_a","font","color","fontSize","fontWeight","fontStyle","fontFamily","textAlign","textBaseline","gapX","gap","gapY","gapXCenter","value","gapYCenter","offsetLeft","offset","offsetTop","getMarkStyle","markStyle","zIndex","left","top","width","height","pointerEvents","backgroundRepeat","positionLeft","positionTop","backgroundPosition","containerRef","shallowRef","watermarkRef","stopObservation","ref","destroyWatermark","remove","appendWatermark","base64Url","markWidth","setAttribute","getStyleStr","backgroundImage","backgroundSize","Math","floor","append","setTimeout","getMarkSize","ctx","defaultWidth","defaultHeight","space","image","content","rotate","measureText","Number","contents","isArray","maxWidth","maxHeight","forEach","item","width2","fontBoundingBoxAscent","fontBoundingBoxDescent","actualBoundingBoxAscent","actualBoundingBoxDescent","height2","isUndefined","ceil","length","angle","PI","abs","sin","getClips","useClips","renderWatermark","canvas","document","createElement","getContext","ratio","getPixelRatio","markHeight","drawCanvas","drawContent","textClips","clipWidth","img","Image","onload","onerror","crossOrigin","referrerPolicy","src","onMounted","watch","deep","flush","onBeforeUnmount","onMutate","mutations","mutation","reRendering","useMutationObserver","attributes","subtree","childList","openBlock","createElementBlock","ref_key","normalizeStyle","renderSlot","_ctx","$slots"],"sources":["../../../../../../packages/components/watermark/src/watermark.vue"],"sourcesContent":["<template>\n  <div ref=\"containerRef\" :style=\"[style]\">\n    <slot />\n  </div>\n</template>\n\n<script lang=\"ts\" setup>\nimport {\n  computed,\n  onBeforeUnmount,\n  onMounted,\n  ref,\n  shallowRef,\n  watch,\n} from 'vue'\nimport { useMutationObserver } from '@vueuse/core'\nimport { isArray, isUndefined } from '@element-plus/utils'\nimport { watermarkProps } from './watermark'\nimport { getPixelRatio, getStyleStr, reRendering } from './utils'\nimport useClips from './useClips'\n\nimport type { WatermarkProps } from './watermark'\nimport type { CSSProperties } from 'vue'\n\ndefineOptions({\n  name: 'ElWatermark',\n})\n\nconst style: CSSProperties = {\n  position: 'relative',\n}\n\nconst props = defineProps(watermarkProps)\nconst fontGap = computed(() => props.font?.fontGap ?? 3)\nconst color = computed(() => props.font?.color ?? 'rgba(0,0,0,.15)')\nconst fontSize = computed(() => props.font?.fontSize ?? 16)\nconst fontWeight = computed(() => props.font?.fontWeight ?? 'normal')\nconst fontStyle = computed(() => props.font?.fontStyle ?? 'normal')\nconst fontFamily = computed(() => props.font?.fontFamily ?? 'sans-serif')\nconst textAlign = computed(() => props.font?.textAlign ?? 'center')\nconst textBaseline = computed(() => props.font?.textBaseline ?? 'hanging')\n\nconst gapX = computed(() => props.gap[0])\nconst gapY = computed(() => props.gap[1])\nconst gapXCenter = computed(() => gapX.value / 2)\nconst gapYCenter = computed(() => gapY.value / 2)\nconst offsetLeft = computed(() => props.offset?.[0] ?? gapXCenter.value)\nconst offsetTop = computed(() => props.offset?.[1] ?? gapYCenter.value)\n\nconst getMarkStyle = () => {\n  const markStyle: CSSProperties = {\n    zIndex: props.zIndex,\n    position: 'absolute',\n    left: 0,\n    top: 0,\n    width: '100%',\n    height: '100%',\n    pointerEvents: 'none',\n    backgroundRepeat: 'repeat',\n  }\n\n  /** Calculate the style of the offset */\n  let positionLeft = offsetLeft.value - gapXCenter.value\n  let positionTop = offsetTop.value - gapYCenter.value\n  if (positionLeft > 0) {\n    markStyle.left = `${positionLeft}px`\n    markStyle.width = `calc(100% - ${positionLeft}px)`\n    positionLeft = 0\n  }\n  if (positionTop > 0) {\n    markStyle.top = `${positionTop}px`\n    markStyle.height = `calc(100% - ${positionTop}px)`\n    positionTop = 0\n  }\n  markStyle.backgroundPosition = `${positionLeft}px ${positionTop}px`\n\n  return markStyle\n}\n\nconst containerRef = shallowRef<HTMLDivElement | null>(null)\nconst watermarkRef = shallowRef<HTMLDivElement>()\nconst stopObservation = ref(false)\n\nconst destroyWatermark = () => {\n  if (watermarkRef.value) {\n    watermarkRef.value.remove()\n    watermarkRef.value = undefined\n  }\n}\nconst appendWatermark = (base64Url: string, markWidth: number) => {\n  if (containerRef.value && watermarkRef.value) {\n    stopObservation.value = true\n    watermarkRef.value.setAttribute(\n      'style',\n      getStyleStr({\n        ...getMarkStyle(),\n        backgroundImage: `url('${base64Url}')`,\n        backgroundSize: `${Math.floor(markWidth)}px`,\n      })\n    )\n    containerRef.value?.append(watermarkRef.value)\n    // Delayed execution\n    setTimeout(() => {\n      stopObservation.value = false\n    })\n  }\n}\n\n/**\n * Get the width and height of the watermark. The default values are as follows\n * Image: [120, 64]; Content: It's calculated by content;\n */\nconst getMarkSize = (ctx: CanvasRenderingContext2D) => {\n  let defaultWidth = 120\n  let defaultHeight = 64\n  let space = 0\n\n  const { image, content, width, height, rotate } = props\n\n  if (!image && ctx.measureText) {\n    ctx.font = `${Number(fontSize.value)}px ${fontFamily.value}`\n\n    const contents = isArray(content) ? content : [content]\n    let maxWidth = 0\n    let maxHeight = 0\n\n    contents.forEach((item) => {\n      const {\n        width,\n        fontBoundingBoxAscent,\n        fontBoundingBoxDescent,\n        actualBoundingBoxAscent,\n        actualBoundingBoxDescent,\n      } = ctx.measureText(item!)\n      // Using `actualBoundingBoxAscent` to be compatible with lower version browsers (eg: Firefox < 116)\n      const height = isUndefined(fontBoundingBoxAscent)\n        ? actualBoundingBoxAscent + actualBoundingBoxDescent\n        : fontBoundingBoxAscent + fontBoundingBoxDescent\n\n      if (width > maxWidth) maxWidth = Math.ceil(width)\n      if (height > maxHeight) maxHeight = Math.ceil(height)\n    })\n\n    defaultWidth = maxWidth\n    defaultHeight =\n      maxHeight * contents.length + (contents.length - 1) * fontGap.value\n\n    const angle = (Math.PI / 180) * Number(rotate)\n    space = Math.ceil(Math.abs(Math.sin(angle) * defaultHeight) / 2)\n\n    defaultWidth += space\n  }\n\n  return [width ?? defaultWidth, height ?? defaultHeight, space] as const\n}\n\nconst getClips = useClips()\n\nconst renderWatermark = () => {\n  const canvas = document.createElement('canvas')\n  const ctx = canvas.getContext('2d')\n  const image = props.image\n  const content = props.content\n  const rotate = props.rotate\n\n  if (ctx) {\n    if (!watermarkRef.value) {\n      watermarkRef.value = document.createElement('div')\n    }\n\n    const ratio = getPixelRatio()\n    const [markWidth, markHeight, space] = getMarkSize(ctx)\n\n    const drawCanvas = (\n      drawContent?: NonNullable<WatermarkProps['content']> | HTMLImageElement\n    ) => {\n      const [textClips, clipWidth] = getClips(\n        drawContent || '',\n        rotate,\n        ratio,\n        markWidth,\n        markHeight,\n        {\n          color: color.value,\n          fontSize: fontSize.value,\n          fontStyle: fontStyle.value,\n          fontWeight: fontWeight.value,\n          fontFamily: fontFamily.value,\n          fontGap: fontGap.value,\n          textAlign: textAlign.value,\n          textBaseline: textBaseline.value,\n        },\n        gapX.value,\n        gapY.value,\n        space\n      )\n\n      appendWatermark(textClips, clipWidth)\n    }\n\n    if (image) {\n      const img = new Image()\n      img.onload = () => {\n        drawCanvas(img)\n      }\n      img.onerror = () => {\n        drawCanvas(content)\n      }\n      img.crossOrigin = 'anonymous'\n      img.referrerPolicy = 'no-referrer'\n      img.src = image\n    } else {\n      drawCanvas(content)\n    }\n  }\n}\n\nonMounted(() => {\n  renderWatermark()\n})\n\nwatch(\n  () => props,\n  () => {\n    renderWatermark()\n  },\n  {\n    deep: true,\n    flush: 'post',\n  }\n)\n\nonBeforeUnmount(() => {\n  destroyWatermark()\n})\n\nconst onMutate = (mutations: MutationRecord[]) => {\n  if (stopObservation.value) {\n    return\n  }\n  mutations.forEach((mutation) => {\n    if (reRendering(mutation, watermarkRef.value)) {\n      destroyWatermark()\n      renderWatermark()\n    }\n  })\n}\n\nuseMutationObserver(containerRef, onMutate, {\n  attributes: true,\n  subtree: true,\n  childList: true,\n})\n</script>\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}