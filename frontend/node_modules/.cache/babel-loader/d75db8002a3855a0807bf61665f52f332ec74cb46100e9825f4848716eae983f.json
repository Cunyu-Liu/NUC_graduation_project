{"ast":null,"code":"import createGrid from '../builders/build-grid.mjs';\nimport { AUTO_ALIGNMENT, CENTERED_ALIGNMENT, END_ALIGNMENT, START_ALIGNMENT, SMART_ALIGNMENT } from '../defaults.mjs';\nimport { isNumber } from '../../../../utils/types.mjs';\nimport { throwError } from '../../../../utils/error.mjs';\nconst SCOPE = \"ElFixedSizeGrid\";\nconst FixedSizeGrid = createGrid({\n  name: \"ElFixedSizeGrid\",\n  getColumnPosition: ({\n    columnWidth\n  }, index) => [columnWidth, index * columnWidth],\n  getRowPosition: ({\n    rowHeight\n  }, index) => [rowHeight, index * rowHeight],\n  getEstimatedTotalHeight: ({\n    totalRow,\n    rowHeight\n  }) => rowHeight * totalRow,\n  getEstimatedTotalWidth: ({\n    totalColumn,\n    columnWidth\n  }) => columnWidth * totalColumn,\n  getColumnOffset: ({\n    totalColumn,\n    columnWidth,\n    width\n  }, columnIndex, alignment, scrollLeft, _, scrollBarWidth) => {\n    width = Number(width);\n    const lastColumnOffset = Math.max(0, totalColumn * columnWidth - width);\n    const maxOffset = Math.min(lastColumnOffset, columnIndex * columnWidth);\n    const minOffset = Math.max(0, columnIndex * columnWidth - width + scrollBarWidth + columnWidth);\n    if (alignment === \"smart\") {\n      if (scrollLeft >= minOffset - width && scrollLeft <= maxOffset + width) {\n        alignment = AUTO_ALIGNMENT;\n      } else {\n        alignment = CENTERED_ALIGNMENT;\n      }\n    }\n    switch (alignment) {\n      case START_ALIGNMENT:\n        return maxOffset;\n      case END_ALIGNMENT:\n        return minOffset;\n      case CENTERED_ALIGNMENT:\n        {\n          const middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n          if (middleOffset < Math.ceil(width / 2)) {\n            return 0;\n          } else if (middleOffset > lastColumnOffset + Math.floor(width / 2)) {\n            return lastColumnOffset;\n          } else {\n            return middleOffset;\n          }\n        }\n      case AUTO_ALIGNMENT:\n      default:\n        if (scrollLeft >= minOffset && scrollLeft <= maxOffset) {\n          return scrollLeft;\n        } else if (minOffset > maxOffset) {\n          return minOffset;\n        } else if (scrollLeft < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n    }\n  },\n  getRowOffset: ({\n    rowHeight,\n    height,\n    totalRow\n  }, rowIndex, align, scrollTop, _, scrollBarWidth) => {\n    height = Number(height);\n    const lastRowOffset = Math.max(0, totalRow * rowHeight - height);\n    const maxOffset = Math.min(lastRowOffset, rowIndex * rowHeight);\n    const minOffset = Math.max(0, rowIndex * rowHeight - height + scrollBarWidth + rowHeight);\n    if (align === SMART_ALIGNMENT) {\n      if (scrollTop >= minOffset - height && scrollTop <= maxOffset + height) {\n        align = AUTO_ALIGNMENT;\n      } else {\n        align = CENTERED_ALIGNMENT;\n      }\n    }\n    switch (align) {\n      case START_ALIGNMENT:\n        return maxOffset;\n      case END_ALIGNMENT:\n        return minOffset;\n      case CENTERED_ALIGNMENT:\n        {\n          const middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n          if (middleOffset < Math.ceil(height / 2)) {\n            return 0;\n          } else if (middleOffset > lastRowOffset + Math.floor(height / 2)) {\n            return lastRowOffset;\n          } else {\n            return middleOffset;\n          }\n        }\n      case AUTO_ALIGNMENT:\n      default:\n        if (scrollTop >= minOffset && scrollTop <= maxOffset) {\n          return scrollTop;\n        } else if (minOffset > maxOffset) {\n          return minOffset;\n        } else if (scrollTop < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n    }\n  },\n  getColumnStartIndexForOffset: ({\n    columnWidth,\n    totalColumn\n  }, scrollLeft) => Math.max(0, Math.min(totalColumn - 1, Math.floor(scrollLeft / columnWidth))),\n  getColumnStopIndexForStartIndex: ({\n    columnWidth,\n    totalColumn,\n    width\n  }, startIndex, scrollLeft) => {\n    const left = startIndex * columnWidth;\n    const visibleColumnsCount = Math.ceil((width + scrollLeft - left) / columnWidth);\n    return Math.max(0, Math.min(totalColumn - 1, startIndex + visibleColumnsCount - 1));\n  },\n  getRowStartIndexForOffset: ({\n    rowHeight,\n    totalRow\n  }, scrollTop) => Math.max(0, Math.min(totalRow - 1, Math.floor(scrollTop / rowHeight))),\n  getRowStopIndexForStartIndex: ({\n    rowHeight,\n    totalRow,\n    height\n  }, startIndex, scrollTop) => {\n    const top = startIndex * rowHeight;\n    const numVisibleRows = Math.ceil((height + scrollTop - top) / rowHeight);\n    return Math.max(0, Math.min(totalRow - 1, startIndex + numVisibleRows - 1));\n  },\n  initCache: () => void 0,\n  clearCache: true,\n  validateProps: ({\n    columnWidth,\n    rowHeight\n  }) => {\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!isNumber(columnWidth)) {\n        throwError(SCOPE, `\n          \"columnWidth\" must be passed as number,\n            instead ${typeof columnWidth} was given.\n        `);\n      }\n      if (!isNumber(rowHeight)) {\n        throwError(SCOPE, `\n          \"columnWidth\" must be passed as number,\n            instead ${typeof rowHeight} was given.\n        `);\n      }\n    }\n  }\n});\nexport { FixedSizeGrid as default };","map":{"version":3,"names":["SCOPE","FixedSizeGrid","createGrid","name","getColumnPosition","columnWidth","index","getRowPosition","rowHeight","getEstimatedTotalHeight","totalRow","getEstimatedTotalWidth","totalColumn","getColumnOffset","width","columnIndex","alignment","scrollLeft","_","scrollBarWidth","Number","lastColumnOffset","Math","max","maxOffset","min","minOffset","AUTO_ALIGNMENT","CENTERED_ALIGNMENT","START_ALIGNMENT","END_ALIGNMENT","middleOffset","round","ceil","floor","getRowOffset","height","rowIndex","align","scrollTop","lastRowOffset","SMART_ALIGNMENT","getColumnStartIndexForOffset","getColumnStopIndexForStartIndex","startIndex","left","visibleColumnsCount","getRowStartIndexForOffset","getRowStopIndexForStartIndex","top","numVisibleRows","initCache","clearCache","validateProps","process","env","NODE_ENV","isNumber","throwError"],"sources":["../../../../../../../packages/components/virtual-list/src/components/fixed-size-grid.ts"],"sourcesContent":["import { isNumber, throwError } from '@element-plus/utils'\nimport createGrid from '../builders/build-grid'\nimport {\n  AUTO_ALIGNMENT,\n  CENTERED_ALIGNMENT,\n  END_ALIGNMENT,\n  SMART_ALIGNMENT,\n  START_ALIGNMENT,\n} from '../defaults'\n\nconst SCOPE = 'ElFixedSizeGrid'\n\nconst FixedSizeGrid = createGrid({\n  name: 'ElFixedSizeGrid',\n  getColumnPosition: ({ columnWidth }, index) => [\n    columnWidth as number,\n    index * (columnWidth as number),\n  ],\n\n  getRowPosition: ({ rowHeight }, index) => [\n    rowHeight as number,\n    index * (rowHeight as number),\n  ],\n\n  getEstimatedTotalHeight: ({ totalRow, rowHeight }) =>\n    (rowHeight as number) * totalRow,\n\n  getEstimatedTotalWidth: ({ totalColumn, columnWidth }) =>\n    (columnWidth as number) * totalColumn,\n\n  getColumnOffset: (\n    { totalColumn, columnWidth, width },\n    columnIndex,\n    alignment,\n    scrollLeft,\n    _,\n    scrollBarWidth\n  ) => {\n    width = Number(width)\n    const lastColumnOffset = Math.max(\n      0,\n      totalColumn * (columnWidth as number) - width\n    )\n    const maxOffset = Math.min(\n      lastColumnOffset,\n      columnIndex * (columnWidth as number)\n    )\n    const minOffset = Math.max(\n      0,\n      columnIndex * (columnWidth as number) -\n        width +\n        scrollBarWidth +\n        (columnWidth as number)\n    )\n\n    if (alignment === 'smart') {\n      if (scrollLeft >= minOffset - width && scrollLeft <= maxOffset + width) {\n        alignment = AUTO_ALIGNMENT\n      } else {\n        alignment = CENTERED_ALIGNMENT\n      }\n    }\n\n    switch (alignment) {\n      case START_ALIGNMENT:\n        return maxOffset\n      case END_ALIGNMENT:\n        return minOffset\n      case CENTERED_ALIGNMENT: {\n        const middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2)\n        if (middleOffset < Math.ceil(width / 2)) {\n          return 0\n        } else if (middleOffset > lastColumnOffset + Math.floor(width / 2)) {\n          return lastColumnOffset\n        } else {\n          return middleOffset\n        }\n      }\n      case AUTO_ALIGNMENT:\n      default:\n        if (scrollLeft >= minOffset && scrollLeft <= maxOffset) {\n          return scrollLeft\n        } else if (minOffset > maxOffset) {\n          return minOffset\n        } else if (scrollLeft < minOffset) {\n          return minOffset\n        } else {\n          return maxOffset\n        }\n    }\n  },\n\n  getRowOffset: (\n    { rowHeight, height, totalRow },\n    rowIndex,\n    align,\n    scrollTop,\n    _,\n    scrollBarWidth\n  ): number => {\n    height = Number(height)\n    const lastRowOffset = Math.max(0, totalRow * (rowHeight as number) - height)\n    const maxOffset = Math.min(lastRowOffset, rowIndex * (rowHeight as number))\n    const minOffset = Math.max(\n      0,\n      rowIndex * (rowHeight as number) -\n        height +\n        scrollBarWidth +\n        (rowHeight as number)\n    )\n\n    if (align === SMART_ALIGNMENT) {\n      if (scrollTop >= minOffset - height && scrollTop <= maxOffset + height) {\n        align = AUTO_ALIGNMENT\n      } else {\n        align = CENTERED_ALIGNMENT\n      }\n    }\n\n    switch (align) {\n      case START_ALIGNMENT:\n        return maxOffset\n      case END_ALIGNMENT:\n        return minOffset\n      case CENTERED_ALIGNMENT: {\n        const middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2)\n        if (middleOffset < Math.ceil(height / 2)) {\n          return 0\n        } else if (middleOffset > lastRowOffset + Math.floor(height / 2)) {\n          return lastRowOffset\n        } else {\n          return middleOffset\n        }\n      }\n      case AUTO_ALIGNMENT:\n      default:\n        if (scrollTop >= minOffset && scrollTop <= maxOffset) {\n          return scrollTop\n        } else if (minOffset > maxOffset) {\n          return minOffset\n        } else if (scrollTop < minOffset) {\n          return minOffset\n        } else {\n          return maxOffset\n        }\n    }\n  },\n\n  getColumnStartIndexForOffset: ({ columnWidth, totalColumn }, scrollLeft) =>\n    Math.max(\n      0,\n      Math.min(\n        totalColumn - 1,\n        Math.floor(scrollLeft / (columnWidth as number))\n      )\n    ),\n\n  getColumnStopIndexForStartIndex: (\n    { columnWidth, totalColumn, width },\n    startIndex: number,\n    scrollLeft: number\n  ): number => {\n    const left = startIndex * (columnWidth as number)\n    const visibleColumnsCount = Math.ceil(\n      ((width as number) + scrollLeft - left) / (columnWidth as number)\n    )\n    return Math.max(\n      0,\n      Math.min(totalColumn - 1, startIndex + visibleColumnsCount - 1)\n    )\n  },\n\n  getRowStartIndexForOffset: (\n    { rowHeight, totalRow },\n    scrollTop: number\n  ): number =>\n    Math.max(\n      0,\n      Math.min(totalRow - 1, Math.floor(scrollTop / (rowHeight as number)))\n    ),\n\n  getRowStopIndexForStartIndex: (\n    { rowHeight, totalRow, height },\n    startIndex: number,\n    scrollTop: number\n  ): number => {\n    const top = startIndex * (rowHeight as number)\n    const numVisibleRows = Math.ceil(\n      ((height as number) + scrollTop - top) / (rowHeight as number)\n    )\n    return Math.max(\n      0,\n      Math.min(\n        totalRow - 1,\n        startIndex + numVisibleRows - 1 // -1 is because stop index is inclusive\n      )\n    )\n  },\n  /**\n   * Fixed size grid does not need this cache\n   * Using any to bypass it, TODO: Using type inference to fix this.\n   */\n  initCache: () => undefined as any,\n\n  clearCache: true,\n\n  validateProps: ({ columnWidth, rowHeight }) => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!isNumber(columnWidth)) {\n        throwError(\n          SCOPE,\n          `\n          \"columnWidth\" must be passed as number,\n            instead ${typeof columnWidth} was given.\n        `\n        )\n      }\n\n      if (!isNumber(rowHeight)) {\n        throwError(\n          SCOPE,\n          `\n          \"columnWidth\" must be passed as number,\n            instead ${typeof rowHeight} was given.\n        `\n        )\n      }\n    }\n  },\n})\n\nexport default FixedSizeGrid\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}