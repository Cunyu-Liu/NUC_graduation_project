{"ast":null,"code":"import createGrid from '../builders/build-grid.mjs';\nimport { DEFAULT_DYNAMIC_LIST_ITEM_SIZE, AUTO_ALIGNMENT, CENTERED_ALIGNMENT, END_ALIGNMENT, START_ALIGNMENT, SMART_ALIGNMENT } from '../defaults.mjs';\nimport { isFunction } from '@vue/shared';\nimport { throwError } from '../../../../utils/error.mjs';\nimport { isNumber, isUndefined } from '../../../../utils/types.mjs';\nconst {\n  max,\n  min,\n  floor\n} = Math;\nconst SCOPE = \"ElDynamicSizeGrid\";\nconst ACCESS_SIZER_KEY_MAP = {\n  column: \"columnWidth\",\n  row: \"rowHeight\"\n};\nconst ACCESS_LAST_VISITED_KEY_MAP = {\n  column: \"lastVisitedColumnIndex\",\n  row: \"lastVisitedRowIndex\"\n};\nconst getItemFromCache = (props, index, gridCache, type) => {\n  const [cachedItems, sizer, lastVisited] = [gridCache[type], props[ACCESS_SIZER_KEY_MAP[type]], gridCache[ACCESS_LAST_VISITED_KEY_MAP[type]]];\n  if (index > lastVisited) {\n    let offset = 0;\n    if (lastVisited >= 0) {\n      const item = cachedItems[lastVisited];\n      offset = item.offset + item.size;\n    }\n    for (let i = lastVisited + 1; i <= index; i++) {\n      const size = sizer(i);\n      cachedItems[i] = {\n        offset,\n        size\n      };\n      offset += size;\n    }\n    gridCache[ACCESS_LAST_VISITED_KEY_MAP[type]] = index;\n  }\n  return cachedItems[index];\n};\nconst bs = (props, gridCache, low, high, offset, type) => {\n  while (low <= high) {\n    const mid = low + floor((high - low) / 2);\n    const currentOffset = getItemFromCache(props, mid, gridCache, type).offset;\n    if (currentOffset === offset) {\n      return mid;\n    } else if (currentOffset < offset) {\n      low = mid + 1;\n    } else {\n      high = mid - 1;\n    }\n  }\n  return max(0, low - 1);\n};\nconst es = (props, gridCache, idx, offset, type) => {\n  const total = type === \"column\" ? props.totalColumn : props.totalRow;\n  let exponent = 1;\n  while (idx < total && getItemFromCache(props, idx, gridCache, type).offset < offset) {\n    idx += exponent;\n    exponent *= 2;\n  }\n  return bs(props, gridCache, floor(idx / 2), min(idx, total - 1), offset, type);\n};\nconst findItem = (props, gridCache, offset, type) => {\n  const [cache, lastVisitedIndex] = [gridCache[type], gridCache[ACCESS_LAST_VISITED_KEY_MAP[type]]];\n  const lastVisitedItemOffset = lastVisitedIndex > 0 ? cache[lastVisitedIndex].offset : 0;\n  if (lastVisitedItemOffset >= offset) {\n    return bs(props, gridCache, 0, lastVisitedIndex, offset, type);\n  }\n  return es(props, gridCache, max(0, lastVisitedIndex), offset, type);\n};\nconst getEstimatedTotalHeight = ({\n  totalRow\n}, {\n  estimatedRowHeight,\n  lastVisitedRowIndex,\n  row\n}) => {\n  let sizeOfVisitedRows = 0;\n  if (lastVisitedRowIndex >= totalRow) {\n    lastVisitedRowIndex = totalRow - 1;\n  }\n  if (lastVisitedRowIndex >= 0) {\n    const item = row[lastVisitedRowIndex];\n    sizeOfVisitedRows = item.offset + item.size;\n  }\n  const unvisitedItems = totalRow - lastVisitedRowIndex - 1;\n  const sizeOfUnvisitedItems = unvisitedItems * estimatedRowHeight;\n  return sizeOfVisitedRows + sizeOfUnvisitedItems;\n};\nconst getEstimatedTotalWidth = ({\n  totalColumn\n}, {\n  column,\n  estimatedColumnWidth,\n  lastVisitedColumnIndex\n}) => {\n  let sizeOfVisitedColumns = 0;\n  if (lastVisitedColumnIndex > totalColumn) {\n    lastVisitedColumnIndex = totalColumn - 1;\n  }\n  if (lastVisitedColumnIndex >= 0) {\n    const item = column[lastVisitedColumnIndex];\n    sizeOfVisitedColumns = item.offset + item.size;\n  }\n  const unvisitedItems = totalColumn - lastVisitedColumnIndex - 1;\n  const sizeOfUnvisitedItems = unvisitedItems * estimatedColumnWidth;\n  return sizeOfVisitedColumns + sizeOfUnvisitedItems;\n};\nconst ACCESS_ESTIMATED_SIZE_KEY_MAP = {\n  column: getEstimatedTotalWidth,\n  row: getEstimatedTotalHeight\n};\nconst getOffset = (props, index, alignment, scrollOffset, cache, type, scrollBarWidth) => {\n  const [size, estimatedSizeAssociates] = [type === \"row\" ? props.height : props.width, ACCESS_ESTIMATED_SIZE_KEY_MAP[type]];\n  const item = getItemFromCache(props, index, cache, type);\n  const estimatedSize = estimatedSizeAssociates(props, cache);\n  const maxOffset = max(0, min(estimatedSize - size, item.offset));\n  const minOffset = max(0, item.offset - size + scrollBarWidth + item.size);\n  if (alignment === SMART_ALIGNMENT) {\n    if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n      alignment = AUTO_ALIGNMENT;\n    } else {\n      alignment = CENTERED_ALIGNMENT;\n    }\n  }\n  switch (alignment) {\n    case START_ALIGNMENT:\n      {\n        return maxOffset;\n      }\n    case END_ALIGNMENT:\n      {\n        return minOffset;\n      }\n    case CENTERED_ALIGNMENT:\n      {\n        return Math.round(minOffset + (maxOffset - minOffset) / 2);\n      }\n    case AUTO_ALIGNMENT:\n    default:\n      {\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (minOffset > maxOffset) {\n          return minOffset;\n        } else if (scrollOffset < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n      }\n  }\n};\nconst DynamicSizeGrid = createGrid({\n  name: \"ElDynamicSizeGrid\",\n  getColumnPosition: (props, idx, cache) => {\n    const item = getItemFromCache(props, idx, cache, \"column\");\n    return [item.size, item.offset];\n  },\n  getRowPosition: (props, idx, cache) => {\n    const item = getItemFromCache(props, idx, cache, \"row\");\n    return [item.size, item.offset];\n  },\n  getColumnOffset: (props, columnIndex, alignment, scrollLeft, cache, scrollBarWidth) => getOffset(props, columnIndex, alignment, scrollLeft, cache, \"column\", scrollBarWidth),\n  getRowOffset: (props, rowIndex, alignment, scrollTop, cache, scrollBarWidth) => getOffset(props, rowIndex, alignment, scrollTop, cache, \"row\", scrollBarWidth),\n  getColumnStartIndexForOffset: (props, scrollLeft, cache) => findItem(props, cache, scrollLeft, \"column\"),\n  getColumnStopIndexForStartIndex: (props, startIndex, scrollLeft, cache) => {\n    const item = getItemFromCache(props, startIndex, cache, \"column\");\n    const maxOffset = scrollLeft + props.width;\n    let offset = item.offset + item.size;\n    let stopIndex = startIndex;\n    while (stopIndex < props.totalColumn - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemFromCache(props, startIndex, cache, \"column\").size;\n    }\n    return stopIndex;\n  },\n  getEstimatedTotalHeight,\n  getEstimatedTotalWidth,\n  getRowStartIndexForOffset: (props, scrollTop, cache) => findItem(props, cache, scrollTop, \"row\"),\n  getRowStopIndexForStartIndex: (props, startIndex, scrollTop, cache) => {\n    const {\n      totalRow,\n      height\n    } = props;\n    const item = getItemFromCache(props, startIndex, cache, \"row\");\n    const maxOffset = scrollTop + height;\n    let offset = item.size + item.offset;\n    let stopIndex = startIndex;\n    while (stopIndex < totalRow - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemFromCache(props, stopIndex, cache, \"row\").size;\n    }\n    return stopIndex;\n  },\n  injectToInstance: (instance, cache) => {\n    const resetAfter = ({\n      columnIndex,\n      rowIndex\n    }, forceUpdate) => {\n      var _a, _b;\n      forceUpdate = isUndefined(forceUpdate) ? true : forceUpdate;\n      if (isNumber(columnIndex)) {\n        cache.value.lastVisitedColumnIndex = Math.min(cache.value.lastVisitedColumnIndex, columnIndex - 1);\n      }\n      if (isNumber(rowIndex)) {\n        cache.value.lastVisitedRowIndex = Math.min(cache.value.lastVisitedRowIndex, rowIndex - 1);\n      }\n      (_a = instance.exposed) == null ? void 0 : _a.getItemStyleCache.value(-1, null, null);\n      if (forceUpdate) (_b = instance.proxy) == null ? void 0 : _b.$forceUpdate();\n    };\n    const resetAfterColumnIndex = (columnIndex, forceUpdate) => {\n      resetAfter({\n        columnIndex\n      }, forceUpdate);\n    };\n    const resetAfterRowIndex = (rowIndex, forceUpdate) => {\n      resetAfter({\n        rowIndex\n      }, forceUpdate);\n    };\n    Object.assign(instance.proxy, {\n      resetAfterColumnIndex,\n      resetAfterRowIndex,\n      resetAfter\n    });\n  },\n  initCache: ({\n    estimatedColumnWidth = DEFAULT_DYNAMIC_LIST_ITEM_SIZE,\n    estimatedRowHeight = DEFAULT_DYNAMIC_LIST_ITEM_SIZE\n  }) => {\n    const cache = {\n      column: {},\n      estimatedColumnWidth,\n      estimatedRowHeight,\n      lastVisitedColumnIndex: -1,\n      lastVisitedRowIndex: -1,\n      row: {}\n    };\n    return cache;\n  },\n  clearCache: false,\n  validateProps: ({\n    columnWidth,\n    rowHeight\n  }) => {\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!isFunction(columnWidth)) {\n        throwError(SCOPE, `\n          \"columnWidth\" must be passed as function,\n            instead ${typeof columnWidth} was given.\n        `);\n      }\n      if (!isFunction(rowHeight)) {\n        throwError(SCOPE, `\n          \"rowHeight\" must be passed as function,\n            instead ${typeof rowHeight} was given.\n        `);\n      }\n    }\n  }\n});\nexport { DynamicSizeGrid as default };","map":{"version":3,"names":["max","min","floor","Math","SCOPE","ACCESS_SIZER_KEY_MAP","column","row","ACCESS_LAST_VISITED_KEY_MAP","getItemFromCache","props","index","gridCache","type","cachedItems","sizer","lastVisited","offset","item","size","i","bs","low","high","mid","currentOffset","es","idx","total","totalColumn","totalRow","exponent","findItem","cache","lastVisitedIndex","lastVisitedItemOffset","getEstimatedTotalHeight","estimatedRowHeight","lastVisitedRowIndex","sizeOfVisitedRows","unvisitedItems","sizeOfUnvisitedItems","getEstimatedTotalWidth","estimatedColumnWidth","lastVisitedColumnIndex","sizeOfVisitedColumns","ACCESS_ESTIMATED_SIZE_KEY_MAP","getOffset","alignment","scrollOffset","scrollBarWidth","estimatedSizeAssociates","height","width","estimatedSize","maxOffset","minOffset","SMART_ALIGNMENT","AUTO_ALIGNMENT","CENTERED_ALIGNMENT","START_ALIGNMENT","END_ALIGNMENT","round","DynamicSizeGrid","createGrid","name","getColumnPosition","getRowPosition","getColumnOffset","columnIndex","scrollLeft","getRowOffset","rowIndex","scrollTop","getColumnStartIndexForOffset","getColumnStopIndexForStartIndex","startIndex","stopIndex","getRowStartIndexForOffset","getRowStopIndexForStartIndex","injectToInstance","instance","resetAfter","forceUpdate","_a","_b","isUndefined","isNumber","value","exposed","getItemStyleCache","proxy","$forceUpdate","resetAfterColumnIndex","resetAfterRowIndex","Object","assign","initCache","DEFAULT_DYNAMIC_LIST_ITEM_SIZE","clearCache","validateProps","columnWidth","rowHeight","process","env","NODE_ENV","isFunction","throwError"],"sources":["../../../../../../../packages/components/virtual-list/src/components/dynamic-size-grid.ts"],"sourcesContent":["import {\n  isFunction,\n  isNumber,\n  isUndefined,\n  throwError,\n} from '@element-plus/utils'\nimport createGrid from '../builders/build-grid'\nimport {\n  AUTO_ALIGNMENT,\n  CENTERED_ALIGNMENT,\n  DEFAULT_DYNAMIC_LIST_ITEM_SIZE,\n  END_ALIGNMENT,\n  SMART_ALIGNMENT,\n  START_ALIGNMENT,\n} from '../defaults'\n\nimport type { GridInstance } from '../builders/build-grid'\nimport type { VirtualizedGridProps } from '../props'\nimport type { Alignment, GridCache, ItemSize } from '../types'\n\nconst { max, min, floor } = Math\nconst SCOPE = 'ElDynamicSizeGrid'\n\ntype Props = VirtualizedGridProps\ntype CacheItemType = 'column' | 'row'\ntype Indices = {\n  columnIndex?: number\n  rowIndex?: number\n}\n\n// generates props access key via type\nconst ACCESS_SIZER_KEY_MAP = {\n  column: 'columnWidth',\n  row: 'rowHeight',\n} as const\n\n// generates cache access key via type\nconst ACCESS_LAST_VISITED_KEY_MAP = {\n  column: 'lastVisitedColumnIndex',\n  row: 'lastVisitedRowIndex',\n} as const\n\nconst getItemFromCache = (\n  props: Props,\n  index: number,\n  gridCache: GridCache,\n  type: CacheItemType\n) => {\n  const [cachedItems, sizer, lastVisited] = [\n    gridCache[type],\n    props[ACCESS_SIZER_KEY_MAP[type]] as ItemSize,\n    gridCache[ACCESS_LAST_VISITED_KEY_MAP[type]],\n  ]\n\n  if (index > lastVisited) {\n    let offset = 0\n    if (lastVisited >= 0) {\n      const item = cachedItems[lastVisited]\n      offset = item.offset + item.size\n    }\n\n    for (let i = lastVisited + 1; i <= index; i++) {\n      const size = sizer(i)\n\n      cachedItems[i] = {\n        offset,\n        size,\n      }\n\n      offset += size\n    }\n\n    gridCache[ACCESS_LAST_VISITED_KEY_MAP[type]] = index\n  }\n\n  return cachedItems[index]\n}\n\nconst bs = (\n  props: Props,\n  gridCache: GridCache,\n  low: number,\n  high: number,\n  offset: number,\n  type: CacheItemType\n) => {\n  while (low <= high) {\n    const mid = low + floor((high - low) / 2)\n    const currentOffset = getItemFromCache(props, mid, gridCache, type).offset\n\n    if (currentOffset === offset) {\n      return mid\n    } else if (currentOffset < offset) {\n      low = mid + 1\n    } else {\n      high = mid - 1\n    }\n  }\n\n  return max(0, low - 1)\n}\n\nconst es = (\n  props: Props,\n  gridCache: GridCache,\n  idx: number,\n  offset: number,\n  type: CacheItemType\n) => {\n  const total = type === 'column' ? props.totalColumn : props.totalRow\n  let exponent = 1\n\n  while (\n    idx < total &&\n    getItemFromCache(props, idx, gridCache, type).offset < offset\n  ) {\n    idx += exponent\n    exponent *= 2\n  }\n\n  return bs(props, gridCache, floor(idx / 2), min(idx, total - 1), offset, type)\n}\n\nconst findItem = (\n  props: Props,\n  gridCache: GridCache,\n  offset: number,\n  type: CacheItemType\n) => {\n  const [cache, lastVisitedIndex] = [\n    gridCache[type],\n    gridCache[ACCESS_LAST_VISITED_KEY_MAP[type]],\n  ]\n\n  const lastVisitedItemOffset =\n    lastVisitedIndex > 0 ? cache[lastVisitedIndex].offset : 0\n\n  if (lastVisitedItemOffset >= offset) {\n    return bs(props, gridCache, 0, lastVisitedIndex, offset, type)\n  }\n\n  return es(props, gridCache, max(0, lastVisitedIndex), offset, type)\n}\n\nconst getEstimatedTotalHeight = (\n  { totalRow }: Props,\n  { estimatedRowHeight, lastVisitedRowIndex, row }: GridCache\n) => {\n  let sizeOfVisitedRows = 0\n\n  if (lastVisitedRowIndex >= totalRow) {\n    lastVisitedRowIndex = totalRow - 1\n  }\n\n  if (lastVisitedRowIndex >= 0) {\n    const item = row[lastVisitedRowIndex]\n    sizeOfVisitedRows = item.offset + item.size\n  }\n\n  const unvisitedItems = totalRow - lastVisitedRowIndex - 1\n  const sizeOfUnvisitedItems = unvisitedItems * estimatedRowHeight\n\n  return sizeOfVisitedRows + sizeOfUnvisitedItems\n}\nconst getEstimatedTotalWidth = (\n  { totalColumn }: Props,\n  { column, estimatedColumnWidth, lastVisitedColumnIndex }: GridCache\n) => {\n  let sizeOfVisitedColumns = 0\n\n  if (lastVisitedColumnIndex > totalColumn) {\n    lastVisitedColumnIndex = totalColumn - 1\n  }\n\n  if (lastVisitedColumnIndex >= 0) {\n    const item = column[lastVisitedColumnIndex]\n    sizeOfVisitedColumns = item.offset + item.size\n  }\n\n  const unvisitedItems = totalColumn - lastVisitedColumnIndex - 1\n  const sizeOfUnvisitedItems = unvisitedItems * estimatedColumnWidth\n\n  return sizeOfVisitedColumns + sizeOfUnvisitedItems\n}\n\nconst ACCESS_ESTIMATED_SIZE_KEY_MAP = {\n  column: getEstimatedTotalWidth,\n  row: getEstimatedTotalHeight,\n}\n\nconst getOffset = (\n  props: Props,\n  index: number,\n  alignment: Alignment,\n  scrollOffset: number,\n  cache: GridCache,\n  type: CacheItemType,\n  scrollBarWidth: number\n) => {\n  const [size, estimatedSizeAssociates] = [\n    type === 'row' ? props.height : props.width,\n    ACCESS_ESTIMATED_SIZE_KEY_MAP[type],\n  ] as [number, (props: Props, cache: GridCache) => number]\n  const item = getItemFromCache(props, index, cache, type)\n\n  const estimatedSize = estimatedSizeAssociates(props, cache)\n\n  const maxOffset = max(0, min(estimatedSize - size, item.offset))\n  const minOffset = max(0, item.offset - size + scrollBarWidth + item.size)\n\n  if (alignment === SMART_ALIGNMENT) {\n    if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n      alignment = AUTO_ALIGNMENT\n    } else {\n      alignment = CENTERED_ALIGNMENT\n    }\n  }\n\n  switch (alignment) {\n    case START_ALIGNMENT: {\n      return maxOffset\n    }\n    case END_ALIGNMENT: {\n      return minOffset\n    }\n    case CENTERED_ALIGNMENT: {\n      return Math.round(minOffset + (maxOffset - minOffset) / 2)\n    }\n    case AUTO_ALIGNMENT:\n    default: {\n      if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n        return scrollOffset\n      } else if (minOffset > maxOffset) {\n        return minOffset\n      } else if (scrollOffset < minOffset) {\n        return minOffset\n      } else {\n        return maxOffset\n      }\n    }\n  }\n}\n\nconst DynamicSizeGrid = createGrid({\n  name: 'ElDynamicSizeGrid',\n  getColumnPosition: (props, idx, cache) => {\n    const item = getItemFromCache(props, idx, cache, 'column')\n    return [item.size, item.offset]\n  },\n\n  getRowPosition: (props, idx, cache) => {\n    const item = getItemFromCache(props, idx, cache, 'row')\n    return [item.size, item.offset]\n  },\n\n  getColumnOffset: (\n    props,\n    columnIndex,\n    alignment,\n    scrollLeft,\n    cache,\n    scrollBarWidth\n  ) =>\n    getOffset(\n      props,\n      columnIndex,\n      alignment,\n      scrollLeft,\n      cache,\n      'column',\n      scrollBarWidth\n    ),\n\n  getRowOffset: (\n    props,\n    rowIndex,\n    alignment,\n    scrollTop,\n    cache,\n    scrollBarWidth: number\n  ) =>\n    getOffset(\n      props,\n      rowIndex,\n      alignment,\n      scrollTop,\n      cache,\n      'row',\n      scrollBarWidth\n    ),\n\n  getColumnStartIndexForOffset: (props, scrollLeft, cache) =>\n    findItem(props, cache, scrollLeft, 'column'),\n\n  getColumnStopIndexForStartIndex: (props, startIndex, scrollLeft, cache) => {\n    const item = getItemFromCache(props, startIndex, cache, 'column')\n\n    const maxOffset = scrollLeft + (props.width as number)\n\n    let offset = item.offset + item.size\n    let stopIndex = startIndex\n    while (stopIndex < props.totalColumn - 1 && offset < maxOffset) {\n      stopIndex++\n      offset += getItemFromCache(props, startIndex, cache, 'column').size\n    }\n    return stopIndex\n  },\n\n  getEstimatedTotalHeight,\n  getEstimatedTotalWidth,\n\n  getRowStartIndexForOffset: (props, scrollTop, cache) =>\n    findItem(props, cache, scrollTop, 'row'),\n\n  getRowStopIndexForStartIndex: (props, startIndex, scrollTop, cache) => {\n    const { totalRow, height } = props\n    const item = getItemFromCache(props, startIndex, cache, 'row')\n    const maxOffset = scrollTop + (height as number)\n\n    let offset = item.size + item.offset\n    let stopIndex = startIndex\n\n    while (stopIndex < totalRow - 1 && offset < maxOffset) {\n      stopIndex++\n      offset += getItemFromCache(props, stopIndex, cache, 'row').size\n    }\n\n    return stopIndex\n  },\n  injectToInstance: (instance, cache) => {\n    const resetAfter = (\n      { columnIndex, rowIndex }: Indices,\n      forceUpdate?: boolean\n    ) => {\n      forceUpdate = isUndefined(forceUpdate) ? true : forceUpdate\n\n      if (isNumber(columnIndex)) {\n        cache.value.lastVisitedColumnIndex = Math.min(\n          cache.value.lastVisitedColumnIndex,\n          columnIndex - 1\n        )\n      }\n\n      if (isNumber(rowIndex)) {\n        cache.value.lastVisitedRowIndex = Math.min(\n          cache.value.lastVisitedRowIndex,\n          rowIndex - 1\n        )\n      }\n\n      instance.exposed?.getItemStyleCache.value(-1, null, null)\n\n      if (forceUpdate) instance.proxy?.$forceUpdate()\n    }\n\n    const resetAfterColumnIndex = (\n      columnIndex: number,\n      forceUpdate: boolean\n    ) => {\n      resetAfter(\n        {\n          columnIndex,\n        },\n        forceUpdate\n      )\n    }\n\n    const resetAfterRowIndex = (rowIndex: number, forceUpdate: boolean) => {\n      resetAfter(\n        {\n          rowIndex,\n        },\n        forceUpdate\n      )\n    }\n\n    Object.assign(instance.proxy!, {\n      resetAfterColumnIndex,\n      resetAfterRowIndex,\n      resetAfter,\n    })\n  },\n  initCache: ({\n    estimatedColumnWidth = DEFAULT_DYNAMIC_LIST_ITEM_SIZE,\n    estimatedRowHeight = DEFAULT_DYNAMIC_LIST_ITEM_SIZE,\n  }) => {\n    const cache = {\n      column: {},\n      estimatedColumnWidth,\n      estimatedRowHeight,\n      lastVisitedColumnIndex: -1,\n      lastVisitedRowIndex: -1,\n      row: {},\n    } as GridCache\n\n    // TODO: expose methods.\n    return cache\n  },\n\n  clearCache: false,\n\n  validateProps: ({ columnWidth, rowHeight }) => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!isFunction(columnWidth)) {\n        throwError(\n          SCOPE,\n          `\n          \"columnWidth\" must be passed as function,\n            instead ${typeof columnWidth} was given.\n        `\n        )\n      }\n\n      if (!isFunction(rowHeight)) {\n        throwError(\n          SCOPE,\n          `\n          \"rowHeight\" must be passed as function,\n            instead ${typeof rowHeight} was given.\n        `\n        )\n      }\n    }\n  },\n})\n\nexport default DynamicSizeGrid\n\nexport type ResetAfterIndex = (idx: number, forceUpdate: boolean) => void\nexport type ResetAfterIndices = (indices: Indices, forceUpdate: boolean) => void\n\nexport type DynamicSizeGridInstance = GridInstance & {\n  resetAfterColumnIndex: ResetAfterIndex\n  resetAfterRowIndex: ResetAfterIndex\n  resetAfter: ResetAfterIndices\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}