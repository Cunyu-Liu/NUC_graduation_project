{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { isClient } from '@vueuse/core';\nimport { easeInOutCubic } from '../easings.mjs';\nimport { isWindow } from '../types.mjs';\nimport { rAF, cAF } from '../raf.mjs';\nimport { getStyle } from './style.mjs';\nimport { isFunction } from '@vue/shared';\nconst isScroll = (el, isVertical) => {\n  if (!isClient) return false;\n  const key = {\n    undefined: \"overflow\",\n    true: \"overflow-y\",\n    false: \"overflow-x\"\n  }[String(isVertical)];\n  const overflow = getStyle(el, key);\n  return [\"scroll\", \"auto\", \"overlay\"].some(s => overflow.includes(s));\n};\nconst getScrollContainer = (el, isVertical) => {\n  if (!isClient) return;\n  let parent = el;\n  while (parent) {\n    if ([window, document, document.documentElement].includes(parent)) return window;\n    if (isScroll(parent, isVertical)) return parent;\n    parent = parent.parentNode;\n  }\n  return parent;\n};\nlet scrollBarWidth;\nconst getScrollBarWidth = namespace => {\n  var _a;\n  if (!isClient) return 0;\n  if (scrollBarWidth !== void 0) return scrollBarWidth;\n  const outer = document.createElement(\"div\");\n  outer.className = `${namespace}-scrollbar__wrap`;\n  outer.style.visibility = \"hidden\";\n  outer.style.width = \"100px\";\n  outer.style.position = \"absolute\";\n  outer.style.top = \"-9999px\";\n  document.body.appendChild(outer);\n  const widthNoScroll = outer.offsetWidth;\n  outer.style.overflow = \"scroll\";\n  const inner = document.createElement(\"div\");\n  inner.style.width = \"100%\";\n  outer.appendChild(inner);\n  const widthWithScroll = inner.offsetWidth;\n  (_a = outer.parentNode) == null ? void 0 : _a.removeChild(outer);\n  scrollBarWidth = widthNoScroll - widthWithScroll;\n  return scrollBarWidth;\n};\nfunction scrollIntoView(container, selected) {\n  if (!isClient) return;\n  if (!selected) {\n    container.scrollTop = 0;\n    return;\n  }\n  const offsetParents = [];\n  let pointer = selected.offsetParent;\n  while (pointer !== null && container !== pointer && container.contains(pointer)) {\n    offsetParents.push(pointer);\n    pointer = pointer.offsetParent;\n  }\n  const top = selected.offsetTop + offsetParents.reduce((prev, curr) => prev + curr.offsetTop, 0);\n  const bottom = top + selected.offsetHeight;\n  const viewRectTop = container.scrollTop;\n  const viewRectBottom = viewRectTop + container.clientHeight;\n  if (top < viewRectTop) {\n    container.scrollTop = top;\n  } else if (bottom > viewRectBottom) {\n    container.scrollTop = bottom - container.clientHeight;\n  }\n}\nfunction animateScrollTo(container, from, to, duration, callback) {\n  const startTime = Date.now();\n  let handle;\n  const scroll = () => {\n    const timestamp = Date.now();\n    const time = timestamp - startTime;\n    const nextScrollTop = easeInOutCubic(time > duration ? duration : time, from, to, duration);\n    if (isWindow(container)) {\n      container.scrollTo(window.pageXOffset, nextScrollTop);\n    } else {\n      container.scrollTop = nextScrollTop;\n    }\n    if (time < duration) {\n      handle = rAF(scroll);\n    } else if (isFunction(callback)) {\n      callback();\n    }\n  };\n  scroll();\n  return () => {\n    handle && cAF(handle);\n  };\n}\nconst getScrollElement = (target, container) => {\n  if (isWindow(container)) {\n    return target.ownerDocument.documentElement;\n  }\n  return container;\n};\nconst getScrollTop = container => {\n  if (isWindow(container)) {\n    return window.scrollY;\n  }\n  return container.scrollTop;\n};\nexport { animateScrollTo, getScrollBarWidth, getScrollContainer, getScrollElement, getScrollTop, isScroll, scrollIntoView };","map":{"version":3,"names":["isScroll","el","isVertical","isClient","key","undefined","true","false","String","overflow","getStyle","some","s","includes","getScrollContainer","parent","window","document","documentElement","parentNode","scrollBarWidth","getScrollBarWidth","namespace","_a","outer","createElement","className","style","visibility","width","position","top","body","appendChild","widthNoScroll","offsetWidth","inner","widthWithScroll","removeChild","scrollIntoView","container","selected","scrollTop","offsetParents","pointer","offsetParent","contains","push","offsetTop","reduce","prev","curr","bottom","offsetHeight","viewRectTop","viewRectBottom","clientHeight","animateScrollTo","from","to","duration","callback","startTime","Date","now","handle","scroll","timestamp","time","nextScrollTop","easeInOutCubic","isWindow","scrollTo","pageXOffset","rAF","isFunction","cAF","getScrollElement","target","ownerDocument","getScrollTop","scrollY"],"sources":["../../../../../packages/utils/dom/scroll.ts"],"sourcesContent":["import { isClient } from '../browser'\nimport { easeInOutCubic } from '../easings'\nimport { isFunction, isWindow } from '../types'\nimport { cAF, rAF } from '../raf'\nimport { getStyle } from './style'\n\nexport const isScroll = (el: HTMLElement, isVertical?: boolean): boolean => {\n  if (!isClient) return false\n\n  const key = (\n    {\n      undefined: 'overflow',\n      true: 'overflow-y',\n      false: 'overflow-x',\n    } as const\n  )[String(isVertical)]!\n  const overflow = getStyle(el, key)\n  return ['scroll', 'auto', 'overlay'].some((s) => overflow.includes(s))\n}\n\nexport const getScrollContainer = (\n  el: HTMLElement,\n  isVertical?: boolean\n): Window | HTMLElement | undefined => {\n  if (!isClient) return\n\n  let parent: HTMLElement = el\n  while (parent) {\n    if ([window, document, document.documentElement].includes(parent))\n      return window\n\n    if (isScroll(parent, isVertical)) return parent\n\n    parent = parent.parentNode as HTMLElement\n  }\n\n  return parent\n}\n\nlet scrollBarWidth: number\nexport const getScrollBarWidth = (namespace: string): number => {\n  if (!isClient) return 0\n  if (scrollBarWidth !== undefined) return scrollBarWidth\n\n  const outer = document.createElement('div')\n  outer.className = `${namespace}-scrollbar__wrap`\n  outer.style.visibility = 'hidden'\n  outer.style.width = '100px'\n  outer.style.position = 'absolute'\n  outer.style.top = '-9999px'\n  document.body.appendChild(outer)\n\n  const widthNoScroll = outer.offsetWidth\n  outer.style.overflow = 'scroll'\n\n  const inner = document.createElement('div')\n  inner.style.width = '100%'\n  outer.appendChild(inner)\n\n  const widthWithScroll = inner.offsetWidth\n  outer.parentNode?.removeChild(outer)\n  scrollBarWidth = widthNoScroll - widthWithScroll\n\n  return scrollBarWidth\n}\n\n/**\n * Scroll with in the container element, positioning the **selected** element at the top\n * of the container\n */\nexport function scrollIntoView(\n  container: HTMLElement,\n  selected: HTMLElement\n): void {\n  if (!isClient) return\n\n  if (!selected) {\n    container.scrollTop = 0\n    return\n  }\n\n  const offsetParents: HTMLElement[] = []\n  let pointer = selected.offsetParent\n  while (\n    pointer !== null &&\n    container !== pointer &&\n    container.contains(pointer)\n  ) {\n    offsetParents.push(pointer as HTMLElement)\n    pointer = (pointer as HTMLElement).offsetParent\n  }\n  const top =\n    selected.offsetTop +\n    offsetParents.reduce((prev, curr) => prev + curr.offsetTop, 0)\n  const bottom = top + selected.offsetHeight\n  const viewRectTop = container.scrollTop\n  const viewRectBottom = viewRectTop + container.clientHeight\n\n  if (top < viewRectTop) {\n    container.scrollTop = top\n  } else if (bottom > viewRectBottom) {\n    container.scrollTop = bottom - container.clientHeight\n  }\n}\n\nexport function animateScrollTo(\n  container: HTMLElement | Window,\n  from: number,\n  to: number,\n  duration: number,\n  callback?: unknown\n) {\n  const startTime = Date.now()\n\n  let handle: number | undefined\n  const scroll = () => {\n    const timestamp = Date.now()\n    const time = timestamp - startTime\n    const nextScrollTop = easeInOutCubic(\n      time > duration ? duration : time,\n      from,\n      to,\n      duration\n    )\n\n    if (isWindow(container)) {\n      container.scrollTo(window.pageXOffset, nextScrollTop)\n    } else {\n      container.scrollTop = nextScrollTop\n    }\n    if (time < duration) {\n      handle = rAF(scroll)\n    } else if (isFunction(callback)) {\n      callback()\n    }\n  }\n\n  scroll()\n\n  return () => {\n    handle && cAF(handle)\n  }\n}\n\nexport const getScrollElement = (\n  target: HTMLElement,\n  container: HTMLElement | Window\n) => {\n  if (isWindow(container)) {\n    return target.ownerDocument.documentElement\n  }\n  return container\n}\n\nexport const getScrollTop = (container: HTMLElement | Window) => {\n  if (isWindow(container)) {\n    return window.scrollY\n  }\n  return container.scrollTop\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}