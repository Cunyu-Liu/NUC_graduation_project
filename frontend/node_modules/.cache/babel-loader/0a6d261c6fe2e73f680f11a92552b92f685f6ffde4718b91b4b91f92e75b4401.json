{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport { getCurrentInstance, shallowRef, ref, computed, unref, nextTick } from 'vue';\nimport { debounce } from 'lodash-unified';\nimport { FixedDir } from '../constants.mjs';\nimport { isNumber } from '../../../../utils/types.mjs';\nconst useRow = (props, {\n  mainTableRef,\n  leftTableRef,\n  rightTableRef,\n  tableInstance,\n  ns,\n  isScrolling\n}) => {\n  const vm = getCurrentInstance();\n  const {\n    emit\n  } = vm;\n  const isResetting = shallowRef(false);\n  const expandedRowKeys = ref(props.defaultExpandedRowKeys || []);\n  const lastRenderedRowIndex = ref(-1);\n  const resetIndex = shallowRef(null);\n  const rowHeights = ref({});\n  const pendingRowHeights = ref({});\n  const leftTableHeights = shallowRef({});\n  const mainTableHeights = shallowRef({});\n  const rightTableHeights = shallowRef({});\n  const isDynamic = computed(() => isNumber(props.estimatedRowHeight));\n  function onRowsRendered(params) {\n    var _a;\n    (_a = props.onRowsRendered) == null ? void 0 : _a.call(props, params);\n    if (params.rowCacheEnd > unref(lastRenderedRowIndex)) {\n      lastRenderedRowIndex.value = params.rowCacheEnd;\n    }\n  }\n  function onRowHovered({\n    hovered,\n    rowKey\n  }) {\n    if (isScrolling.value) {\n      return;\n    }\n    const tableRoot = tableInstance.vnode.el;\n    const rows = tableRoot.querySelectorAll(`[rowkey=\"${String(rowKey)}\"]`);\n    rows.forEach(row => {\n      if (hovered) {\n        row.classList.add(ns.is(\"hovered\"));\n      } else {\n        row.classList.remove(ns.is(\"hovered\"));\n      }\n    });\n  }\n  function onRowExpanded({\n    expanded,\n    rowData,\n    rowIndex,\n    rowKey\n  }) {\n    var _a, _b;\n    const _expandedRowKeys = [...unref(expandedRowKeys)];\n    const currentKeyIndex = _expandedRowKeys.indexOf(rowKey);\n    if (expanded) {\n      if (currentKeyIndex === -1) _expandedRowKeys.push(rowKey);\n    } else {\n      if (currentKeyIndex > -1) _expandedRowKeys.splice(currentKeyIndex, 1);\n    }\n    expandedRowKeys.value = _expandedRowKeys;\n    emit(\"update:expandedRowKeys\", _expandedRowKeys);\n    (_a = props.onRowExpand) == null ? void 0 : _a.call(props, {\n      expanded,\n      rowData,\n      rowIndex,\n      rowKey\n    });\n    (_b = props.onExpandedRowsChange) == null ? void 0 : _b.call(props, _expandedRowKeys);\n    const tableRoot = tableInstance.vnode.el;\n    const hoverRow = tableRoot.querySelector(`.${ns.is(\"hovered\")}[rowkey=\"${String(rowKey)}\"]`);\n    if (hoverRow) {\n      nextTick(() => onRowHovered({\n        hovered: true,\n        rowKey\n      }));\n    }\n  }\n  const flushingRowHeights = debounce(() => {\n    var _a, _b, _c, _d;\n    isResetting.value = true;\n    rowHeights.value = {\n      ...unref(rowHeights),\n      ...unref(pendingRowHeights)\n    };\n    resetAfterIndex(unref(resetIndex), false);\n    pendingRowHeights.value = {};\n    resetIndex.value = null;\n    (_a = mainTableRef.value) == null ? void 0 : _a.forceUpdate();\n    (_b = leftTableRef.value) == null ? void 0 : _b.forceUpdate();\n    (_c = rightTableRef.value) == null ? void 0 : _c.forceUpdate();\n    (_d = vm.proxy) == null ? void 0 : _d.$forceUpdate();\n    isResetting.value = false;\n  }, 0);\n  function resetAfterIndex(index, forceUpdate = false) {\n    if (!unref(isDynamic)) return;\n    [mainTableRef, leftTableRef, rightTableRef].forEach(tableRef => {\n      const table = unref(tableRef);\n      if (table) table.resetAfterRowIndex(index, forceUpdate);\n    });\n  }\n  function resetHeights(rowKey, height, rowIdx) {\n    const resetIdx = unref(resetIndex);\n    if (resetIdx === null) {\n      resetIndex.value = rowIdx;\n    } else {\n      if (resetIdx > rowIdx) {\n        resetIndex.value = rowIdx;\n      }\n    }\n    pendingRowHeights.value[rowKey] = height;\n  }\n  function onRowHeightChange({\n    rowKey,\n    height,\n    rowIndex\n  }, fixedDir) {\n    if (!fixedDir) {\n      mainTableHeights.value[rowKey] = height;\n    } else {\n      if (fixedDir === FixedDir.RIGHT) {\n        rightTableHeights.value[rowKey] = height;\n      } else {\n        leftTableHeights.value[rowKey] = height;\n      }\n    }\n    const maximumHeight = Math.max(...[leftTableHeights, rightTableHeights, mainTableHeights].map(records => records.value[rowKey] || 0));\n    if (unref(rowHeights)[rowKey] !== maximumHeight) {\n      resetHeights(rowKey, maximumHeight, rowIndex);\n      flushingRowHeights();\n    }\n  }\n  return {\n    expandedRowKeys,\n    lastRenderedRowIndex,\n    isDynamic,\n    isResetting,\n    rowHeights,\n    resetAfterIndex,\n    onRowExpanded,\n    onRowHovered,\n    onRowsRendered,\n    onRowHeightChange\n  };\n};\nexport { useRow };","map":{"version":3,"names":["useRow","props","mainTableRef","leftTableRef","rightTableRef","tableInstance","ns","isScrolling","vm","getCurrentInstance","emit","isResetting","shallowRef","expandedRowKeys","ref","defaultExpandedRowKeys","lastRenderedRowIndex","resetIndex","rowHeights","pendingRowHeights","leftTableHeights","mainTableHeights","rightTableHeights","isDynamic","computed","isNumber","estimatedRowHeight","onRowsRendered","params","_a","call","rowCacheEnd","unref","value","onRowHovered","hovered","rowKey","tableRoot","vnode","el","rows","querySelectorAll","String","forEach","row","classList","add","is","remove","onRowExpanded","expanded","rowData","rowIndex","_b","_expandedRowKeys","currentKeyIndex","indexOf","push","splice","onRowExpand","onExpandedRowsChange","hoverRow","querySelector","nextTick","flushingRowHeights","debounce","_c","_d","resetAfterIndex","forceUpdate","proxy","$forceUpdate","index","tableRef","table","resetAfterRowIndex","resetHeights","height","rowIdx","resetIdx","onRowHeightChange","fixedDir","FixedDir","RIGHT","maximumHeight","Math","max","map","records"],"sources":["../../../../../../../packages/components/table-v2/src/composables/use-row.ts"],"sourcesContent":["import {\n  computed,\n  getCurrentInstance,\n  nextTick,\n  ref,\n  shallowRef,\n  unref,\n} from 'vue'\nimport { debounce } from 'lodash-unified'\nimport { isNumber } from '@element-plus/utils'\nimport { FixedDir } from '../constants'\n\nimport type { ComponentInternalInstance, Ref, ShallowRef } from 'vue'\nimport type { TableV2Props } from '../table'\nimport type {\n  RowExpandParams,\n  RowHeightChangedParams,\n  RowHoverParams,\n} from '../row'\nimport type { FixedDirection, KeyType } from '../types'\nimport type { onRowRenderedParams } from '../grid'\nimport type { TableGridInstance } from '../table-grid'\nimport type { UseNamespaceReturn } from '@element-plus/hooks'\n\ntype Heights = Record<KeyType, number>\ntype GridInstanceRef = Ref<TableGridInstance | undefined>\n\ntype UseRowProps = {\n  mainTableRef: GridInstanceRef\n  leftTableRef: GridInstanceRef\n  rightTableRef: GridInstanceRef\n  tableInstance: ComponentInternalInstance\n  ns: UseNamespaceReturn\n  isScrolling: ShallowRef<boolean>\n}\n\nexport const useRow = (\n  props: TableV2Props,\n  {\n    mainTableRef,\n    leftTableRef,\n    rightTableRef,\n    tableInstance,\n    ns,\n    isScrolling,\n  }: UseRowProps\n) => {\n  const vm = getCurrentInstance()!\n  const { emit } = vm\n  const isResetting = shallowRef(false)\n  const expandedRowKeys = ref<KeyType[]>(props.defaultExpandedRowKeys || [])\n  const lastRenderedRowIndex = ref(-1)\n  const resetIndex = shallowRef<number | null>(null)\n  const rowHeights = ref<Heights>({})\n  const pendingRowHeights = ref<Heights>({})\n  const leftTableHeights = shallowRef<Heights>({})\n  const mainTableHeights = shallowRef<Heights>({})\n  const rightTableHeights = shallowRef<Heights>({})\n  const isDynamic = computed(() => isNumber(props.estimatedRowHeight))\n\n  function onRowsRendered(params: onRowRenderedParams) {\n    props.onRowsRendered?.(params)\n\n    if (params.rowCacheEnd > unref(lastRenderedRowIndex)) {\n      lastRenderedRowIndex.value = params.rowCacheEnd\n    }\n  }\n\n  function onRowHovered({ hovered, rowKey }: RowHoverParams) {\n    if (isScrolling.value) {\n      return\n    }\n    const tableRoot = tableInstance!.vnode.el as HTMLElement\n    const rows = tableRoot.querySelectorAll(`[rowkey=\"${String(rowKey)}\"]`)\n    rows.forEach((row) => {\n      if (hovered) {\n        row.classList.add(ns.is('hovered'))\n      } else {\n        row.classList.remove(ns.is('hovered'))\n      }\n    })\n  }\n\n  function onRowExpanded({\n    expanded,\n    rowData,\n    rowIndex,\n    rowKey,\n  }: RowExpandParams) {\n    const _expandedRowKeys = [...unref(expandedRowKeys)]\n    const currentKeyIndex = _expandedRowKeys.indexOf(rowKey)\n    if (expanded) {\n      if (currentKeyIndex === -1) _expandedRowKeys.push(rowKey)\n    } else {\n      if (currentKeyIndex > -1) _expandedRowKeys.splice(currentKeyIndex, 1)\n    }\n    expandedRowKeys.value = _expandedRowKeys\n\n    emit('update:expandedRowKeys', _expandedRowKeys)\n    props.onRowExpand?.({\n      expanded,\n      rowData,\n      rowIndex,\n      rowKey,\n    })\n    // If this is not controlled, then use this to notify changes\n    props.onExpandedRowsChange?.(_expandedRowKeys)\n\n    const tableRoot = tableInstance!.vnode.el as HTMLElement\n    const hoverRow = tableRoot.querySelector(\n      `.${ns.is('hovered')}[rowkey=\"${String(rowKey)}\"]`\n    )\n    if (hoverRow) {\n      nextTick(() => onRowHovered({ hovered: true, rowKey }))\n    }\n  }\n\n  const flushingRowHeights = debounce(() => {\n    isResetting.value = true\n    rowHeights.value = { ...unref(rowHeights), ...unref(pendingRowHeights) }\n    resetAfterIndex(unref(resetIndex)!, false)\n    pendingRowHeights.value = {}\n    // force update\n    resetIndex.value = null\n    mainTableRef.value?.forceUpdate()\n    leftTableRef.value?.forceUpdate()\n    rightTableRef.value?.forceUpdate()\n    vm.proxy?.$forceUpdate()\n    isResetting.value = false\n  }, 0)\n\n  function resetAfterIndex(index: number, forceUpdate = false) {\n    if (!unref(isDynamic)) return\n    ;[mainTableRef, leftTableRef, rightTableRef].forEach((tableRef) => {\n      const table = unref(tableRef)\n      if (table) table.resetAfterRowIndex(index, forceUpdate)\n    })\n  }\n\n  function resetHeights(rowKey: KeyType, height: number, rowIdx: number) {\n    const resetIdx = unref(resetIndex)\n    if (resetIdx === null) {\n      resetIndex.value = rowIdx\n    } else {\n      if (resetIdx > rowIdx) {\n        resetIndex.value = rowIdx\n      }\n    }\n\n    pendingRowHeights.value[rowKey] = height\n  }\n\n  function onRowHeightChange(\n    { rowKey, height, rowIndex }: RowHeightChangedParams,\n    fixedDir: FixedDirection\n  ) {\n    if (!fixedDir) {\n      mainTableHeights.value[rowKey] = height\n    } else {\n      if (fixedDir === FixedDir.RIGHT) {\n        rightTableHeights.value[rowKey] = height\n      } else {\n        leftTableHeights.value[rowKey] = height\n      }\n    }\n\n    const maximumHeight = Math.max(\n      ...[leftTableHeights, rightTableHeights, mainTableHeights].map(\n        (records) => records.value[rowKey] || 0\n      )\n    )\n\n    if (unref(rowHeights)[rowKey] !== maximumHeight) {\n      resetHeights(rowKey, maximumHeight, rowIndex)\n      flushingRowHeights()\n    }\n  }\n\n  return {\n    expandedRowKeys,\n    lastRenderedRowIndex,\n    isDynamic,\n    isResetting,\n    rowHeights,\n\n    resetAfterIndex,\n    onRowExpanded,\n    onRowHovered,\n    onRowsRendered,\n    onRowHeightChange,\n  }\n}\n\nexport type UseRowReturn = ReturnType<typeof useRow>\n"],"mappings":";;;;;;;AAoCa,MAAAA,MAAA,GAASA,CACpBC,KACA;EACEC,YAAA;EACAC,YAAA;EACAC,aAAA;EACAC,aAAA;EACAC,EAAA;EACAC;AACF,CACG;EACH,MAAMC,EAAA,GAAKC,kBAAmB;EACxB;IAAEC;EAAA,CAAS,GAAAF,EAAA;EACX,MAAAG,WAAA,GAAcC,UAAA,CAAW,KAAK;EACpC,MAAMC,eAAkB,GAAAC,GAAA,CAAeb,KAAM,CAAAc,sBAAA,IAA0B,EAAE;EACnE,MAAAC,oBAAA,GAAuBF,GAAA,CAAI,CAAE;EAC7B,MAAAG,UAAA,GAAaL,UAAA,CAA0B,IAAI;EAC3C,MAAAM,UAAA,GAAaJ,GAAa,GAAE;EAC5B,MAAAK,iBAAA,GAAoBL,GAAa,GAAE;EACnC,MAAAM,gBAAA,GAAmBR,UAAoB,GAAE;EACzC,MAAAS,gBAAA,GAAmBT,UAAoB,GAAE;EACzC,MAAAU,iBAAA,GAAoBV,UAAoB,GAAE;EAChD,MAAMW,SAAA,GAAYC,QAAS,OAAMC,QAAS,CAAAxB,KAAA,CAAMyB,kBAAkB,CAAC;EAEnE,SAASC,eAAeC,MAA6B;IA5DvD,IAAAC,EAAA;IA6DI,CAAAA,EAAA,GAAA5B,KAAA,CAAM0B,cAAA,KAAN,IAAuB,YAAAE,EAAA,CAAAC,IAAA,CAAA7B,KAAA,EAAA2B,MAAA;IAEvB,IAAIA,MAAO,CAAAG,WAAA,GAAcC,KAAM,CAAAhB,oBAAoB,CAAG;MACpDA,oBAAA,CAAqBiB,KAAA,GAAQL,MAAO,CAAAG,WAAA;IAAA;EACtC;EAGF,SAASG,YAAaA,CAAA;IAAEC,OAAS;IAAAC;EAAA,CAA0B;IACzD,IAAI7B,WAAA,CAAY0B,KAAO;MACrB;IAAA;IAEI,MAAAI,SAAA,GAAYhC,aAAA,CAAeiC,KAAM,CAAAC,EAAA;IACvC,MAAMC,IAAA,GAAOH,SAAU,CAAAI,gBAAA,CAAiB,YAAYC,MAAA,CAAON,MAAM,CAAK;IACjEI,IAAA,CAAAG,OAAA,CAASC,GAAQ;MACpB,IAAIT,OAAS;QACXS,GAAA,CAAIC,SAAU,CAAAC,GAAA,CAAIxC,EAAG,CAAAyC,EAAA,CAAG,SAAS,CAAC;MAAA,CAC7B;QACLH,GAAA,CAAIC,SAAU,CAAAG,MAAA,CAAO1C,EAAG,CAAAyC,EAAA,CAAG,SAAS,CAAC;MAAA;IACvC,CACD;EAAA;EAGH,SAASE,aAAcA,CAAA;IACrBC,QAAA;IACAC,OAAA;IACAC,QAAA;IACAhB;EAAA,CACkB;IAxFtB,IAAAP,EAAA,EAAAwB,EAAA;IAyFI,MAAMC,gBAAmB,IAAC,GAAGtB,KAAA,CAAMnB,eAAe,CAAC;IAC7C,MAAA0C,eAAA,GAAkBD,gBAAiB,CAAAE,OAAA,CAAQpB,MAAM;IACvD,IAAIc,QAAU;MACZ,IAAIK,eAAoB,SAAID,gBAAA,CAAiBG,IAAA,CAAKrB,MAAM;IAAA,CACnD;MACL,IAAImB,eAAkB,OAAqBD,gBAAA,CAAAI,MAAA,CAAOH,eAAA,EAAiB,CAAC;IAAA;IAEtE1C,eAAA,CAAgBoB,KAAQ,GAAAqB,gBAAA;IAExB5C,IAAA,CAAK,0BAA0B4C,gBAAgB;IAC/C,CAAAzB,EAAA,GAAA5B,KAAA,CAAM0D,WAAA,KAAN,IAAoB,YAAA9B,EAAA,CAAAC,IAAA,CAAA7B,KAAA;MAClBiD,QAAA;MACAC,OAAA;MACAC,QAAA;MACAhB;IAAA,CACF;IAEA,CAAAiB,EAAA,GAAApD,KAAA,CAAM2D,oBAAA,KAAN,IAA6B,YAAAP,EAAA,CAAAvB,IAAA,CAAA7B,KAAA,EAAAqD,gBAAA;IAEvB,MAAAjB,SAAA,GAAYhC,aAAA,CAAeiC,KAAM,CAAAC,EAAA;IACvC,MAAMsB,QAAA,GAAWxB,SAAU,CAAAyB,aAAA,CACzB,IAAIxD,EAAG,CAAAyC,EAAA,CAAG,SAAS,aAAaL,MAAA,CAAON,MAAM,MAC/C;IACA,IAAIyB,QAAU;MACZE,QAAA,CAAS,MAAM7B,YAAa;QAAEC,OAAA,EAAS,IAAM;QAAAC;MAAA,CAAQ,CAAC;IAAA;EACxD;EAGI,MAAA4B,kBAAA,GAAqBC,QAAA,CAAS,MAAM;IArH5C,IAAApC,EAAA,EAAAwB,EAAA,EAAAa,EAAA,EAAAC,EAAA;IAsHIxD,WAAA,CAAYsB,KAAQ;IACTf,UAAA,CAAAe,KAAA,GAAQ;MAAE,GAAGD,KAAA,CAAMd,UAAU,CAAG;MAAA,GAAGc,KAAM,CAAAb,iBAAiB;IAAE;IACvDiD,eAAA,CAAApC,KAAA,CAAMf,UAAU,GAAI,KAAK;IACzCE,iBAAA,CAAkBc,KAAA,GAAQ,EAAC;IAE3BhB,UAAA,CAAWgB,KAAQ;IACnB,CAAAJ,EAAA,GAAA3B,YAAA,CAAa+B,KAAA,KAAb,IAAoB,YAAAJ,EAAA,CAAAwC,WAAA;IACpB,CAAAhB,EAAA,GAAAlD,YAAA,CAAa8B,KAAA,KAAb,IAAoB,YAAAoB,EAAA,CAAAgB,WAAA;IACpB,CAAAH,EAAA,GAAA9D,aAAA,CAAc6B,KAAA,KAAd,IAAqB,YAAAiC,EAAA,CAAAG,WAAA;IACrB,CAAAF,EAAA,GAAA3D,EAAA,CAAG8D,KAAA,KAAH,IAAU,YAAAH,EAAA,CAAAI,YAAA;IACV5D,WAAA,CAAYsB,KAAQ;EAAA,GACnB,CAAC;EAEK,SAAAmC,gBAAgBI,KAAe,EAAAH,WAAA,GAAc,KAAO;IACvD,KAACrC,KAAA,CAAMT,SAAS,GAAG;IACtB,CAACrB,YAAA,EAAcC,YAAc,EAAAC,aAAa,CAAE,CAAAuC,OAAA,CAAS8B,QAAa;MAC3D,MAAAC,KAAA,GAAQ1C,KAAA,CAAMyC,QAAQ;MACxB,IAAAC,KAAA,EAAaA,KAAA,CAAAC,kBAAA,CAAmBH,KAAA,EAAOH,WAAW;IAAA,CACvD;EAAA;EAGM,SAAAO,aAAaxC,MAAiB,EAAAyC,MAAA,EAAgBC,MAAgB;IAC/D,MAAAC,QAAA,GAAW/C,KAAA,CAAMf,UAAU;IACjC,IAAI8D,QAAA,KAAa,IAAM;MACrB9D,UAAA,CAAWgB,KAAQ,GAAA6C,MAAA;IAAA,CACd;MACL,IAAIC,QAAA,GAAWD,MAAQ;QACrB7D,UAAA,CAAWgB,KAAQ,GAAA6C,MAAA;MAAA;IACrB;IAGF3D,iBAAA,CAAkBc,KAAA,CAAMG,MAAU,IAAAyC,MAAA;EAAA;EAGpC,SAASG,kBACP;IAAE5C,MAAA;IAAQyC,MAAQ;IAAAzB;EAAA,GAClB6B,QACA;IACA,IAAI,CAACA,QAAU;MACb5D,gBAAA,CAAiBY,KAAA,CAAMG,MAAU,IAAAyC,MAAA;IAAA,CAC5B;MACD,IAAAI,QAAA,KAAaC,QAAA,CAASC,KAAO;QAC/B7D,iBAAA,CAAkBW,KAAA,CAAMG,MAAU,IAAAyC,MAAA;MAAA,CAC7B;QACLzD,gBAAA,CAAiBa,KAAA,CAAMG,MAAU,IAAAyC,MAAA;MAAA;IACnC;IAGF,MAAMO,aAAA,GAAgBC,IAAK,CAAAC,GAAA,CACzB,GAAG,CAAClE,gBAAkB,EAAAE,iBAAA,EAAmBD,gBAAgB,CAAE,CAAAkE,GAAA,CACxDC,OAAA,IAAYA,OAAQ,CAAAvD,KAAA,CAAMG,MAAW,OACxC,CACF;IAEA,IAAIJ,KAAM,CAAAd,UAAU,CAAE,CAAAkB,MAAA,MAAYgD,aAAe;MAClCR,YAAA,CAAAxC,MAAA,EAAQgD,aAAA,EAAehC,QAAQ;MACzBY,kBAAA;IAAA;EACrB;EAGK;IACLnD,eAAA;IACAG,oBAAA;IACAO,SAAA;IACAZ,WAAA;IACAO,UAAA;IAEAkD,eAAA;IACAnB,aAAA;IACAf,YAAA;IACAP,cAAA;IACAqD;EAAA,CACF;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}