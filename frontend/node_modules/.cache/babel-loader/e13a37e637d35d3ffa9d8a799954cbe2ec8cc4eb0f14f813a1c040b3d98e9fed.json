{"ast":null,"code":"import \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nconst FOCUSABLE_ELEMENT_SELECTORS = `a[href],button:not([disabled]),button:not([hidden]),:not([tabindex=\"-1\"]),input:not([disabled]),input:not([type=\"hidden\"]),select:not([disabled]),textarea:not([disabled])`;\nconst isHTMLElement = e => {\n  if (typeof Element === \"undefined\") return false;\n  return e instanceof Element;\n};\nconst isVisible = element => {\n  if (process.env.NODE_ENV === \"test\") return true;\n  const computed = getComputedStyle(element);\n  return computed.position === \"fixed\" ? false : element.offsetParent !== null;\n};\nconst obtainAllFocusableElements = element => {\n  return Array.from(element.querySelectorAll(FOCUSABLE_ELEMENT_SELECTORS)).filter(item => isFocusable(item) && isVisible(item));\n};\nconst isFocusable = element => {\n  if (element.tabIndex > 0 || element.tabIndex === 0 && element.getAttribute(\"tabIndex\") !== null) {\n    return true;\n  }\n  if (element.tabIndex < 0 || element.hasAttribute(\"disabled\") || element.getAttribute(\"aria-disabled\") === \"true\") {\n    return false;\n  }\n  switch (element.nodeName) {\n    case \"A\":\n      {\n        return !!element.href && element.rel !== \"ignore\";\n      }\n    case \"INPUT\":\n      {\n        return !(element.type === \"hidden\" || element.type === \"file\");\n      }\n    case \"BUTTON\":\n    case \"SELECT\":\n    case \"TEXTAREA\":\n      {\n        return true;\n      }\n    default:\n      {\n        return false;\n      }\n  }\n};\nconst triggerEvent = function (elm, name, ...opts) {\n  let eventName;\n  if (name.includes(\"mouse\") || name.includes(\"click\")) {\n    eventName = \"MouseEvents\";\n  } else if (name.includes(\"key\")) {\n    eventName = \"KeyboardEvent\";\n  } else {\n    eventName = \"HTMLEvents\";\n  }\n  const evt = document.createEvent(eventName);\n  evt.initEvent(name, ...opts);\n  elm.dispatchEvent(evt);\n  return elm;\n};\nconst isLeaf = el => !el.getAttribute(\"aria-owns\");\nconst getSibling = (el, distance, elClass) => {\n  const {\n    parentNode\n  } = el;\n  if (!parentNode) return null;\n  const siblings = parentNode.querySelectorAll(elClass);\n  const index = Array.prototype.indexOf.call(siblings, el);\n  return siblings[index + distance] || null;\n};\nconst focusElement = (el, options) => {\n  if (!el || !el.focus) return;\n  let cleanup = false;\n  if (isHTMLElement(el) && !isFocusable(el) && !el.getAttribute(\"tabindex\")) {\n    el.setAttribute(\"tabindex\", \"-1\");\n    cleanup = true;\n  }\n  el.focus(options);\n  if (isHTMLElement(el) && cleanup) {\n    el.removeAttribute(\"tabindex\");\n  }\n};\nconst focusNode = el => {\n  if (!el) return;\n  focusElement(el);\n  !isLeaf(el) && el.click();\n};\nexport { focusElement, focusNode, getSibling, isFocusable, isLeaf, isVisible, obtainAllFocusableElements, triggerEvent };","map":{"version":3,"names":["FOCUSABLE_ELEMENT_SELECTORS","isHTMLElement","e","Element","isVisible","element","process","env","NODE_ENV","computed","getComputedStyle","position","offsetParent","obtainAllFocusableElements","Array","from","querySelectorAll","filter","item","isFocusable","tabIndex","getAttribute","hasAttribute","nodeName","href","rel","type","triggerEvent","elm","name","opts","eventName","includes","evt","document","createEvent","initEvent","dispatchEvent","isLeaf","el","getSibling","distance","elClass","parentNode","siblings","index","prototype","indexOf","call","focusElement","options","focus","cleanup","setAttribute","removeAttribute","focusNode","click"],"sources":["../../../../../packages/utils/dom/aria.ts"],"sourcesContent":["const FOCUSABLE_ELEMENT_SELECTORS = `a[href],button:not([disabled]),button:not([hidden]),:not([tabindex=\"-1\"]),input:not([disabled]),input:not([type=\"hidden\"]),select:not([disabled]),textarea:not([disabled])`\n\nconst isHTMLElement = (e: unknown): e is Element => {\n  if (typeof Element === 'undefined') return false\n  return e instanceof Element\n}\n\n/**\n * Determine if the testing element is visible on screen no matter if its on the viewport or not\n */\nexport const isVisible = (element: HTMLElement) => {\n  if (process.env.NODE_ENV === 'test') return true\n  const computed = getComputedStyle(element)\n  // element.offsetParent won't work on fix positioned\n  // WARNING: potential issue here, going to need some expert advices on this issue\n  return computed.position === 'fixed' ? false : element.offsetParent !== null\n}\n\nexport const obtainAllFocusableElements = (\n  element: HTMLElement\n): HTMLElement[] => {\n  return Array.from(\n    element.querySelectorAll<HTMLElement>(FOCUSABLE_ELEMENT_SELECTORS)\n  ).filter((item: HTMLElement) => isFocusable(item) && isVisible(item))\n}\n\n/**\n * @desc Determine if target element is focusable\n * @param element {HTMLElement}\n * @returns {Boolean} true if it is focusable\n */\nexport const isFocusable = (element: HTMLElement): boolean => {\n  if (\n    element.tabIndex > 0 ||\n    (element.tabIndex === 0 && element.getAttribute('tabIndex') !== null)\n  ) {\n    return true\n  }\n  if (\n    element.tabIndex < 0 ||\n    element.hasAttribute('disabled') ||\n    element.getAttribute('aria-disabled') === 'true'\n  ) {\n    return false\n  }\n\n  switch (element.nodeName) {\n    case 'A': {\n      // casting current element to Specific HTMLElement in order to be more type precise\n      return (\n        !!(element as HTMLAnchorElement).href &&\n        (element as HTMLAnchorElement).rel !== 'ignore'\n      )\n    }\n    case 'INPUT': {\n      return !(\n        (element as HTMLInputElement).type === 'hidden' ||\n        (element as HTMLInputElement).type === 'file'\n      )\n    }\n    case 'BUTTON':\n    case 'SELECT':\n    case 'TEXTAREA': {\n      return true\n    }\n    default: {\n      return false\n    }\n  }\n}\n\n/**\n * Trigger an event\n * mouseenter, mouseleave, mouseover, keyup, change, click, etc.\n * @param  {HTMLElement} elm\n * @param  {String} name\n * @param  {*} opts\n */\nexport const triggerEvent = function (\n  elm: HTMLElement,\n  name: string,\n  ...opts: Array<boolean>\n): HTMLElement {\n  let eventName: string\n\n  if (name.includes('mouse') || name.includes('click')) {\n    eventName = 'MouseEvents'\n  } else if (name.includes('key')) {\n    eventName = 'KeyboardEvent'\n  } else {\n    eventName = 'HTMLEvents'\n  }\n  const evt = document.createEvent(eventName)\n\n  evt.initEvent(name, ...opts)\n  elm.dispatchEvent(evt)\n  return elm\n}\n\nexport const isLeaf = (el: HTMLElement) => !el.getAttribute('aria-owns')\n\nexport const getSibling = (\n  el: HTMLElement,\n  distance: number,\n  elClass: string\n) => {\n  const { parentNode } = el\n  if (!parentNode) return null\n  const siblings = parentNode.querySelectorAll(elClass)\n  const index = Array.prototype.indexOf.call(siblings, el)\n  return siblings[index + distance] || null\n}\n\nexport const focusElement = (\n  el?: HTMLElement | { focus: () => void } | null,\n  options?: FocusOptions\n) => {\n  if (!el || !el.focus) return\n  let cleanup: boolean = false\n\n  if (isHTMLElement(el) && !isFocusable(el) && !el.getAttribute('tabindex')) {\n    el.setAttribute('tabindex', '-1')\n    cleanup = true\n  }\n\n  el.focus(options)\n\n  if (isHTMLElement(el) && cleanup) {\n    el.removeAttribute('tabindex')\n  }\n}\n\nexport const focusNode = (el: HTMLElement) => {\n  if (!el) return\n  focusElement(el)\n  !isLeaf(el) && el.click()\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}