{"ast":null,"code":"import { defineComponent, computed, ref, reactive, unref, watch, onBeforeUnmount, h, withModifiers } from 'vue';\nimport { HORIZONTAL, ScrollbarDirKey, SCROLLBAR_MIN_SIZE } from '../defaults.mjs';\nimport { virtualizedScrollbarProps } from '../props.mjs';\nimport { renderThumbStyle } from '../utils.mjs';\nimport { BAR_MAP } from '../../../scrollbar/src/util.mjs';\nimport { useNamespace } from '../../../../hooks/use-namespace/index.mjs';\nimport { cAF, rAF } from '../../../../utils/raf.mjs';\nconst ScrollBar = defineComponent({\n  name: \"ElVirtualScrollBar\",\n  props: virtualizedScrollbarProps,\n  emits: [\"scroll\", \"start-move\", \"stop-move\"],\n  setup(props, {\n    emit\n  }) {\n    const GAP = computed(() => props.startGap + props.endGap);\n    const nsVirtualScrollbar = useNamespace(\"virtual-scrollbar\");\n    const nsScrollbar = useNamespace(\"scrollbar\");\n    const trackRef = ref();\n    const thumbRef = ref();\n    let frameHandle = null;\n    let onselectstartStore = null;\n    const state = reactive({\n      isDragging: false,\n      traveled: 0\n    });\n    const bar = computed(() => BAR_MAP[props.layout]);\n    const trackSize = computed(() => props.clientSize - unref(GAP));\n    const trackStyle = computed(() => ({\n      position: \"absolute\",\n      width: `${HORIZONTAL === props.layout ? trackSize.value : props.scrollbarSize}px`,\n      height: `${HORIZONTAL === props.layout ? props.scrollbarSize : trackSize.value}px`,\n      [ScrollbarDirKey[props.layout]]: \"2px\",\n      right: \"2px\",\n      bottom: \"2px\",\n      borderRadius: \"4px\"\n    }));\n    const thumbSize = computed(() => {\n      const ratio = props.ratio;\n      if (ratio >= 100) {\n        return Number.POSITIVE_INFINITY;\n      }\n      if (ratio >= 50) {\n        return ratio * trackSize.value / 100;\n      }\n      const SCROLLBAR_MAX_SIZE = trackSize.value / 3;\n      return Math.floor(Math.min(Math.max(ratio * trackSize.value / 100, SCROLLBAR_MIN_SIZE), SCROLLBAR_MAX_SIZE));\n    });\n    const thumbStyle = computed(() => {\n      if (!Number.isFinite(thumbSize.value)) {\n        return {\n          display: \"none\"\n        };\n      }\n      const thumb = `${thumbSize.value}px`;\n      const style = renderThumbStyle({\n        bar: bar.value,\n        size: thumb,\n        move: state.traveled\n      }, props.layout);\n      return style;\n    });\n    const totalSteps = computed(() => Math.ceil(props.clientSize - thumbSize.value - unref(GAP)));\n    const attachEvents = () => {\n      window.addEventListener(\"mousemove\", onMouseMove);\n      window.addEventListener(\"mouseup\", onMouseUp);\n      const thumbEl = unref(thumbRef);\n      if (!thumbEl) return;\n      onselectstartStore = document.onselectstart;\n      document.onselectstart = () => false;\n      thumbEl.addEventListener(\"touchmove\", onMouseMove, {\n        passive: true\n      });\n      thumbEl.addEventListener(\"touchend\", onMouseUp);\n    };\n    const detachEvents = () => {\n      window.removeEventListener(\"mousemove\", onMouseMove);\n      window.removeEventListener(\"mouseup\", onMouseUp);\n      document.onselectstart = onselectstartStore;\n      onselectstartStore = null;\n      const thumbEl = unref(thumbRef);\n      if (!thumbEl) return;\n      thumbEl.removeEventListener(\"touchmove\", onMouseMove);\n      thumbEl.removeEventListener(\"touchend\", onMouseUp);\n    };\n    const onThumbMouseDown = e => {\n      e.stopImmediatePropagation();\n      if (e.ctrlKey || [1, 2].includes(e.button)) {\n        return;\n      }\n      state.isDragging = true;\n      state[bar.value.axis] = e.currentTarget[bar.value.offset] - (e[bar.value.client] - e.currentTarget.getBoundingClientRect()[bar.value.direction]);\n      emit(\"start-move\");\n      attachEvents();\n    };\n    const onMouseUp = () => {\n      state.isDragging = false;\n      state[bar.value.axis] = 0;\n      emit(\"stop-move\");\n      detachEvents();\n    };\n    const onMouseMove = e => {\n      const {\n        isDragging\n      } = state;\n      if (!isDragging) return;\n      if (!thumbRef.value || !trackRef.value) return;\n      const prevPage = state[bar.value.axis];\n      if (!prevPage) return;\n      cAF(frameHandle);\n      const offset = (trackRef.value.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]) * -1;\n      const thumbClickPosition = thumbRef.value[bar.value.offset] - prevPage;\n      const distance = offset - thumbClickPosition;\n      frameHandle = rAF(() => {\n        state.traveled = Math.max(0, Math.min(distance, totalSteps.value));\n        emit(\"scroll\", distance, totalSteps.value);\n      });\n    };\n    const clickTrackHandler = e => {\n      const offset = Math.abs(e.target.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]);\n      const thumbHalf = thumbRef.value[bar.value.offset] / 2;\n      const distance = offset - thumbHalf;\n      state.traveled = Math.max(0, Math.min(distance, totalSteps.value));\n      emit(\"scroll\", distance, totalSteps.value);\n    };\n    watch(() => props.scrollFrom, v => {\n      if (state.isDragging) return;\n      state.traveled = Math.ceil(v * totalSteps.value);\n    });\n    onBeforeUnmount(() => {\n      detachEvents();\n    });\n    return () => {\n      return h(\"div\", {\n        role: \"presentation\",\n        ref: trackRef,\n        class: [nsVirtualScrollbar.b(), props.class, (props.alwaysOn || state.isDragging) && \"always-on\"],\n        style: trackStyle.value,\n        onMousedown: withModifiers(clickTrackHandler, [\"stop\", \"prevent\"]),\n        onTouchstartPrevent: onThumbMouseDown\n      }, h(\"div\", {\n        ref: thumbRef,\n        class: nsScrollbar.e(\"thumb\"),\n        style: thumbStyle.value,\n        onMousedown: onThumbMouseDown\n      }, []));\n    };\n  }\n});\nexport { ScrollBar as default };","map":{"version":3,"names":["ScrollBar","defineComponent","name","props","virtualizedScrollbarProps","emits","setup","emit","GAP","computed","startGap","endGap","nsVirtualScrollbar","useNamespace","nsScrollbar","trackRef","ref","thumbRef","frameHandle","onselectstartStore","state","reactive","isDragging","traveled","bar","BAR_MAP","layout","trackSize","clientSize","unref","trackStyle","position","width","HORIZONTAL","value","scrollbarSize","height","ScrollbarDirKey","right","bottom","borderRadius","thumbSize","ratio","Number","POSITIVE_INFINITY","SCROLLBAR_MAX_SIZE","Math","floor","min","max","SCROLLBAR_MIN_SIZE","thumbStyle","isFinite","display","thumb","style","renderThumbStyle","size","move","totalSteps","ceil","attachEvents","window","addEventListener","onMouseMove","onMouseUp","thumbEl","document","onselectstart","passive","detachEvents","removeEventListener","onThumbMouseDown","e","stopImmediatePropagation","ctrlKey","includes","button","axis","currentTarget","offset","client","getBoundingClientRect","direction","prevPage","cAF","thumbClickPosition","distance","rAF","clickTrackHandler","abs","target","thumbHalf","watch","scrollFrom","v","onBeforeUnmount","h","role","class","b","alwaysOn","onMousedown","withModifiers","onTouchstartPrevent"],"sources":["../../../../../../../packages/components/virtual-list/src/components/scrollbar.ts"],"sourcesContent":["import {\n  computed,\n  defineComponent,\n  h,\n  onBeforeUnmount,\n  reactive,\n  ref,\n  unref,\n  watch,\n  withModifiers,\n} from 'vue'\nimport { BAR_MAP } from '@element-plus/components/scrollbar'\nimport { cAF, rAF } from '@element-plus/utils'\nimport { useNamespace } from '@element-plus/hooks'\nimport { HORIZONTAL, SCROLLBAR_MIN_SIZE, ScrollbarDirKey } from '../defaults'\nimport { virtualizedScrollbarProps } from '../props'\nimport { renderThumbStyle } from '../utils'\n\nimport type { CSSProperties } from 'vue'\n\ninterface ScrollState {\n  isDragging: boolean\n  traveled: number\n  [key: string]: unknown\n}\n\nconst ScrollBar = defineComponent({\n  name: 'ElVirtualScrollBar',\n  props: virtualizedScrollbarProps,\n  emits: ['scroll', 'start-move', 'stop-move'],\n  setup(props, { emit }) {\n    const GAP = computed(() => props.startGap + props.endGap) // top 2 + bottom 2 | left 2 + right 2\n\n    const nsVirtualScrollbar = useNamespace('virtual-scrollbar')\n    const nsScrollbar = useNamespace('scrollbar')\n    // DOM refs\n    const trackRef = ref<HTMLElement>()\n    const thumbRef = ref<HTMLElement>()\n\n    // local variables\n    let frameHandle: null | number = null\n    let onselectstartStore: null | typeof document.onselectstart = null\n\n    // data\n    const state = reactive<ScrollState>({\n      isDragging: false,\n      traveled: 0,\n    })\n\n    const bar = computed(() => BAR_MAP[props.layout])\n\n    const trackSize = computed(() => props.clientSize! - unref(GAP))\n\n    const trackStyle = computed<CSSProperties>(() => ({\n      position: 'absolute',\n      width: `${\n        HORIZONTAL === props.layout ? trackSize.value : props.scrollbarSize\n      }px`,\n      height: `${\n        HORIZONTAL === props.layout ? props.scrollbarSize : trackSize.value\n      }px`,\n      [ScrollbarDirKey[props.layout]]: '2px',\n      right: '2px',\n      bottom: '2px',\n      borderRadius: '4px',\n    }))\n\n    const thumbSize = computed(() => {\n      const ratio = props.ratio!\n      if (ratio >= 100) {\n        return Number.POSITIVE_INFINITY\n      }\n\n      if (ratio >= 50) {\n        return (ratio * trackSize.value) / 100\n      }\n\n      const SCROLLBAR_MAX_SIZE = trackSize.value / 3\n      return Math.floor(\n        Math.min(\n          Math.max((ratio * trackSize.value) / 100, SCROLLBAR_MIN_SIZE),\n          SCROLLBAR_MAX_SIZE\n        )\n      )\n    })\n\n    const thumbStyle = computed<CSSProperties>(() => {\n      if (!Number.isFinite(thumbSize.value)) {\n        return {\n          display: 'none',\n        }\n      }\n\n      const thumb = `${thumbSize.value}px`\n\n      const style = renderThumbStyle(\n        {\n          bar: bar.value,\n          size: thumb,\n          move: state.traveled,\n        },\n        props.layout\n      )\n\n      return style\n    })\n\n    const totalSteps = computed(() =>\n      Math.ceil(props.clientSize! - thumbSize.value - unref(GAP))\n    )\n\n    const attachEvents = () => {\n      window.addEventListener('mousemove', onMouseMove)\n      window.addEventListener('mouseup', onMouseUp)\n\n      const thumbEl = unref(thumbRef)\n\n      if (!thumbEl) return\n\n      onselectstartStore = document.onselectstart\n      document.onselectstart = () => false\n\n      thumbEl.addEventListener('touchmove', onMouseMove, { passive: true })\n      thumbEl.addEventListener('touchend', onMouseUp)\n    }\n\n    const detachEvents = () => {\n      window.removeEventListener('mousemove', onMouseMove)\n      window.removeEventListener('mouseup', onMouseUp)\n\n      document.onselectstart = onselectstartStore\n      onselectstartStore = null\n\n      const thumbEl = unref(thumbRef)\n      if (!thumbEl) return\n\n      thumbEl.removeEventListener('touchmove', onMouseMove)\n      thumbEl.removeEventListener('touchend', onMouseUp)\n    }\n\n    const onThumbMouseDown = (e: Event | KeyboardEvent | MouseEvent) => {\n      e.stopImmediatePropagation()\n      if (\n        (e as KeyboardEvent).ctrlKey ||\n        [1, 2].includes((e as MouseEvent).button)\n      ) {\n        return\n      }\n\n      state.isDragging = true\n      state[bar.value.axis] =\n        (e.currentTarget as HTMLElement)[bar.value.offset] -\n        ((e as MouseEvent)[bar.value.client] -\n          (e.currentTarget as HTMLElement).getBoundingClientRect()[\n            bar.value.direction\n          ])\n\n      emit('start-move')\n      attachEvents()\n    }\n\n    const onMouseUp = () => {\n      state.isDragging = false\n      state[bar.value.axis] = 0\n      emit('stop-move')\n      detachEvents()\n    }\n\n    const onMouseMove = (e: MouseEvent | TouchEvent) => {\n      const { isDragging } = state\n      if (!isDragging) return\n      if (!thumbRef.value || !trackRef.value) return\n\n      const prevPage = state[bar.value.axis]\n      if (!prevPage) return\n\n      cAF(frameHandle!)\n      // using the current track's offset top/left - the current pointer's clientY/clientX\n      // to get the relative position of the pointer to the track.\n      const offset =\n        (trackRef.value.getBoundingClientRect()[bar.value.direction] -\n          (e as MouseEvent)[bar.value.client]) *\n        -1\n\n      // find where the thumb was clicked on.\n      const thumbClickPosition =\n        thumbRef.value[bar.value.offset] - (prevPage as number)\n      /**\n       *  +--------------+                                   +--------------+\n       *  |              -  <--------- thumb.offsetTop       |              |\n       *  |             |+|             <--+                 |              |\n       *  |              -                 |                 |              |\n       *  |   Content    |                 |                 |              |\n       *  |              |                 |                 |              |\n       *  |              |                 |                 |              |\n       *  |              |                 |                 |              -\n       *  |              |                 +-->              |             |+|\n       *  |              |                                   |              -\n       *  +--------------+                                   +--------------+\n       */\n\n      // using the current position - prev position to\n\n      const distance = offset - thumbClickPosition\n      // get how many steps in total.\n      // gap of 2 on top, 2 on bottom, in total 4.\n      // using totalSteps รท totalSize getting each step's size * distance to get the new\n      // scroll offset to scrollTo\n      frameHandle = rAF(() => {\n        state.traveled = Math.max(0, Math.min(distance, totalSteps.value))\n        emit('scroll', distance, totalSteps.value)\n      })\n    }\n\n    const clickTrackHandler = (e: MouseEvent) => {\n      const offset = Math.abs(\n        (e.target as HTMLElement).getBoundingClientRect()[bar.value.direction] -\n          e[bar.value.client]\n      )\n      const thumbHalf = thumbRef.value![bar.value.offset] / 2\n      const distance = offset - thumbHalf\n\n      state.traveled = Math.max(0, Math.min(distance, totalSteps.value))\n      emit('scroll', distance, totalSteps.value)\n    }\n\n    watch(\n      () => props.scrollFrom,\n      (v) => {\n        if (state.isDragging) return\n        /**\n         *  this is simply mapping the current scrollbar offset\n         *\n         *  formula 1:\n         *    v = scrollOffset / (estimatedTotalSize - clientSize)\n         *    traveled = v * (clientSize - thumbSize - GAP) --> v * totalSteps\n         *\n         *  formula 2:\n         *    traveled = (v * clientSize) / (clientSize / totalSteps) --> (v * clientSize) * (totalSteps / clientSize) --> v * totalSteps\n         */\n        state.traveled = Math.ceil(v! * totalSteps.value)\n      }\n    )\n\n    onBeforeUnmount(() => {\n      detachEvents()\n    })\n\n    return () => {\n      return h(\n        'div',\n        {\n          role: 'presentation',\n          ref: trackRef,\n          class: [\n            nsVirtualScrollbar.b(),\n            props.class,\n            (props.alwaysOn || state.isDragging) && 'always-on',\n          ],\n          style: trackStyle.value,\n          onMousedown: withModifiers(clickTrackHandler as (e: Event) => void, [\n            'stop',\n            'prevent',\n          ]),\n          onTouchstartPrevent: onThumbMouseDown,\n        },\n        h(\n          'div',\n          {\n            ref: thumbRef,\n            class: nsScrollbar.e('thumb'),\n            style: thumbStyle.value,\n            onMousedown: onThumbMouseDown,\n          },\n          []\n        )\n      )\n    }\n  },\n})\n\nexport default ScrollBar\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}