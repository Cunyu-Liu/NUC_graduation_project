{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.json.stringify.js\";\nimport \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\nimport { warn } from 'vue';\nimport { fromPairs } from 'lodash-unified';\nimport { isObject, hasOwn } from '@vue/shared';\nconst epPropKey = \"__epPropKey\";\nconst definePropType = val => val;\nconst isEpProp = val => isObject(val) && !!val[epPropKey];\nconst buildProp = (prop, key) => {\n  if (!isObject(prop) || isEpProp(prop)) return prop;\n  const {\n    values,\n    required,\n    default: defaultValue,\n    type,\n    validator\n  } = prop;\n  const _validator = values || validator ? val => {\n    let valid = false;\n    let allowedValues = [];\n    if (values) {\n      allowedValues = Array.from(values);\n      if (hasOwn(prop, \"default\")) {\n        allowedValues.push(defaultValue);\n      }\n      valid || (valid = allowedValues.includes(val));\n    }\n    if (validator) valid || (valid = validator(val));\n    if (!valid && allowedValues.length > 0) {\n      const allowValuesText = [...new Set(allowedValues)].map(value => JSON.stringify(value)).join(\", \");\n      warn(`Invalid prop: validation failed${key ? ` for prop \"${key}\"` : \"\"}. Expected one of [${allowValuesText}], got value ${JSON.stringify(val)}.`);\n    }\n    return valid;\n  } : void 0;\n  const epProp = {\n    type,\n    required: !!required,\n    validator: _validator,\n    [epPropKey]: true\n  };\n  if (hasOwn(prop, \"default\")) epProp.default = defaultValue;\n  return epProp;\n};\nconst buildProps = props => fromPairs(Object.entries(props).map(([key, option]) => [key, buildProp(option, key)]));\nexport { buildProp, buildProps, definePropType, epPropKey, isEpProp };","map":{"version":3,"names":["epPropKey","definePropType","val","isEpProp","isObject","buildProp","prop","key","values","required","default","defaultValue","type","validator","_validator","valid","allowedValues","Array","from","hasOwn","push","includes","length","allowValuesText","Set","map","value","JSON","stringify","join","warn","epProp","buildProps","props","fromPairs","Object","entries","option"],"sources":["../../../../../../packages/utils/vue/props/runtime.ts"],"sourcesContent":["import { warn } from 'vue'\nimport { fromPairs } from 'lodash-unified'\nimport { isObject } from '../../types'\nimport { hasOwn } from '../../objects'\n\nimport type { PropType } from 'vue'\nimport type {\n  EpProp,\n  EpPropConvert,\n  EpPropFinalized,\n  EpPropInput,\n  EpPropMergeType,\n  IfEpProp,\n  IfNativePropType,\n  NativePropType,\n} from './types'\n\nexport const epPropKey = '__epPropKey'\n\nexport const definePropType = <T>(val: any): PropType<T> => val\n\nexport const isEpProp = (val: unknown): val is EpProp<any, any, any> =>\n  isObject(val) && !!(val as any)[epPropKey]\n\n/**\n * @description Build prop. It can better optimize prop types\n * @description 生成 prop，能更好地优化类型\n * @example\n  // limited options\n  // the type will be PropType<'light' | 'dark'>\n  buildProp({\n    type: String,\n    values: ['light', 'dark'],\n  } as const)\n  * @example\n  // limited options and other types\n  // the type will be PropType<'small' | 'large' | number>\n  buildProp({\n    type: [String, Number],\n    values: ['small', 'large'],\n    validator: (val: unknown): val is number => typeof val === 'number',\n  } as const)\n  @link see more: https://github.com/element-plus/element-plus/pull/3341\n */\nexport const buildProp = <\n  Type = never,\n  Value = never,\n  Validator = never,\n  Default extends EpPropMergeType<Type, Value, Validator> = never,\n  Required extends boolean = false,\n>(\n  prop: EpPropInput<Type, Value, Validator, Default, Required>,\n  key?: string\n): EpPropFinalized<Type, Value, Validator, Default, Required> => {\n  // filter native prop type and nested prop, e.g `null`, `undefined` (from `buildProps`)\n  if (!isObject(prop) || isEpProp(prop)) return prop as any\n\n  const { values, required, default: defaultValue, type, validator } = prop\n\n  const _validator =\n    values || validator\n      ? (val: unknown) => {\n          let valid = false\n          let allowedValues: unknown[] = []\n\n          if (values) {\n            allowedValues = Array.from(values)\n            if (hasOwn(prop, 'default')) {\n              allowedValues.push(defaultValue)\n            }\n            valid ||= allowedValues.includes(val)\n          }\n          if (validator) valid ||= validator(val)\n\n          if (!valid && allowedValues.length > 0) {\n            const allowValuesText = [...new Set(allowedValues)]\n              .map((value) => JSON.stringify(value))\n              .join(', ')\n            warn(\n              `Invalid prop: validation failed${\n                key ? ` for prop \"${key}\"` : ''\n              }. Expected one of [${allowValuesText}], got value ${JSON.stringify(\n                val\n              )}.`\n            )\n          }\n          return valid\n        }\n      : undefined\n\n  const epProp: any = {\n    type,\n    required: !!required,\n    validator: _validator,\n    [epPropKey]: true,\n  }\n  if (hasOwn(prop, 'default')) epProp.default = defaultValue\n  return epProp\n}\n\nexport const buildProps = <\n  Props extends Record<\n    string,\n    | { [epPropKey]: true }\n    | NativePropType\n    | EpPropInput<any, any, any, any, any>\n  >,\n>(\n  props: Props\n): {\n  [K in keyof Props]: IfEpProp<\n    Props[K],\n    Props[K],\n    IfNativePropType<Props[K], Props[K], EpPropConvert<Props[K]>>\n  >\n} =>\n  fromPairs(\n    Object.entries(props).map(([key, option]) => [\n      key,\n      buildProp(option as any, key),\n    ])\n  ) as any\n"],"mappings":";;;;;;;;;;;;;;AAiBO,MAAMA,SAAY;AAEZ,MAAAC,cAAA,GAAqBC,GAA0B,IAAAA,GAAA;AAE/C,MAAAC,QAAA,GAAYD,GACvB,IAAAE,QAAA,CAASF,GAAG,CAAK,KAAC,CAAEA,GAAY,CAAAF,SAAA;AAsBrB,MAAAK,SAAA,GAAYA,CAOvBC,IAAA,EACAC,GAC+D;EAE/D,IAAI,CAACH,QAAA,CAASE,IAAI,KAAKH,QAAA,CAASG,IAAI,GAAU,OAAAA,IAAA;EAE9C,MAAM;IAAEE,MAAQ;IAAAC,QAAA;IAAUC,OAAA,EAASC,YAAc;IAAAC,IAAA;IAAMC;EAAA,CAAc,GAAAP,IAAA;EAErE,MAAMQ,UACJ,GAAAN,MAAA,IAAUK,SACN,GAACX,GAAiB;IAChB,IAAIa,KAAQ;IACZ,IAAIC,aAAA,GAA2B,EAAC;IAEhC,IAAIR,MAAQ;MACMQ,aAAA,GAAAC,KAAA,CAAMC,IAAA,CAAKV,MAAM;MAC7B,IAAAW,MAAA,CAAOb,IAAM,WAAS,CAAG;QAC3BU,aAAA,CAAcI,IAAA,CAAKT,YAAY;MAAA;MAEvBI,KAAA,KAAAA,KAAA,GAAAC,aAAA,CAAcK,QAAA,CAASnB,GAAG;IAAA;IAElC,IAAAW,SAAA,EAAWE,KAAA,KAAAA,KAAA,GAAUF,SAAA,CAAUX,GAAG;IAEtC,IAAI,CAACa,KAAA,IAASC,aAAc,CAAAM,MAAA,GAAS,CAAG;MACtC,MAAMC,eAAA,GAAkB,CAAC,GAAG,IAAIC,GAAA,CAAIR,aAAa,CAAC,EAC/CS,GAAI,CAACC,KAAA,IAAUC,IAAK,CAAAC,SAAA,CAAUF,KAAK,CAAC,EACpCG,IAAA,CAAK,IAAI;MACZC,IAAA,CACE,kCACEvB,GAAM,iBAAcA,GAAS,8BACTgB,eAAA,gBAA+BI,IAAK,CAAAC,SAAA,CACxD1B,GAAA,CACF,IACF;IAAA;IAEK,OAAAa,KAAA;EAAA,CAET;EAEN,MAAMgB,MAAc;IAClBnB,IAAA;IACAH,QAAA,EAAU,CAAC,CAACA,QAAA;IACZI,SAAW,EAAAC,UAAA;IACX,CAACd,SAAY;EAAA,CACf;EACI,IAAAmB,MAAA,CAAOb,IAAA,EAAM,SAAS,GAAGyB,MAAA,CAAOrB,OAAU,GAAAC,YAAA;EACvC,OAAAoB,MAAA;AACT;AAEa,MAAAC,UAAA,GAQXC,KAQA,IAAAC,SAAA,CACEC,MAAA,CAAOC,OAAA,CAAQH,KAAK,EAAER,GAAA,CAAI,CAAC,CAAClB,GAAK,EAAA8B,MAAM,CAAM,MAC3C9B,GAAA,EACAF,SAAA,CAAUgC,MAAA,EAAe9B,GAAG,EAC7B,CACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}