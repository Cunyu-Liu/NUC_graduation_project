{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport { ref, computed, watch } from 'vue';\nimport { isPct, getPct, isPx, getPx } from './useSize.mjs';\nimport { NOOP } from '@vue/shared';\nfunction useResize(panels, containerSize, pxSizes, lazy) {\n  const ptg2px = ptg => ptg * containerSize.value || 0;\n  function getLimitSize(str, defaultLimit) {\n    if (isPct(str)) {\n      return ptg2px(getPct(str));\n    } else if (isPx(str)) {\n      return getPx(str);\n    }\n    return str != null ? str : defaultLimit;\n  }\n  const lazyOffset = ref(0);\n  const movingIndex = ref(null);\n  let cachePxSizes = [];\n  let updatePanelSizes = NOOP;\n  const limitSizes = computed(() => panels.value.map(item => [item.min, item.max]));\n  watch(lazy, () => {\n    if (lazyOffset.value) {\n      const mouseup = new MouseEvent(\"mouseup\", {\n        bubbles: true\n      });\n      window.dispatchEvent(mouseup);\n    }\n  });\n  const onMoveStart = index => {\n    lazyOffset.value = 0;\n    movingIndex.value = {\n      index,\n      confirmed: false\n    };\n    cachePxSizes = pxSizes.value;\n  };\n  const onMoving = (index, offset) => {\n    var _a, _b;\n    let confirmedIndex = null;\n    if ((!movingIndex.value || !movingIndex.value.confirmed) && offset !== 0) {\n      if (offset > 0) {\n        confirmedIndex = index;\n        movingIndex.value = {\n          index,\n          confirmed: true\n        };\n      } else {\n        for (let i = index; i >= 0; i -= 1) {\n          if (cachePxSizes[i] > 0) {\n            confirmedIndex = i;\n            movingIndex.value = {\n              index: i,\n              confirmed: true\n            };\n            break;\n          }\n        }\n      }\n    }\n    const mergedIndex = (_b = confirmedIndex != null ? confirmedIndex : (_a = movingIndex.value) == null ? void 0 : _a.index) != null ? _b : index;\n    const numSizes = [...cachePxSizes];\n    const nextIndex = mergedIndex + 1;\n    const startMinSize = getLimitSize(limitSizes.value[mergedIndex][0], 0);\n    const endMinSize = getLimitSize(limitSizes.value[nextIndex][0], 0);\n    const startMaxSize = getLimitSize(limitSizes.value[mergedIndex][1], containerSize.value || 0);\n    const endMaxSize = getLimitSize(limitSizes.value[nextIndex][1], containerSize.value || 0);\n    let mergedOffset = offset;\n    if (numSizes[mergedIndex] + mergedOffset < startMinSize) {\n      mergedOffset = startMinSize - numSizes[mergedIndex];\n    }\n    if (numSizes[nextIndex] - mergedOffset < endMinSize) {\n      mergedOffset = numSizes[nextIndex] - endMinSize;\n    }\n    if (numSizes[mergedIndex] + mergedOffset > startMaxSize) {\n      mergedOffset = startMaxSize - numSizes[mergedIndex];\n    }\n    if (numSizes[nextIndex] - mergedOffset > endMaxSize) {\n      mergedOffset = numSizes[nextIndex] - endMaxSize;\n    }\n    numSizes[mergedIndex] += mergedOffset;\n    numSizes[nextIndex] -= mergedOffset;\n    lazyOffset.value = mergedOffset;\n    updatePanelSizes = () => {\n      panels.value.forEach((panel, index2) => {\n        panel.size = numSizes[index2];\n      });\n      updatePanelSizes = NOOP;\n    };\n    if (!lazy.value) {\n      updatePanelSizes();\n    }\n  };\n  const onMoveEnd = () => {\n    if (lazy.value) {\n      updatePanelSizes();\n    }\n    lazyOffset.value = 0;\n    movingIndex.value = null;\n    cachePxSizes = [];\n  };\n  const cacheCollapsedSize = [];\n  const onCollapse = (index, type) => {\n    if (!cacheCollapsedSize.length) {\n      cacheCollapsedSize.push(...pxSizes.value);\n    }\n    const currentSizes = pxSizes.value;\n    const currentIndex = type === \"start\" ? index : index + 1;\n    const targetIndex = type === \"start\" ? index + 1 : index;\n    const currentSize = currentSizes[currentIndex];\n    const targetSize = currentSizes[targetIndex];\n    if (currentSize !== 0 && targetSize !== 0) {\n      currentSizes[currentIndex] = 0;\n      currentSizes[targetIndex] += currentSize;\n      cacheCollapsedSize[index] = currentSize;\n    } else {\n      const totalSize = currentSize + targetSize;\n      const targetCacheCollapsedSize = cacheCollapsedSize[index];\n      const currentCacheCollapsedSize = totalSize - targetCacheCollapsedSize;\n      currentSizes[targetIndex] = targetCacheCollapsedSize;\n      currentSizes[currentIndex] = currentCacheCollapsedSize;\n    }\n    panels.value.forEach((panel, index2) => {\n      panel.size = currentSizes[index2];\n    });\n  };\n  return {\n    lazyOffset,\n    onMoveStart,\n    onMoving,\n    onMoveEnd,\n    movingIndex,\n    onCollapse\n  };\n}\nexport { useResize };","map":{"version":3,"names":["useResize","panels","containerSize","pxSizes","lazy","ptg2px","ptg","value","getLimitSize","str","defaultLimit","isPct","getPct","isPx","getPx","lazyOffset","ref","movingIndex","cachePxSizes","updatePanelSizes","NOOP","limitSizes","computed","map","item","min","max","watch","mouseup","MouseEvent","bubbles","window","dispatchEvent","onMoveStart","index","confirmed","onMoving","offset","_a","_b","confirmedIndex","i","mergedIndex","numSizes","nextIndex","startMinSize","endMinSize","startMaxSize","endMaxSize","mergedOffset","forEach","panel","index2","size","onMoveEnd","cacheCollapsedSize","onCollapse","type","length","push","currentSizes","currentIndex","targetIndex","currentSize","targetSize","totalSize","targetCacheCollapsedSize","currentCacheCollapsedSize"],"sources":["../../../../../../../packages/components/splitter/src/hooks/useResize.ts"],"sourcesContent":["import { computed, ref, watch } from 'vue'\nimport { getPct, getPx, isPct, isPx } from './useSize'\nimport { NOOP } from '@element-plus/utils'\n\nimport type { ComputedRef, Ref } from 'vue'\nimport type { PanelItemState } from '../type'\n\nexport function useResize(\n  panels: Ref<PanelItemState[]>,\n  containerSize: ComputedRef<number>,\n  pxSizes: ComputedRef<number[]>,\n  lazy: Ref<boolean>\n) {\n  const ptg2px = (ptg: number) => ptg * containerSize.value || 0\n\n  function getLimitSize(\n    str: string | number | undefined,\n    defaultLimit: number\n  ) {\n    if (isPct(str)) {\n      return ptg2px(getPct(str))\n    } else if (isPx(str)) {\n      return getPx(str)\n    }\n    return str ?? defaultLimit\n  }\n\n  const lazyOffset = ref(0)\n  const movingIndex = ref<{\n    index: number\n    confirmed: boolean\n  } | null>(null)\n\n  let cachePxSizes: number[] = []\n  let updatePanelSizes = NOOP\n\n  const limitSizes = computed(() =>\n    panels.value.map((item) => [item.min, item.max])\n  )\n\n  watch(lazy, () => {\n    if (lazyOffset.value) {\n      const mouseup = new MouseEvent('mouseup', { bubbles: true })\n      window.dispatchEvent(mouseup)\n    }\n  })\n\n  const onMoveStart = (index: number) => {\n    lazyOffset.value = 0\n    movingIndex.value = { index, confirmed: false }\n    cachePxSizes = pxSizes.value\n  }\n\n  const onMoving = (index: number, offset: number) => {\n    let confirmedIndex: number | null = null\n\n    // When overlapping, find the nearest draggable index\n    if ((!movingIndex.value || !movingIndex.value.confirmed) && offset !== 0) {\n      if (offset > 0) {\n        confirmedIndex = index\n        movingIndex.value = { index, confirmed: true }\n      } else {\n        for (let i = index; i >= 0; i -= 1) {\n          if (cachePxSizes[i]! > 0) {\n            confirmedIndex = i\n            movingIndex.value = { index: i, confirmed: true }\n            break\n          }\n        }\n      }\n    }\n    const mergedIndex = confirmedIndex ?? movingIndex.value?.index ?? index\n\n    const numSizes = [...cachePxSizes]\n    const nextIndex = mergedIndex + 1\n\n    // Handle the maximum and minimum edge cases\n    const startMinSize = getLimitSize(limitSizes.value[mergedIndex]![0], 0)\n    const endMinSize = getLimitSize(limitSizes.value[nextIndex]![0], 0)\n    const startMaxSize = getLimitSize(\n      limitSizes.value[mergedIndex]![1],\n      containerSize.value || 0\n    )\n    const endMaxSize = getLimitSize(\n      limitSizes.value[nextIndex]![1],\n      containerSize.value || 0\n    )\n\n    let mergedOffset = offset\n\n    if (numSizes[mergedIndex]! + mergedOffset < startMinSize) {\n      mergedOffset = startMinSize - numSizes[mergedIndex]!\n    }\n    if (numSizes[nextIndex]! - mergedOffset < endMinSize) {\n      mergedOffset = numSizes[nextIndex]! - endMinSize\n    }\n    if (numSizes[mergedIndex]! + mergedOffset > startMaxSize) {\n      mergedOffset = startMaxSize - numSizes[mergedIndex]!\n    }\n    if (numSizes[nextIndex]! - mergedOffset > endMaxSize) {\n      mergedOffset = numSizes[nextIndex]! - endMaxSize\n    }\n\n    numSizes[mergedIndex]! += mergedOffset\n    numSizes[nextIndex]! -= mergedOffset\n    lazyOffset.value = mergedOffset\n\n    updatePanelSizes = () => {\n      panels.value.forEach((panel, index) => {\n        panel.size = numSizes[index]\n      })\n      updatePanelSizes = NOOP\n    }\n\n    if (!lazy.value) {\n      updatePanelSizes()\n    }\n  }\n\n  const onMoveEnd = () => {\n    if (lazy.value) {\n      updatePanelSizes()\n    }\n\n    lazyOffset.value = 0\n    movingIndex.value = null\n    cachePxSizes = []\n  }\n\n  const cacheCollapsedSize: number[] = []\n  const onCollapse = (index: number, type: 'start' | 'end') => {\n    if (!cacheCollapsedSize.length) {\n      cacheCollapsedSize.push(...pxSizes.value)\n    }\n\n    const currentSizes = pxSizes.value\n\n    const currentIndex = type === 'start' ? index : index + 1\n    const targetIndex = type === 'start' ? index + 1 : index\n\n    const currentSize = currentSizes[currentIndex]\n    const targetSize = currentSizes[targetIndex]\n\n    if (currentSize !== 0 && targetSize !== 0) {\n      currentSizes[currentIndex] = 0\n      currentSizes[targetIndex]! += currentSize\n      cacheCollapsedSize[index] = currentSize\n    } else {\n      const totalSize = currentSize + targetSize\n\n      const targetCacheCollapsedSize = cacheCollapsedSize[index]\n      const currentCacheCollapsedSize = totalSize - targetCacheCollapsedSize\n\n      currentSizes[targetIndex] = targetCacheCollapsedSize\n      currentSizes[currentIndex] = currentCacheCollapsedSize\n    }\n\n    panels.value.forEach((panel, index) => {\n      panel.size = currentSizes[index]\n    })\n  }\n\n  return {\n    lazyOffset,\n    onMoveStart,\n    onMoving,\n    onMoveEnd,\n    movingIndex,\n    onCollapse,\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}