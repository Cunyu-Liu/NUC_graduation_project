{"ast":null,"code":"import \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.iterator.reduce.js\";\nimport { computed, ref, watch } from 'vue';\nimport { isString } from '@vue/shared';\nfunction getPct(str) {\n  return Number(str.slice(0, -1)) / 100;\n}\nfunction getPx(str) {\n  return Number(str.slice(0, -2));\n}\nfunction isPct(itemSize) {\n  return isString(itemSize) && itemSize.endsWith(\"%\");\n}\nfunction isPx(itemSize) {\n  return isString(itemSize) && itemSize.endsWith(\"px\");\n}\nfunction useSize(panels, containerSize) {\n  const propSizes = computed(() => panels.value.map(i => i.size));\n  const panelCounts = computed(() => panels.value.length);\n  const percentSizes = ref([]);\n  watch([propSizes, panelCounts, containerSize], () => {\n    var _a;\n    let ptgList = [];\n    let emptyCount = 0;\n    for (let i = 0; i < panelCounts.value; i += 1) {\n      const itemSize = (_a = panels.value[i]) == null ? void 0 : _a.size;\n      if (isPct(itemSize)) {\n        ptgList[i] = getPct(itemSize);\n      } else if (isPx(itemSize)) {\n        ptgList[i] = getPx(itemSize) / containerSize.value;\n      } else if (itemSize || itemSize === 0) {\n        const num = Number(itemSize);\n        if (!Number.isNaN(num)) {\n          ptgList[i] = num / containerSize.value;\n        }\n      } else {\n        emptyCount += 1;\n        ptgList[i] = void 0;\n      }\n    }\n    const totalPtg = ptgList.reduce((acc, ptg) => acc + (ptg || 0), 0);\n    if (totalPtg > 1 || !emptyCount) {\n      const scale = 1 / totalPtg;\n      ptgList = ptgList.map(ptg => ptg === void 0 ? 0 : ptg * scale);\n    } else {\n      const avgRest = (1 - totalPtg) / emptyCount;\n      ptgList = ptgList.map(ptg => ptg === void 0 ? avgRest : ptg);\n    }\n    percentSizes.value = ptgList;\n  });\n  const ptg2px = ptg => ptg * containerSize.value;\n  const pxSizes = computed(() => percentSizes.value.map(ptg2px));\n  return {\n    percentSizes,\n    pxSizes\n  };\n}\nexport { getPct, getPx, isPct, isPx, useSize };","map":{"version":3,"names":["getPct","str","Number","slice","getPx","isPct","itemSize","isString","endsWith","isPx","useSize","panels","containerSize","propSizes","computed","value","map","i","size","panelCounts","length","percentSizes","ref","watch","_a","ptgList","emptyCount","num","isNaN","totalPtg","reduce","acc","ptg","scale","avgRest","ptg2px","pxSizes"],"sources":["../../../../../../../packages/components/splitter/src/hooks/useSize.ts"],"sourcesContent":["import { computed, ref, watch } from 'vue'\nimport { isString } from '@element-plus/utils'\n\nimport type { ComputedRef, Ref } from 'vue'\nimport type { PanelItemState } from '../type'\n\nexport function getPct(str: string) {\n  return Number(str.slice(0, -1)) / 100\n}\n\nexport function getPx(str: string) {\n  return Number(str.slice(0, -2))\n}\n\nexport function isPct(\n  itemSize: string | number | undefined\n): itemSize is string {\n  return isString(itemSize) && itemSize.endsWith('%')\n}\n\nexport function isPx(\n  itemSize: string | number | undefined\n): itemSize is string {\n  return isString(itemSize) && itemSize.endsWith('px')\n}\n\nexport function useSize(\n  panels: Ref<PanelItemState[]>,\n  containerSize: ComputedRef<number>\n) {\n  const propSizes = computed(() => panels.value.map((i) => i.size))\n\n  const panelCounts = computed(() => panels.value.length)\n\n  const percentSizes = ref<number[]>([])\n\n  watch([propSizes, panelCounts, containerSize], () => {\n    let ptgList: (number | undefined)[] = []\n    let emptyCount = 0\n\n    // Convert the passed props size to a percentage\n    for (let i = 0; i < panelCounts.value; i += 1) {\n      const itemSize = panels.value[i]?.size\n\n      if (isPct(itemSize)) {\n        ptgList[i] = getPct(itemSize)\n      } else if (isPx(itemSize)) {\n        ptgList[i] = getPx(itemSize) / containerSize.value\n      } else if (itemSize || itemSize === 0) {\n        const num = Number(itemSize)\n\n        if (!Number.isNaN(num)) {\n          ptgList[i] = num / containerSize.value\n        }\n      } else {\n        emptyCount += 1\n        ptgList[i] = undefined\n      }\n    }\n\n    const totalPtg = ptgList.reduce<number>((acc, ptg) => acc + (ptg || 0), 0)\n\n    if (totalPtg > 1 || !emptyCount) {\n      // If it is greater than 1, the scaling ratio\n      const scale = 1 / totalPtg\n      ptgList = ptgList.map((ptg) => (ptg === undefined ? 0 : ptg * scale))\n    } else {\n      // If it is less than 1, the filling ratio\n      const avgRest = (1 - totalPtg) / emptyCount\n      ptgList = ptgList.map((ptg) => (ptg === undefined ? avgRest : ptg))\n    }\n\n    percentSizes.value = ptgList as number[]\n  })\n\n  const ptg2px = (ptg: number) => ptg * containerSize.value\n  const pxSizes = computed(() => percentSizes.value.map(ptg2px))\n\n  return { percentSizes, pxSizes }\n}\n"],"mappings":";;;;;AAMO,SAASA,OAAOC,GAAa;EAClC,OAAOC,MAAA,CAAOD,GAAI,CAAAE,KAAA,CAAM,CAAG,IAAE,CAAC,CAAI;AACpC;AAEO,SAASC,MAAMH,GAAa;EACjC,OAAOC,MAAO,CAAAD,GAAA,CAAIE,KAAM,IAAG,EAAE,CAAC;AAChC;AAEO,SAASE,MACdC,QACoB;EACpB,OAAOC,QAAS,CAAAD,QAAQ,CAAK,IAAAA,QAAA,CAASE,QAAA,CAAS,GAAG;AACpD;AAEO,SAASC,KACdH,QACoB;EACpB,OAAOC,QAAS,CAAAD,QAAQ,CAAK,IAAAA,QAAA,CAASE,QAAA,CAAS,IAAI;AACrD;AAEgB,SAAAE,QACdC,MAAA,EACAC,aACA;EACM,MAAAC,SAAA,GAAYC,QAAS,OAAMH,MAAO,CAAAI,KAAA,CAAMC,GAAA,CAAKC,CAAA,IAAMA,CAAE,CAAAC,IAAI,CAAC;EAEhE,MAAMC,WAAc,GAAAL,QAAA,CAAS,MAAMH,MAAA,CAAOI,KAAA,CAAMK,MAAM;EAEhD,MAAAC,YAAA,GAAeC,GAAc,GAAE;EAErCC,KAAA,CAAM,CAACV,SAAA,EAAWM,WAAa,EAAAP,aAAa,GAAG,MAAM;IApCvD,IAAAY,EAAA;IAqCI,IAAIC,OAAA,GAAkC,EAAC;IACvC,IAAIC,UAAa;IAGjB,SAAST,CAAA,GAAI,CAAG,EAAAA,CAAA,GAAIE,WAAY,CAAAJ,KAAA,EAAOE,CAAA,IAAK,CAAG;MAC7C,MAAMX,QAAW,IAAAkB,EAAA,GAAAb,MAAA,CAAOI,KAAM,CAAAE,CAAA,MAAb,IAAiB,YAAAO,EAAA,CAAAN,IAAA;MAE9B,IAAAb,KAAA,CAAMC,QAAQ,CAAG;QACXmB,OAAA,CAAAR,CAAA,IAAKjB,MAAA,CAAOM,QAAQ;MAAA,CAC9B,UAAWG,IAAK,CAAAH,QAAQ,CAAG;QACzBmB,OAAA,CAAQR,CAAK,IAAAb,KAAA,CAAME,QAAQ,IAAIM,aAAc,CAAAG,KAAA;MAAA,CAC/C,UAAWT,QAAY,IAAAA,QAAA,KAAa,CAAG;QAC/B,MAAAqB,GAAA,GAAMzB,MAAA,CAAOI,QAAQ;QAE3B,IAAI,CAACJ,MAAA,CAAO0B,KAAM,CAAAD,GAAG,CAAG;UACdF,OAAA,CAAAR,CAAA,IAAKU,GAAA,GAAMf,aAAc,CAAAG,KAAA;QAAA;MACnC,CACK;QACSW,UAAA;QACdD,OAAA,CAAQR,CAAK;MAAA;IACf;IAGI,MAAAY,QAAA,GAAWJ,OAAA,CAAQK,MAAe,EAACC,GAAA,EAAKC,GAAQ,KAAAD,GAAA,IAAOC,GAAO,QAAI,CAAC;IAErE,IAAAH,QAAA,GAAW,CAAK,KAACH,UAAY;MAE/B,MAAMO,KAAA,GAAQ,CAAI,GAAAJ,QAAA;MACRJ,OAAA,GAAAA,OAAA,CAAQT,GAAA,CAAKgB,GAAA,IAASA,GAAA,KAAQ,KAAY,QAAIA,GAAA,GAAMC,KAAM;IAAA,CAC/D;MAEC,MAAAC,OAAA,IAAW,IAAIL,QAAY,IAAAH,UAAA;MACjCD,OAAA,GAAUA,OAAA,CAAQT,GAAI,CAACgB,GAAA,IAASA,GAAQ,cAAYE,OAAA,GAAUF,GAAI;IAAA;IAGpEX,YAAA,CAAaN,KAAQ,GAAAU,OAAA;EAAA,CACtB;EAED,MAAMU,MAAS,GAACH,GAAgB,IAAAA,GAAA,GAAMpB,aAAc,CAAAG,KAAA;EACpD,MAAMqB,OAAA,GAAUtB,QAAS,OAAMO,YAAA,CAAaN,KAAM,CAAAC,GAAA,CAAImB,MAAM,CAAC;EAEtD;IAAEd,YAAA;IAAce;EAAQ;AACjC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}