{"ast":null,"code":"import \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\nimport { inject, onBeforeUnmount, provide } from 'vue';\nimport { TREE_NODE_MAP_INJECTION_KEY } from '../tokens.mjs';\nfunction useNodeExpandEventBroadcast(props) {\n  const parentNodeMap = inject(TREE_NODE_MAP_INJECTION_KEY, null);\n  let currentNodeMap = {\n    treeNodeExpand: node => {\n      var _a;\n      if (props.node !== node) {\n        (_a = props.node) == null ? void 0 : _a.collapse();\n      }\n    },\n    children: /* @__PURE__ */new Set()\n  };\n  if (parentNodeMap) {\n    parentNodeMap.children.add(currentNodeMap);\n  }\n  onBeforeUnmount(() => {\n    if (parentNodeMap) {\n      parentNodeMap.children.delete(currentNodeMap);\n    }\n    currentNodeMap = null;\n  });\n  provide(TREE_NODE_MAP_INJECTION_KEY, currentNodeMap);\n  return {\n    broadcastExpanded: node => {\n      if (!props.accordion) return;\n      for (const childNode of currentNodeMap.children) {\n        childNode.treeNodeExpand(node);\n      }\n    }\n  };\n}\nexport { useNodeExpandEventBroadcast };","map":{"version":3,"names":["useNodeExpandEventBroadcast","props","parentNodeMap","inject","TREE_NODE_MAP_INJECTION_KEY","currentNodeMap","treeNodeExpand","node","_a","collapse","children","Set","add","onBeforeUnmount","delete","provide","broadcastExpanded","accordion","childNode"],"sources":["../../../../../../../packages/components/tree/src/model/useNodeExpandEventBroadcast.ts"],"sourcesContent":["import { inject, onBeforeUnmount, provide } from 'vue'\nimport { TREE_NODE_MAP_INJECTION_KEY } from '../tokens'\n\nimport type Node from '../model/node'\n\ninterface NodeMap {\n  treeNodeExpand(node?: Node): void\n  children: Set<NodeMap>\n}\n\ninterface Props {\n  node?: Node\n  accordion: boolean\n}\n\nexport function useNodeExpandEventBroadcast(props: Props) {\n  const parentNodeMap = inject(\n    TREE_NODE_MAP_INJECTION_KEY,\n    null\n  ) as NodeMap | null\n  let currentNodeMap: NodeMap | null = {\n    treeNodeExpand: (node) => {\n      if (props.node !== node) {\n        props.node?.collapse()\n      }\n    },\n    children: new Set(),\n  }\n\n  if (parentNodeMap) {\n    parentNodeMap.children.add(currentNodeMap)\n  }\n\n  onBeforeUnmount(() => {\n    if (parentNodeMap) {\n      parentNodeMap.children.delete(currentNodeMap!)\n    }\n    currentNodeMap = null\n  })\n\n  provide(TREE_NODE_MAP_INJECTION_KEY, currentNodeMap)\n\n  return {\n    broadcastExpanded: (node?: Node): void => {\n      if (!props.accordion) return\n      for (const childNode of currentNodeMap!.children) {\n        childNode.treeNodeExpand(node)\n      }\n    },\n  }\n}\n"],"mappings":";;;;;;;;;AAeO,SAASA,4BAA4BC,KAAc;EACxD,MAAMC,aAAgB,GAAAC,MAAA,CACpBC,2BAAA,EACA,KACF;EACA,IAAIC,cAAiC;IACnCC,cAAA,EAAiBC,IAAS;MArB9B,IAAAC,EAAA;MAsBU,IAAAP,KAAA,CAAMM,IAAA,KAASA,IAAM;QACvB,CAAAC,EAAA,GAAAP,KAAA,CAAMM,IAAA,KAAN,IAAY,YAAAC,EAAA,CAAAC,QAAA;MAAA;IACd,CACF;IACAC,QAAA,qBAAcC,GAAI;EAAA,CACpB;EAEA,IAAIT,aAAe;IACHA,aAAA,CAAAQ,QAAA,CAASE,GAAA,CAAIP,cAAc;EAAA;EAG3CQ,eAAA,CAAgB,MAAM;IACpB,IAAIX,aAAe;MACHA,aAAA,CAAAQ,QAAA,CAASI,MAAA,CAAOT,cAAe;IAAA;IAE9BA,cAAA;EAAA,CAClB;EAEDU,OAAA,CAAQX,2BAAA,EAA6BC,cAAc;EAE5C;IACLW,iBAAA,EAAoBT,IAAsB;MACxC,IAAI,CAACN,KAAM,CAAAgB,SAAA,EAAW;MACX,WAAAC,SAAA,IAAab,cAAA,CAAgBK,QAAU;QAChDQ,SAAA,CAAUZ,cAAA,CAAeC,IAAI;MAAA;IAC/B;EACF,CACF;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}