{"ast":null,"code":"import { defineComponent, inject, toRefs, ref, getCurrentInstance, computed, watch, nextTick, reactive, onBeforeUnmount, openBlock, createElementBlock, Fragment, createElementVNode, mergeProps, unref, renderSlot, createBlock, withCtx, createCommentVNode } from 'vue';\nimport { isCollapsible, getCollapsible } from './hooks/usePanel.mjs';\nimport SplitBar from './split-bar.mjs';\nimport { splitterPanelProps, splitterPanelEmits } from './split-panel2.mjs';\nimport { splitterRootContextKey } from './type.mjs';\nimport _export_sfc from '../../../_virtual/plugin-vue_export-helper.mjs';\nimport { isPct, getPct, isPx, getPx } from './hooks/useSize.mjs';\nimport { useNamespace } from '../../../hooks/use-namespace/index.mjs';\nimport { throwError } from '../../../utils/error.mjs';\nconst COMPONENT_NAME = \"ElSplitterPanel\";\nconst _sfc_main = defineComponent({\n  ...{\n    name: COMPONENT_NAME\n  },\n  __name: \"split-panel\",\n  props: splitterPanelProps,\n  emits: splitterPanelEmits,\n  setup(__props, {\n    expose: __expose,\n    emit: __emit\n  }) {\n    const ns = useNamespace(\"splitter-panel\");\n    const props = __props;\n    const emits = __emit;\n    const splitterContext = inject(splitterRootContextKey);\n    if (!splitterContext) throwError(COMPONENT_NAME, \"usage: <el-splitter><el-splitter-panel /></el-splitter/>\");\n    const {\n      panels,\n      layout,\n      lazy,\n      containerSize,\n      pxSizes\n    } = toRefs(splitterContext);\n    const {\n      registerPanel,\n      unregisterPanel,\n      onCollapse,\n      onMoveEnd,\n      onMoveStart,\n      onMoving\n    } = splitterContext;\n    const panelEl = ref();\n    const instance = getCurrentInstance();\n    const uid = instance.uid;\n    const index = ref(0);\n    const panel = computed(() => panels.value[index.value]);\n    const setIndex = val => {\n      index.value = val;\n    };\n    const panelSize = computed(() => {\n      var _a;\n      if (!panel.value) return 0;\n      return (_a = pxSizes.value[index.value]) != null ? _a : 0;\n    });\n    const nextSize = computed(() => {\n      var _a;\n      if (!panel.value) return 0;\n      return (_a = pxSizes.value[index.value + 1]) != null ? _a : 0;\n    });\n    const nextPanel = computed(() => {\n      if (panel.value) {\n        return panels.value[index.value + 1];\n      }\n      return null;\n    });\n    const isResizable = computed(() => {\n      var _a;\n      if (!nextPanel.value) return false;\n      return props.resizable && ((_a = nextPanel.value) == null ? void 0 : _a.resizable) && (panelSize.value !== 0 || !props.min) && (nextSize.value !== 0 || !nextPanel.value.min);\n    });\n    const isShowBar = computed(() => {\n      if (!panel.value) return false;\n      return index.value !== panels.value.length - 1;\n    });\n    const startCollapsible = computed(() => isCollapsible(panel.value, panelSize.value, nextPanel.value, nextSize.value));\n    const endCollapsible = computed(() => isCollapsible(nextPanel.value, nextSize.value, panel.value, panelSize.value));\n    function sizeToPx(str) {\n      if (isPct(str)) {\n        return getPct(str) * containerSize.value || 0;\n      } else if (isPx(str)) {\n        return getPx(str);\n      }\n      return str != null ? str : 0;\n    }\n    let isSizeUpdating = false;\n    watch(() => props.size, () => {\n      if (!isSizeUpdating && panel.value) {\n        if (!containerSize.value) {\n          panel.value.size = props.size;\n          return;\n        }\n        const size = sizeToPx(props.size);\n        const maxSize = sizeToPx(props.max);\n        const minSize = sizeToPx(props.min);\n        const finalSize = Math.min(Math.max(size, minSize || 0), maxSize || size);\n        if (finalSize !== size) {\n          emits(\"update:size\", finalSize);\n        }\n        panel.value.size = finalSize;\n      }\n    });\n    watch(() => {\n      var _a;\n      return (_a = panel.value) == null ? void 0 : _a.size;\n    }, val => {\n      if (val !== props.size) {\n        isSizeUpdating = true;\n        emits(\"update:size\", val);\n        nextTick(() => isSizeUpdating = false);\n      }\n    });\n    watch(() => props.resizable, val => {\n      if (panel.value) {\n        panel.value.resizable = val;\n      }\n    });\n    const _panel = reactive({\n      el: panelEl.value,\n      uid,\n      getVnode: () => instance.vnode,\n      setIndex,\n      ...props,\n      collapsible: computed(() => getCollapsible(props.collapsible))\n    });\n    registerPanel(_panel);\n    onBeforeUnmount(() => unregisterPanel(_panel));\n    __expose({\n      splitterPanelRef: panelEl\n    });\n    return (_ctx, _cache) => {\n      return openBlock(), createElementBlock(Fragment, null, [createElementVNode(\"div\", mergeProps({\n        ref_key: \"panelEl\",\n        ref: panelEl,\n        class: [unref(ns).b()],\n        style: {\n          flexBasis: `${panelSize.value}px`\n        }\n      }, _ctx.$attrs), [renderSlot(_ctx.$slots, \"default\")], 16), isShowBar.value ? (openBlock(), createBlock(SplitBar, {\n        key: 0,\n        index: index.value,\n        layout: unref(layout),\n        lazy: unref(lazy),\n        resizable: isResizable.value,\n        \"start-collapsible\": startCollapsible.value,\n        \"end-collapsible\": endCollapsible.value,\n        onMoveStart: unref(onMoveStart),\n        onMoving: unref(onMoving),\n        onMoveEnd: unref(onMoveEnd),\n        onCollapse: unref(onCollapse)\n      }, {\n        \"start-collapsible\": withCtx(() => [renderSlot(_ctx.$slots, \"start-collapsible\")]),\n        \"end-collapsible\": withCtx(() => [renderSlot(_ctx.$slots, \"end-collapsible\")]),\n        _: 3\n      }, 8, [\"index\", \"layout\", \"lazy\", \"resizable\", \"start-collapsible\", \"end-collapsible\", \"onMoveStart\", \"onMoving\", \"onMoveEnd\", \"onCollapse\"])) : createCommentVNode(\"v-if\", true)], 64);\n    };\n  }\n});\nvar SplitPanel = /* @__PURE__ */_export_sfc(_sfc_main, [[\"__file\", \"/home/runner/work/element-plus/element-plus/packages/components/splitter/src/split-panel.vue\"]]);\nexport { SplitPanel as default };","map":{"version":3,"names":["COMPONENT_NAME","ns","useNamespace","props","__props","emits","__emit","splitterContext","inject","splitterRootContextKey","throwError","panels","layout","lazy","containerSize","pxSizes","toRefs","registerPanel","unregisterPanel","onCollapse","onMoveEnd","onMoveStart","onMoving","panelEl","ref","instance","getCurrentInstance","uid","index","panel","computed","value","setIndex","val","panelSize","_a","nextSize","nextPanel","isResizable","resizable","min","isShowBar","length","startCollapsible","isCollapsible","endCollapsible","sizeToPx","str","isPct","getPct","isPx","getPx","isSizeUpdating","watch","size","maxSize","max","minSize","finalSize","Math","nextTick","_panel","reactive","el","getVnode","vnode","collapsible","getCollapsible","onBeforeUnmount","__expose","splitterPanelRef","createElementVNode","mergeProps","ref_key","class","unref","b","style","flexBasis","_ctx","$attrs","renderSlot","$slots","openBlock","createBlock","SplitBar","key","withCtx","_"],"sources":["../../../../../../packages/components/splitter/src/split-panel.vue"],"sourcesContent":["<script setup lang=\"ts\">\nimport {\n  computed,\n  getCurrentInstance,\n  inject,\n  nextTick,\n  onBeforeUnmount,\n  reactive,\n  ref,\n  toRefs,\n  watch,\n} from 'vue'\nimport { useNamespace } from '@element-plus/hooks'\nimport { throwError } from '@element-plus/utils'\nimport { getCollapsible, isCollapsible } from './hooks/usePanel'\nimport SplitBar from './split-bar.vue'\nimport { splitterPanelEmits, splitterPanelProps } from './split-panel'\nimport { getPct, getPx, isPct, isPx } from './hooks'\nimport { splitterRootContextKey } from './type'\n\nconst ns = useNamespace('splitter-panel')\n\nconst COMPONENT_NAME = 'ElSplitterPanel'\ndefineOptions({\n  name: COMPONENT_NAME,\n})\n\nconst props = defineProps(splitterPanelProps)\n\nconst emits = defineEmits(splitterPanelEmits)\nconst splitterContext = inject(splitterRootContextKey)\nif (!splitterContext)\n  throwError(\n    COMPONENT_NAME,\n    'usage: <el-splitter><el-splitter-panel /></el-splitter/>'\n  )\n\nconst { panels, layout, lazy, containerSize, pxSizes } = toRefs(splitterContext)\n\nconst {\n  registerPanel,\n  unregisterPanel,\n  onCollapse,\n  onMoveEnd,\n  onMoveStart,\n  onMoving,\n} = splitterContext\n\nconst panelEl = ref<HTMLDivElement>()\nconst instance = getCurrentInstance()!\nconst uid = instance.uid\n\nconst index = ref(0)\nconst panel = computed(() => panels.value[index.value])\n\nconst setIndex = (val: number) => {\n  index.value = val\n}\n\nconst panelSize = computed(() => {\n  if (!panel.value) return 0\n  return pxSizes.value[index.value] ?? 0\n})\n\nconst nextSize = computed(() => {\n  if (!panel.value) return 0\n  return pxSizes.value[index.value + 1] ?? 0\n})\n\nconst nextPanel = computed(() => {\n  if (panel.value) {\n    return panels.value[index.value + 1]\n  }\n  return null\n})\n\nconst isResizable = computed(() => {\n  if (!nextPanel.value) return false\n  return (\n    props.resizable &&\n    nextPanel.value?.resizable &&\n    // If it is 0, it means it is collapsed => check if the minimum value is set\n    (panelSize.value !== 0 || !props.min) &&\n    (nextSize.value !== 0 || !nextPanel.value.min)\n  )\n})\n\n// The last panel doesn't need a drag bar\nconst isShowBar = computed(() => {\n  if (!panel.value) return false\n  return index.value !== panels.value.length - 1\n})\n\nconst startCollapsible = computed(() =>\n  isCollapsible(panel.value, panelSize.value, nextPanel.value, nextSize.value)\n)\n\nconst endCollapsible = computed(() =>\n  isCollapsible(nextPanel.value, nextSize.value, panel.value, panelSize.value)\n)\n\nfunction sizeToPx(str: string | number | undefined) {\n  if (isPct(str)) {\n    return getPct(str) * containerSize.value || 0\n  } else if (isPx(str)) {\n    return getPx(str)\n  }\n  return str ?? 0\n}\n\n// Two-way binding for size\nlet isSizeUpdating = false\nwatch(\n  () => props.size,\n  () => {\n    if (!isSizeUpdating && panel.value) {\n      if (!containerSize.value) {\n        panel.value.size = props.size\n        return\n      }\n\n      const size = sizeToPx(props.size)\n      const maxSize = sizeToPx(props.max)\n      const minSize = sizeToPx(props.min)\n\n      // Ensure it is within the maximum and minimum value range\n      const finalSize = Math.min(Math.max(size, minSize || 0), maxSize || size)\n\n      if (finalSize !== size) {\n        emits('update:size', finalSize)\n      }\n\n      panel.value.size = finalSize\n    }\n  }\n)\n\nwatch(\n  () => panel.value?.size,\n  (val) => {\n    if (val !== props.size) {\n      isSizeUpdating = true\n      emits('update:size', val as number)\n      nextTick(() => (isSizeUpdating = false))\n    }\n  }\n)\n\nwatch(\n  () => props.resizable,\n  (val) => {\n    if (panel.value) {\n      panel.value.resizable = val\n    }\n  }\n)\n\nconst _panel = reactive({\n  el: panelEl.value!,\n  uid,\n  getVnode: () => instance.vnode,\n  setIndex,\n  ...props,\n  collapsible: computed(() => getCollapsible(props.collapsible)),\n})\n\nregisterPanel(_panel)\n\nonBeforeUnmount(() => unregisterPanel(_panel))\n\ndefineExpose({\n  /** @description splitter-panel html element */\n  splitterPanelRef: panelEl,\n})\n</script>\n\n<template>\n  <div\n    ref=\"panelEl\"\n    :class=\"[ns.b()]\"\n    :style=\"{ flexBasis: `${panelSize}px` }\"\n    v-bind=\"$attrs\"\n  >\n    <slot />\n  </div>\n  <SplitBar\n    v-if=\"isShowBar\"\n    :index=\"index\"\n    :layout=\"layout\"\n    :lazy=\"lazy\"\n    :resizable=\"isResizable\"\n    :start-collapsible=\"startCollapsible\"\n    :end-collapsible=\"endCollapsible\"\n    @move-start=\"onMoveStart\"\n    @moving=\"onMoving\"\n    @move-end=\"onMoveEnd\"\n    @collapse=\"onCollapse\"\n  >\n    <template #start-collapsible>\n      <slot name=\"start-collapsible\" />\n    </template>\n    <template #end-collapsible>\n      <slot name=\"end-collapsible\" />\n    </template>\n  </SplitBar>\n</template>\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}