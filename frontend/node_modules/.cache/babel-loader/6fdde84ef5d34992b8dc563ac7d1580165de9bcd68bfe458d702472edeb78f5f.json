{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport { ref, getCurrentInstance, computed, watch, unref } from 'vue';\nimport { getRowIdentity, walkTreeNode } from '../util.mjs';\nimport { isArray } from '@vue/shared';\nimport { isUndefined } from '../../../../utils/types.mjs';\nfunction useTree(watcherData) {\n  const expandRowKeys = ref([]);\n  const treeData = ref({});\n  const indent = ref(16);\n  const lazy = ref(false);\n  const lazyTreeNodeMap = ref({});\n  const lazyColumnIdentifier = ref(\"hasChildren\");\n  const childrenColumnName = ref(\"children\");\n  const checkStrictly = ref(false);\n  const instance = getCurrentInstance();\n  const normalizedData = computed(() => {\n    if (!watcherData.rowKey.value) return {};\n    const data = watcherData.data.value || [];\n    return normalize(data);\n  });\n  const normalizedLazyNode = computed(() => {\n    const rowKey = watcherData.rowKey.value;\n    const keys = Object.keys(lazyTreeNodeMap.value);\n    const res = {};\n    if (!keys.length) return res;\n    keys.forEach(key => {\n      if (lazyTreeNodeMap.value[key].length) {\n        const item = {\n          children: []\n        };\n        lazyTreeNodeMap.value[key].forEach(row => {\n          const currentRowKey = getRowIdentity(row, rowKey);\n          item.children.push(currentRowKey);\n          if (row[lazyColumnIdentifier.value] && !res[currentRowKey]) {\n            res[currentRowKey] = {\n              children: []\n            };\n          }\n        });\n        res[key] = item;\n      }\n    });\n    return res;\n  });\n  const normalize = data => {\n    const rowKey = watcherData.rowKey.value;\n    const res = {};\n    walkTreeNode(data, (parent, children, level) => {\n      const parentId = getRowIdentity(parent, rowKey);\n      if (isArray(children)) {\n        res[parentId] = {\n          children: children.map(row => getRowIdentity(row, rowKey)),\n          level\n        };\n      } else if (lazy.value) {\n        res[parentId] = {\n          children: [],\n          lazy: true,\n          level\n        };\n      }\n    }, childrenColumnName.value, lazyColumnIdentifier.value, lazy.value);\n    return res;\n  };\n  const updateTreeData = (ifChangeExpandRowKeys = false, ifExpandAll) => {\n    var _a, _b;\n    ifExpandAll || (ifExpandAll = (_a = instance.store) == null ? void 0 : _a.states.defaultExpandAll.value);\n    const nested = normalizedData.value;\n    const normalizedLazyNode_ = normalizedLazyNode.value;\n    const keys = Object.keys(nested);\n    const newTreeData = {};\n    if (keys.length) {\n      const oldTreeData = unref(treeData);\n      const rootLazyRowKeys = [];\n      const getExpanded = (oldValue, key) => {\n        if (ifChangeExpandRowKeys) {\n          if (expandRowKeys.value) {\n            return ifExpandAll || expandRowKeys.value.includes(key);\n          } else {\n            return !!(ifExpandAll || (oldValue == null ? void 0 : oldValue.expanded));\n          }\n        } else {\n          const included = ifExpandAll || expandRowKeys.value && expandRowKeys.value.includes(key);\n          return !!((oldValue == null ? void 0 : oldValue.expanded) || included);\n        }\n      };\n      keys.forEach(key => {\n        const oldValue = oldTreeData[key];\n        const newValue = {\n          ...nested[key]\n        };\n        newValue.expanded = getExpanded(oldValue, key);\n        if (newValue.lazy) {\n          const {\n            loaded = false,\n            loading = false\n          } = oldValue || {};\n          newValue.loaded = !!loaded;\n          newValue.loading = !!loading;\n          rootLazyRowKeys.push(key);\n        }\n        newTreeData[key] = newValue;\n      });\n      const lazyKeys = Object.keys(normalizedLazyNode_);\n      if (lazy.value && lazyKeys.length && rootLazyRowKeys.length) {\n        lazyKeys.forEach(key => {\n          var _a2;\n          const oldValue = oldTreeData[key];\n          const lazyNodeChildren = normalizedLazyNode_[key].children;\n          if (rootLazyRowKeys.includes(key)) {\n            if (((_a2 = newTreeData[key].children) == null ? void 0 : _a2.length) !== 0) {\n              throw new Error(\"[ElTable]children must be an empty array.\");\n            }\n            newTreeData[key].children = lazyNodeChildren;\n          } else {\n            const {\n              loaded = false,\n              loading = false\n            } = oldValue || {};\n            newTreeData[key] = {\n              lazy: true,\n              loaded: !!loaded,\n              loading: !!loading,\n              expanded: getExpanded(oldValue, key),\n              children: lazyNodeChildren,\n              level: void 0\n            };\n          }\n        });\n      }\n    }\n    treeData.value = newTreeData;\n    (_b = instance.store) == null ? void 0 : _b.updateTableScrollY();\n  };\n  watch(() => expandRowKeys.value, () => {\n    updateTreeData(true);\n  });\n  watch(() => normalizedData.value, () => {\n    updateTreeData();\n  });\n  watch(() => normalizedLazyNode.value, () => {\n    updateTreeData();\n  });\n  const updateTreeExpandKeys = value => {\n    expandRowKeys.value = value;\n    updateTreeData();\n  };\n  const isUseLazy = data => {\n    return lazy.value && data && \"loaded\" in data && !data.loaded;\n  };\n  const toggleTreeExpansion = (row, expanded) => {\n    instance.store.assertRowKey();\n    const rowKey = watcherData.rowKey.value;\n    const id = getRowIdentity(row, rowKey);\n    const data = id && treeData.value[id];\n    if (id && data && \"expanded\" in data) {\n      const oldExpanded = data.expanded;\n      expanded = isUndefined(expanded) ? !data.expanded : expanded;\n      treeData.value[id].expanded = expanded;\n      if (oldExpanded !== expanded) {\n        instance.emit(\"expand-change\", row, expanded);\n      }\n      expanded && isUseLazy(data) && loadData(row, id, data);\n      instance.store.updateTableScrollY();\n    }\n  };\n  const loadOrToggle = row => {\n    instance.store.assertRowKey();\n    const rowKey = watcherData.rowKey.value;\n    const id = getRowIdentity(row, rowKey);\n    const data = treeData.value[id];\n    if (isUseLazy(data)) {\n      loadData(row, id, data);\n    } else {\n      toggleTreeExpansion(row, void 0);\n    }\n  };\n  const loadData = (row, key, treeNode) => {\n    const {\n      load\n    } = instance.props;\n    if (load && !treeData.value[key].loaded) {\n      treeData.value[key].loading = true;\n      load(row, treeNode, data => {\n        if (!isArray(data)) {\n          throw new TypeError(\"[ElTable] data must be an array\");\n        }\n        treeData.value[key].loading = false;\n        treeData.value[key].loaded = true;\n        treeData.value[key].expanded = true;\n        if (data.length) {\n          lazyTreeNodeMap.value[key] = data;\n        }\n        instance.emit(\"expand-change\", row, true);\n      });\n    }\n  };\n  const updateKeyChildren = (key, data) => {\n    const {\n      lazy: lazy2,\n      rowKey\n    } = instance.props;\n    if (!lazy2) return;\n    if (!rowKey) throw new Error(\"[Table] rowKey is required in updateKeyChild\");\n    if (lazyTreeNodeMap.value[key]) {\n      lazyTreeNodeMap.value[key] = data;\n    }\n  };\n  return {\n    loadData,\n    loadOrToggle,\n    toggleTreeExpansion,\n    updateTreeExpandKeys,\n    updateTreeData,\n    updateKeyChildren,\n    normalize,\n    states: {\n      expandRowKeys,\n      treeData,\n      indent,\n      lazy,\n      lazyTreeNodeMap,\n      lazyColumnIdentifier,\n      childrenColumnName,\n      checkStrictly\n    }\n  };\n}\nexport { useTree as default };","map":{"version":3,"names":["useTree","watcherData","expandRowKeys","ref","treeData","indent","lazy","lazyTreeNodeMap","lazyColumnIdentifier","childrenColumnName","checkStrictly","instance","getCurrentInstance","normalizedData","computed","rowKey","value","data","normalize","normalizedLazyNode","keys","Object","res","length","forEach","key","item","children","row","currentRowKey","getRowIdentity","push","walkTreeNode","parent","level","parentId","isArray","map","updateTreeData","ifChangeExpandRowKeys","ifExpandAll","_a","_b","store","states","defaultExpandAll","nested","normalizedLazyNode_","newTreeData","oldTreeData","unref","rootLazyRowKeys","getExpanded","oldValue","includes","expanded","included","newValue","loaded","loading","lazyKeys","_a2","lazyNodeChildren","Error","updateTableScrollY","watch","updateTreeExpandKeys","isUseLazy","toggleTreeExpansion","assertRowKey","id","oldExpanded","isUndefined","emit","loadData","loadOrToggle","treeNode","load","props","TypeError","updateKeyChildren","lazy2"],"sources":["../../../../../../../packages/components/table/src/store/tree.ts"],"sourcesContent":["import { computed, getCurrentInstance, ref, unref, watch } from 'vue'\nimport { isArray, isUndefined } from '@element-plus/utils'\nimport { getRowIdentity, walkTreeNode } from '../util'\n\nimport type { WatcherPropsData } from '.'\nimport type { DefaultRow, Table, TableProps, TreeNode } from '../table/defaults'\n\nexport interface TreeData extends TreeNode {\n  children?: string[]\n  lazy?: boolean\n  loaded?: boolean\n}\n\nfunction useTree<T extends DefaultRow>(watcherData: WatcherPropsData<T>) {\n  const expandRowKeys = ref<Array<string>>([])\n  const treeData = ref<Record<string, TreeData>>({})\n  const indent = ref(16)\n  const lazy = ref(false)\n  const lazyTreeNodeMap = ref<Record<string, T[]>>({})\n  const lazyColumnIdentifier = ref('hasChildren')\n  const childrenColumnName = ref('children')\n  const checkStrictly = ref(false)\n  const instance = getCurrentInstance() as Table<T>\n  const normalizedData = computed(() => {\n    if (!watcherData.rowKey.value) return {}\n    const data = watcherData.data.value || []\n    return normalize(data)\n  })\n  const normalizedLazyNode = computed(() => {\n    const rowKey = watcherData.rowKey.value\n    const keys = Object.keys(lazyTreeNodeMap.value)\n    const res: Record<string, { children: string[] }> = {}\n    if (!keys.length) return res\n    keys.forEach((key) => {\n      if (lazyTreeNodeMap.value[key].length) {\n        const item: (typeof res)[number] = { children: [] }\n        lazyTreeNodeMap.value[key].forEach((row) => {\n          const currentRowKey = getRowIdentity(row, rowKey)\n          item.children.push(currentRowKey)\n          if (row[lazyColumnIdentifier.value] && !res[currentRowKey]) {\n            res[currentRowKey] = { children: [] }\n          }\n        })\n        res[key] = item\n      }\n    })\n    return res\n  })\n\n  const normalize = (data: T[]) => {\n    const rowKey = watcherData.rowKey.value\n    const res = {} as Record<string, TreeData>\n    walkTreeNode(\n      data,\n      (parent, children, level) => {\n        const parentId = getRowIdentity(parent, rowKey)\n        if (isArray(children)) {\n          res[parentId] = {\n            children: children.map((row) => getRowIdentity(row, rowKey)),\n            level,\n          }\n        } else if (lazy.value) {\n          // 当 children 不存在且 lazy 为 true，该节点即为懒加载的节点\n          res[parentId] = {\n            children: [],\n            lazy: true,\n            level,\n          }\n        }\n      },\n      childrenColumnName.value,\n      lazyColumnIdentifier.value,\n      lazy.value\n    )\n    return res\n  }\n\n  const updateTreeData = (\n    ifChangeExpandRowKeys = false,\n    ifExpandAll?: boolean\n  ) => {\n    ifExpandAll ||= instance.store?.states.defaultExpandAll.value\n    const nested = normalizedData.value\n    const normalizedLazyNode_ = normalizedLazyNode.value\n    const keys = Object.keys(nested)\n    const newTreeData: Record<string, TreeData> = {}\n    if (keys.length) {\n      const oldTreeData = unref(treeData)\n      const rootLazyRowKeys: string[] = []\n      const getExpanded = (oldValue: TreeData, key: string) => {\n        if (ifChangeExpandRowKeys) {\n          if (expandRowKeys.value) {\n            return ifExpandAll || expandRowKeys.value.includes(key)\n          } else {\n            return !!(ifExpandAll || oldValue?.expanded)\n          }\n        } else {\n          const included =\n            ifExpandAll ||\n            (expandRowKeys.value && expandRowKeys.value.includes(key))\n          return !!(oldValue?.expanded || included)\n        }\n      }\n      // 合并 expanded 与 display，确保数据刷新后，状态不变\n      keys.forEach((key) => {\n        const oldValue = oldTreeData[key]\n        const newValue = { ...nested[key] }\n        newValue.expanded = getExpanded(oldValue, key)\n        if (newValue.lazy) {\n          const { loaded = false, loading = false } = oldValue || {}\n          newValue.loaded = !!loaded\n          newValue.loading = !!loading\n          rootLazyRowKeys.push(key)\n        }\n        newTreeData[key] = newValue\n      })\n      // 根据懒加载数据更新 treeData\n      const lazyKeys = Object.keys(normalizedLazyNode_)\n      if (lazy.value && lazyKeys.length && rootLazyRowKeys.length) {\n        lazyKeys.forEach((key) => {\n          const oldValue = oldTreeData[key]\n          const lazyNodeChildren = normalizedLazyNode_[key].children\n          if (rootLazyRowKeys.includes(key)) {\n            // 懒加载的 root 节点，更新一下原有的数据，原来的 children 一定是空数组\n            if (newTreeData[key].children?.length !== 0) {\n              throw new Error('[ElTable]children must be an empty array.')\n            }\n            newTreeData[key].children = lazyNodeChildren\n          } else {\n            const { loaded = false, loading = false } = oldValue || {}\n            newTreeData[key] = {\n              lazy: true,\n              loaded: !!loaded,\n              loading: !!loading,\n              expanded: getExpanded(oldValue, key),\n              children: lazyNodeChildren,\n              level: undefined,\n            }\n          }\n        })\n      }\n    }\n    treeData.value = newTreeData\n    instance.store?.updateTableScrollY()\n  }\n\n  watch(\n    () => expandRowKeys.value,\n    () => {\n      updateTreeData(true)\n    }\n  )\n\n  watch(\n    () => normalizedData.value,\n    () => {\n      updateTreeData()\n    }\n  )\n  watch(\n    () => normalizedLazyNode.value,\n    () => {\n      updateTreeData()\n    }\n  )\n\n  const updateTreeExpandKeys = (value: string[]) => {\n    expandRowKeys.value = value\n    updateTreeData()\n  }\n  const isUseLazy = (data: TreeData) => {\n    return lazy.value && data && 'loaded' in data && !data.loaded\n  }\n  const toggleTreeExpansion = (row: T, expanded?: boolean) => {\n    instance.store.assertRowKey()\n\n    const rowKey = watcherData.rowKey.value\n    const id = getRowIdentity(row, rowKey)\n    const data = id && treeData.value[id]\n    if (id && data && 'expanded' in data) {\n      const oldExpanded = data.expanded\n      expanded = isUndefined(expanded) ? !data.expanded : expanded\n      treeData.value[id].expanded = expanded\n      if (oldExpanded !== expanded) {\n        instance.emit('expand-change', row, expanded)\n      }\n      expanded && isUseLazy(data) && loadData(row, id, data)\n      instance.store.updateTableScrollY()\n    }\n  }\n\n  const loadOrToggle = (row: T) => {\n    instance.store.assertRowKey()\n    const rowKey = watcherData.rowKey.value\n    const id = getRowIdentity(row, rowKey)\n    const data = treeData.value[id]\n    if (isUseLazy(data)) {\n      loadData(row, id, data)\n    } else {\n      toggleTreeExpansion(row, undefined)\n    }\n  }\n\n  const loadData = (row: T, key: string, treeNode: TreeNode) => {\n    const { load } = instance.props as unknown as TableProps<T>\n    if (load && !treeData.value[key].loaded) {\n      treeData.value[key].loading = true\n      load(row, treeNode, (data) => {\n        if (!isArray(data)) {\n          throw new TypeError('[ElTable] data must be an array')\n        }\n        treeData.value[key].loading = false\n        treeData.value[key].loaded = true\n        treeData.value[key].expanded = true\n        if (data.length) {\n          lazyTreeNodeMap.value[key] = data\n        }\n        instance.emit('expand-change', row, true)\n      })\n    }\n  }\n\n  const updateKeyChildren = (key: string, data: T[]) => {\n    const { lazy, rowKey } = instance.props as unknown as TableProps<T>\n    if (!lazy) return\n    if (!rowKey) throw new Error('[Table] rowKey is required in updateKeyChild')\n\n    if (lazyTreeNodeMap.value[key]) {\n      lazyTreeNodeMap.value[key] = data\n    }\n  }\n\n  return {\n    loadData,\n    loadOrToggle,\n    toggleTreeExpansion,\n    updateTreeExpandKeys,\n    updateTreeData,\n    updateKeyChildren,\n    normalize,\n    states: {\n      expandRowKeys,\n      treeData,\n      indent,\n      lazy,\n      lazyTreeNodeMap,\n      lazyColumnIdentifier,\n      childrenColumnName,\n      checkStrictly,\n    },\n  }\n}\n\nexport default useTree\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}