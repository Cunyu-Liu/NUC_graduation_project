{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.every.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport { computed, watch } from 'vue';\nimport { CHECKED_CHANGE_EVENT } from '../transfer-panel.mjs';\nimport { usePropsAlias } from './use-props-alias.mjs';\nimport { isFunction } from '@vue/shared';\nconst useCheck = (props, panelState, emit) => {\n  const propsAlias = usePropsAlias(props);\n  const filteredData = computed(() => {\n    return props.data.filter(item => {\n      if (isFunction(props.filterMethod)) {\n        return props.filterMethod(panelState.query, item);\n      } else {\n        const label = String(item[propsAlias.value.label] || item[propsAlias.value.key]);\n        return label.toLowerCase().includes(panelState.query.toLowerCase());\n      }\n    });\n  });\n  const checkableData = computed(() => filteredData.value.filter(item => !item[propsAlias.value.disabled]));\n  const checkedSummary = computed(() => {\n    const checkedLength = panelState.checked.length;\n    const dataLength = props.data.length;\n    const {\n      noChecked,\n      hasChecked\n    } = props.format;\n    if (noChecked && hasChecked) {\n      return checkedLength > 0 ? hasChecked.replace(/\\${checked}/g, checkedLength.toString()).replace(/\\${total}/g, dataLength.toString()) : noChecked.replace(/\\${total}/g, dataLength.toString());\n    } else {\n      return `${checkedLength}/${dataLength}`;\n    }\n  });\n  const isIndeterminate = computed(() => {\n    const checkedLength = panelState.checked.length;\n    return checkedLength > 0 && checkedLength < checkableData.value.length;\n  });\n  const updateAllChecked = () => {\n    const checkableDataKeys = checkableData.value.map(item => item[propsAlias.value.key]);\n    panelState.allChecked = checkableDataKeys.length > 0 && checkableDataKeys.every(item => panelState.checked.includes(item));\n  };\n  const handleAllCheckedChange = value => {\n    panelState.checked = value ? checkableData.value.map(item => item[propsAlias.value.key]) : [];\n  };\n  watch(() => panelState.checked, (val, oldVal) => {\n    updateAllChecked();\n    if (panelState.checkChangeByUser) {\n      const movedKeys = val.concat(oldVal).filter(v => !val.includes(v) || !oldVal.includes(v));\n      emit(CHECKED_CHANGE_EVENT, val, movedKeys);\n    } else {\n      emit(CHECKED_CHANGE_EVENT, val);\n      panelState.checkChangeByUser = true;\n    }\n  });\n  watch(checkableData, () => {\n    updateAllChecked();\n  });\n  watch(() => props.data, () => {\n    const checked = [];\n    const filteredDataKeys = filteredData.value.map(item => item[propsAlias.value.key]);\n    panelState.checked.forEach(item => {\n      if (filteredDataKeys.includes(item)) {\n        checked.push(item);\n      }\n    });\n    panelState.checkChangeByUser = false;\n    panelState.checked = checked;\n  });\n  watch(() => props.defaultChecked, (val, oldVal) => {\n    if (oldVal && val.length === oldVal.length && val.every(item => oldVal.includes(item))) return;\n    const checked = [];\n    const checkableDataKeys = checkableData.value.map(item => item[propsAlias.value.key]);\n    val.forEach(item => {\n      if (checkableDataKeys.includes(item)) {\n        checked.push(item);\n      }\n    });\n    panelState.checkChangeByUser = false;\n    panelState.checked = checked;\n  }, {\n    immediate: true\n  });\n  return {\n    filteredData,\n    checkableData,\n    checkedSummary,\n    isIndeterminate,\n    updateAllChecked,\n    handleAllCheckedChange\n  };\n};\nexport { useCheck };","map":{"version":3,"names":["useCheck","props","panelState","emit","propsAlias","usePropsAlias","filteredData","computed","data","filter","item","isFunction","filterMethod","query","label","String","value","key","toLowerCase","includes","checkableData","disabled","checkedSummary","checkedLength","checked","length","dataLength","noChecked","hasChecked","format","replace","toString","isIndeterminate","updateAllChecked","checkableDataKeys","map","allChecked","every","handleAllCheckedChange","watch","val","oldVal","checkChangeByUser","movedKeys","concat","v","CHECKED_CHANGE_EVENT","filteredDataKeys","forEach","push","defaultChecked","immediate"],"sources":["../../../../../../../packages/components/transfer/src/composables/use-check.ts"],"sourcesContent":["import { computed, watch } from 'vue'\nimport { isFunction } from '@element-plus/utils'\nimport { CHECKED_CHANGE_EVENT } from '../transfer-panel'\nimport { usePropsAlias } from './use-props-alias'\n\nimport type { SetupContext } from 'vue'\nimport type { CheckboxValueType } from '@element-plus/components/checkbox'\nimport type { TransferKey } from '../transfer'\nimport type {\n  TransferPanelEmits,\n  TransferPanelProps,\n  TransferPanelState,\n} from '../transfer-panel'\n\nexport const useCheck = (\n  props: TransferPanelProps,\n  panelState: TransferPanelState,\n  emit: SetupContext<TransferPanelEmits>['emit']\n) => {\n  const propsAlias = usePropsAlias(props)\n\n  const filteredData = computed(() => {\n    return props.data.filter((item) => {\n      if (isFunction(props.filterMethod)) {\n        return props.filterMethod(panelState.query, item)\n      } else {\n        const label = String(\n          item[propsAlias.value.label] || item[propsAlias.value.key]\n        )\n        return label.toLowerCase().includes(panelState.query.toLowerCase())\n      }\n    })\n  })\n\n  const checkableData = computed(() =>\n    filteredData.value.filter((item) => !item[propsAlias.value.disabled])\n  )\n\n  const checkedSummary = computed(() => {\n    const checkedLength = panelState.checked.length\n    const dataLength = props.data.length\n    const { noChecked, hasChecked } = props.format\n\n    if (noChecked && hasChecked) {\n      return checkedLength > 0\n        ? hasChecked\n            .replace(/\\${checked}/g, checkedLength.toString())\n            .replace(/\\${total}/g, dataLength.toString())\n        : noChecked.replace(/\\${total}/g, dataLength.toString())\n    } else {\n      return `${checkedLength}/${dataLength}`\n    }\n  })\n\n  const isIndeterminate = computed(() => {\n    const checkedLength = panelState.checked.length\n    return checkedLength > 0 && checkedLength < checkableData.value.length\n  })\n\n  const updateAllChecked = () => {\n    const checkableDataKeys = checkableData.value.map(\n      (item) => item[propsAlias.value.key]\n    )\n    panelState.allChecked =\n      checkableDataKeys.length > 0 &&\n      checkableDataKeys.every((item) => panelState.checked.includes(item))\n  }\n\n  const handleAllCheckedChange = (value: CheckboxValueType) => {\n    panelState.checked = value\n      ? checkableData.value.map((item) => item[propsAlias.value.key])\n      : []\n  }\n\n  watch(\n    () => panelState.checked,\n    (val, oldVal) => {\n      updateAllChecked()\n\n      if (panelState.checkChangeByUser) {\n        const movedKeys = val\n          .concat(oldVal)\n          .filter((v) => !val.includes(v) || !oldVal.includes(v))\n        emit(CHECKED_CHANGE_EVENT, val, movedKeys)\n      } else {\n        emit(CHECKED_CHANGE_EVENT, val)\n        panelState.checkChangeByUser = true\n      }\n    }\n  )\n\n  watch(checkableData, () => {\n    updateAllChecked()\n  })\n\n  watch(\n    () => props.data,\n    () => {\n      const checked: TransferKey[] = []\n      const filteredDataKeys = filteredData.value.map(\n        (item) => item[propsAlias.value.key]\n      )\n      panelState.checked.forEach((item) => {\n        if (filteredDataKeys.includes(item)) {\n          checked.push(item)\n        }\n      })\n      panelState.checkChangeByUser = false\n      panelState.checked = checked\n    }\n  )\n\n  watch(\n    () => props.defaultChecked,\n    (val, oldVal) => {\n      if (\n        oldVal &&\n        val.length === oldVal.length &&\n        val.every((item) => oldVal.includes(item))\n      )\n        return\n\n      const checked: TransferKey[] = []\n      const checkableDataKeys = checkableData.value.map(\n        (item) => item[propsAlias.value.key]\n      )\n\n      val.forEach((item) => {\n        if (checkableDataKeys.includes(item)) {\n          checked.push(item)\n        }\n      })\n      panelState.checkChangeByUser = false\n      panelState.checked = checked\n    },\n    {\n      immediate: true,\n    }\n  )\n\n  return {\n    filteredData,\n    checkableData,\n    checkedSummary,\n    isIndeterminate,\n    updateAllChecked,\n    handleAllCheckedChange,\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}