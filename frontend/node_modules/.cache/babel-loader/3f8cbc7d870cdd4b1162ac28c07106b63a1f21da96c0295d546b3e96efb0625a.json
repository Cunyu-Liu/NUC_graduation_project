{"ast":null,"code":"import { defineComponent, inject, provide, onActivated, nextTick, unref, createVNode, ref, computed, watch } from 'vue';\nimport { TableV2InjectionKey, TABLE_V2_GRID_INJECTION_KEY } from './tokens.mjs';\nimport { tableV2GridProps } from './grid.mjs';\nimport { sum } from './utils.mjs';\nimport Header from './components/header.mjs';\nimport DynamicSizeGrid from '../../virtual-list/src/components/dynamic-size-grid.mjs';\nimport FixedSizeGrid from '../../virtual-list/src/components/fixed-size-grid.mjs';\nimport { isNumber } from '../../../utils/types.mjs';\nimport { isObject } from '@vue/shared';\nconst COMPONENT_NAME = \"ElTableV2Grid\";\nconst useTableGrid = props => {\n  const headerRef = ref();\n  const bodyRef = ref();\n  const scrollLeft = ref(0);\n  const totalHeight = computed(() => {\n    const {\n      data,\n      rowHeight,\n      estimatedRowHeight\n    } = props;\n    if (estimatedRowHeight) {\n      return;\n    }\n    return data.length * rowHeight;\n  });\n  const fixedRowHeight = computed(() => {\n    const {\n      fixedData,\n      rowHeight\n    } = props;\n    return ((fixedData == null ? void 0 : fixedData.length) || 0) * rowHeight;\n  });\n  const headerHeight = computed(() => sum(props.headerHeight));\n  const gridHeight = computed(() => {\n    const {\n      height\n    } = props;\n    return Math.max(0, height - unref(headerHeight) - unref(fixedRowHeight));\n  });\n  const hasHeader = computed(() => {\n    return unref(headerHeight) + unref(fixedRowHeight) > 0;\n  });\n  const itemKey = ({\n    data,\n    rowIndex\n  }) => data[rowIndex][props.rowKey];\n  function onItemRendered({\n    rowCacheStart,\n    rowCacheEnd,\n    rowVisibleStart,\n    rowVisibleEnd\n  }) {\n    var _a;\n    (_a = props.onRowsRendered) == null ? void 0 : _a.call(props, {\n      rowCacheStart,\n      rowCacheEnd,\n      rowVisibleStart,\n      rowVisibleEnd\n    });\n  }\n  function resetAfterRowIndex(index, forceUpdate2) {\n    var _a;\n    (_a = bodyRef.value) == null ? void 0 : _a.resetAfterRowIndex(index, forceUpdate2);\n  }\n  function scrollTo(leftOrOptions, top) {\n    const header$ = unref(headerRef);\n    const body$ = unref(bodyRef);\n    if (isObject(leftOrOptions)) {\n      header$ == null ? void 0 : header$.scrollToLeft(leftOrOptions.scrollLeft);\n      scrollLeft.value = leftOrOptions.scrollLeft;\n      body$ == null ? void 0 : body$.scrollTo(leftOrOptions);\n    } else {\n      header$ == null ? void 0 : header$.scrollToLeft(leftOrOptions);\n      scrollLeft.value = leftOrOptions;\n      body$ == null ? void 0 : body$.scrollTo({\n        scrollLeft: leftOrOptions,\n        scrollTop: top\n      });\n    }\n  }\n  function scrollToTop(scrollTop) {\n    var _a;\n    (_a = unref(bodyRef)) == null ? void 0 : _a.scrollTo({\n      scrollTop\n    });\n  }\n  function scrollToRow(row, strategy) {\n    var _a;\n    (_a = unref(bodyRef)) == null ? void 0 : _a.scrollToItem(row, 1, strategy);\n  }\n  function forceUpdate() {\n    var _a, _b;\n    (_a = unref(bodyRef)) == null ? void 0 : _a.$forceUpdate();\n    (_b = unref(headerRef)) == null ? void 0 : _b.$forceUpdate();\n  }\n  watch(() => props.bodyWidth, () => {\n    var _a;\n    if (isNumber(props.estimatedRowHeight)) (_a = bodyRef.value) == null ? void 0 : _a.resetAfter({\n      columnIndex: 0\n    }, false);\n  });\n  return {\n    bodyRef,\n    forceUpdate,\n    fixedRowHeight,\n    gridHeight,\n    hasHeader,\n    headerHeight,\n    headerRef,\n    totalHeight,\n    itemKey,\n    onItemRendered,\n    resetAfterRowIndex,\n    scrollTo,\n    scrollToTop,\n    scrollToRow,\n    scrollLeft\n  };\n};\nconst TableGrid = defineComponent({\n  name: COMPONENT_NAME,\n  props: tableV2GridProps,\n  setup(props, {\n    slots,\n    expose\n  }) {\n    const {\n      ns\n    } = inject(TableV2InjectionKey);\n    const {\n      bodyRef,\n      fixedRowHeight,\n      gridHeight,\n      hasHeader,\n      headerRef,\n      headerHeight,\n      totalHeight,\n      forceUpdate,\n      itemKey,\n      onItemRendered,\n      resetAfterRowIndex,\n      scrollTo,\n      scrollToTop,\n      scrollToRow,\n      scrollLeft\n    } = useTableGrid(props);\n    provide(TABLE_V2_GRID_INJECTION_KEY, scrollLeft);\n    onActivated(async () => {\n      var _a;\n      await nextTick();\n      const scrollTop = (_a = bodyRef.value) == null ? void 0 : _a.states.scrollTop;\n      scrollTop && scrollToTop(Math.round(scrollTop) + 1);\n    });\n    expose({\n      forceUpdate,\n      totalHeight,\n      scrollTo,\n      scrollToTop,\n      scrollToRow,\n      resetAfterRowIndex\n    });\n    const getColumnWidth = () => props.bodyWidth;\n    return () => {\n      const {\n        cache,\n        columns,\n        data,\n        fixedData,\n        useIsScrolling,\n        scrollbarAlwaysOn,\n        scrollbarEndGap,\n        scrollbarStartGap,\n        style,\n        rowHeight,\n        bodyWidth,\n        estimatedRowHeight,\n        headerWidth,\n        height,\n        width,\n        getRowHeight,\n        onScroll\n      } = props;\n      const isDynamicRowEnabled = isNumber(estimatedRowHeight);\n      const Grid = isDynamicRowEnabled ? DynamicSizeGrid : FixedSizeGrid;\n      const _headerHeight = unref(headerHeight);\n      return createVNode(\"div\", {\n        \"role\": \"table\",\n        \"class\": [ns.e(\"table\"), props.class],\n        \"style\": style\n      }, [createVNode(Grid, {\n        \"ref\": bodyRef,\n        \"data\": data,\n        \"useIsScrolling\": useIsScrolling,\n        \"itemKey\": itemKey,\n        \"columnCache\": 0,\n        \"columnWidth\": isDynamicRowEnabled ? getColumnWidth : bodyWidth,\n        \"totalColumn\": 1,\n        \"totalRow\": data.length,\n        \"rowCache\": cache,\n        \"rowHeight\": isDynamicRowEnabled ? getRowHeight : rowHeight,\n        \"width\": width,\n        \"height\": unref(gridHeight),\n        \"class\": ns.e(\"body\"),\n        \"role\": \"rowgroup\",\n        \"scrollbarStartGap\": scrollbarStartGap,\n        \"scrollbarEndGap\": scrollbarEndGap,\n        \"scrollbarAlwaysOn\": scrollbarAlwaysOn,\n        \"onScroll\": onScroll,\n        \"onItemRendered\": onItemRendered,\n        \"perfMode\": false\n      }, {\n        default: params => {\n          var _a;\n          const rowData = data[params.rowIndex];\n          return (_a = slots.row) == null ? void 0 : _a.call(slots, {\n            ...params,\n            columns,\n            rowData\n          });\n        }\n      }), unref(hasHeader) && createVNode(Header, {\n        \"ref\": headerRef,\n        \"class\": ns.e(\"header-wrapper\"),\n        \"columns\": columns,\n        \"headerData\": data,\n        \"headerHeight\": props.headerHeight,\n        \"fixedHeaderData\": fixedData,\n        \"rowWidth\": headerWidth,\n        \"rowHeight\": rowHeight,\n        \"width\": width,\n        \"height\": Math.min(_headerHeight + unref(fixedRowHeight), height)\n      }, {\n        dynamic: slots.header,\n        fixed: slots.row\n      })]);\n    };\n  }\n});\nvar Table = TableGrid;\nexport { Table as default };","map":{"version":3,"names":["COMPONENT_NAME","useTableGrid","props","headerRef","ref","bodyRef","scrollLeft","totalHeight","computed","data","rowHeight","estimatedRowHeight","length","fixedRowHeight","fixedData","headerHeight","sum","gridHeight","height","Math","max","unref","hasHeader","itemKey","rowIndex","rowKey","onItemRendered","rowCacheStart","rowCacheEnd","rowVisibleStart","rowVisibleEnd","_a","onRowsRendered","call","resetAfterRowIndex","index","forceUpdate2","value","scrollTo","leftOrOptions","top","header$","body$","isObject","scrollToLeft","scrollTop","scrollToTop","scrollToRow","row","strategy","scrollToItem","forceUpdate","_b","$forceUpdate","watch","bodyWidth","isNumber","resetAfter","columnIndex","TableGrid","defineComponent","name","tableV2GridProps","setup","slots","expose","ns","inject","TableV2InjectionKey","provide","TABLE_V2_GRID_INJECTION_KEY","onActivated","nextTick","states","round","getColumnWidth","cache","columns","useIsScrolling","scrollbarAlwaysOn","scrollbarEndGap","scrollbarStartGap","style","headerWidth","width","getRowHeight","onScroll","isDynamicRowEnabled","Grid","DynamicSizeGrid","FixedSizeGrid","_headerHeight","createVNode","e","class","default","params","rowData","Header","min","dynamic","header","fixed","Table"],"sources":["../../../../../../packages/components/table-v2/src/table-grid.tsx"],"sourcesContent":["import {\n  computed,\n  defineComponent,\n  inject,\n  nextTick,\n  onActivated,\n  provide,\n  ref,\n  unref,\n  watch,\n} from 'vue'\nimport {\n  DynamicSizeGrid,\n  FixedSizeGrid,\n} from '@element-plus/components/virtual-list'\nimport { isNumber, isObject } from '@element-plus/utils'\nimport { Header } from './components'\nimport { TABLE_V2_GRID_INJECTION_KEY, TableV2InjectionKey } from './tokens'\nimport { tableV2GridProps } from './grid'\nimport { sum } from './utils'\n\nimport type { UnwrapRef } from 'vue'\nimport type {\n  DynamicSizeGridInstance,\n  GridDefaultSlotParams,\n  GridItemKeyGetter,\n  GridItemRenderedEvtParams,\n  GridScrollOptions,\n  ResetAfterIndex,\n  Alignment as ScrollStrategy,\n} from '@element-plus/components/virtual-list'\nimport type { TableV2HeaderInstance } from './components'\nimport type { TableV2GridProps } from './grid'\n\nconst COMPONENT_NAME = 'ElTableV2Grid'\n\nconst useTableGrid = (props: TableV2GridProps) => {\n  const headerRef = ref<TableV2HeaderInstance>()\n  const bodyRef = ref<DynamicSizeGridInstance>()\n  const scrollLeft = ref(0)\n\n  const totalHeight = computed(() => {\n    const { data, rowHeight, estimatedRowHeight } = props\n\n    if (estimatedRowHeight) {\n      return\n    }\n\n    return data.length * (rowHeight as number)\n  })\n\n  const fixedRowHeight = computed(() => {\n    const { fixedData, rowHeight } = props\n\n    return (fixedData?.length || 0) * (rowHeight as number)\n  })\n\n  const headerHeight = computed(() => sum(props.headerHeight))\n\n  const gridHeight = computed(() => {\n    const { height } = props\n    return Math.max(0, height - unref(headerHeight) - unref(fixedRowHeight))\n  })\n\n  const hasHeader = computed(() => {\n    return unref(headerHeight) + unref(fixedRowHeight) > 0\n  })\n\n  const itemKey: GridItemKeyGetter = ({ data, rowIndex }) =>\n    data[rowIndex][props.rowKey]\n\n  function onItemRendered({\n    rowCacheStart,\n    rowCacheEnd,\n    rowVisibleStart,\n    rowVisibleEnd,\n  }: GridItemRenderedEvtParams) {\n    props.onRowsRendered?.({\n      rowCacheStart,\n      rowCacheEnd,\n      rowVisibleStart,\n      rowVisibleEnd,\n    })\n  }\n\n  function resetAfterRowIndex(index: number, forceUpdate: boolean) {\n    bodyRef.value?.resetAfterRowIndex(index, forceUpdate)\n  }\n\n  function scrollTo(x: number, y: number): void\n  function scrollTo(options: GridScrollOptions): void\n  function scrollTo(leftOrOptions: number | GridScrollOptions, top?: number) {\n    const header$ = unref(headerRef)\n    const body$ = unref(bodyRef)\n\n    if (isObject(leftOrOptions)) {\n      header$?.scrollToLeft(leftOrOptions.scrollLeft)\n      scrollLeft.value = leftOrOptions.scrollLeft!\n      body$?.scrollTo(leftOrOptions)\n    } else {\n      header$?.scrollToLeft(leftOrOptions)\n      scrollLeft.value = leftOrOptions\n      body$?.scrollTo({\n        scrollLeft: leftOrOptions,\n        scrollTop: top,\n      })\n    }\n  }\n\n  function scrollToTop(scrollTop: number) {\n    unref(bodyRef)?.scrollTo({\n      scrollTop,\n    })\n  }\n\n  function scrollToRow(row: number, strategy: ScrollStrategy) {\n    unref(bodyRef)?.scrollToItem(row, 1, strategy)\n  }\n\n  function forceUpdate() {\n    unref(bodyRef)?.$forceUpdate()\n    unref(headerRef)?.$forceUpdate()\n  }\n\n  watch(\n    () => props.bodyWidth,\n    () => {\n      if (isNumber(props.estimatedRowHeight))\n        bodyRef.value?.resetAfter({ columnIndex: 0 }, false)\n    }\n  )\n\n  return {\n    bodyRef,\n    forceUpdate,\n    fixedRowHeight,\n    gridHeight,\n    hasHeader,\n    headerHeight,\n    headerRef,\n    totalHeight,\n\n    itemKey,\n    onItemRendered,\n    resetAfterRowIndex,\n    scrollTo,\n    scrollToTop,\n    scrollToRow,\n    scrollLeft,\n  }\n}\n\nconst TableGrid = defineComponent({\n  name: COMPONENT_NAME,\n  props: tableV2GridProps,\n  setup(props, { slots, expose }) {\n    const { ns } = inject(TableV2InjectionKey)!\n\n    const {\n      bodyRef,\n      fixedRowHeight,\n      gridHeight,\n      hasHeader,\n      headerRef,\n      headerHeight,\n      totalHeight,\n\n      forceUpdate,\n      itemKey,\n      onItemRendered,\n      resetAfterRowIndex,\n      scrollTo,\n      scrollToTop,\n      scrollToRow,\n      scrollLeft,\n    } = useTableGrid(props)\n\n    provide(TABLE_V2_GRID_INJECTION_KEY, scrollLeft)\n\n    onActivated(async () => {\n      await nextTick()\n      const scrollTop = bodyRef.value?.states.scrollTop\n      scrollTop && scrollToTop(Math.round(scrollTop) + 1)\n    })\n\n    expose({\n      forceUpdate,\n      /**\n       * @description fetch total height\n       */\n      totalHeight,\n      /**\n       * @description scroll to a position\n       */\n      scrollTo,\n      /**\n       * @description scroll vertically to position y\n       */\n      scrollToTop,\n      /**\n       * @description scroll to a given row\n       * @params row {Number} which row to scroll to\n       * @params strategy {ScrollStrategy} use what strategy to scroll to\n       */\n      scrollToRow,\n      /**\n       * @description reset rendered state after row index\n       */\n      resetAfterRowIndex,\n    })\n\n    const getColumnWidth = () => props.bodyWidth\n\n    return () => {\n      const {\n        cache,\n        columns,\n        data,\n        fixedData,\n        useIsScrolling,\n        scrollbarAlwaysOn,\n        scrollbarEndGap,\n        scrollbarStartGap,\n        style,\n        rowHeight,\n        bodyWidth,\n        estimatedRowHeight,\n        headerWidth,\n        height,\n        width,\n\n        getRowHeight,\n        onScroll,\n      } = props\n\n      const isDynamicRowEnabled = isNumber(estimatedRowHeight)\n      const Grid = isDynamicRowEnabled ? DynamicSizeGrid : FixedSizeGrid\n      const _headerHeight = unref(headerHeight)\n\n      return (\n        <div role=\"table\" class={[ns.e('table'), props.class]} style={style}>\n          <Grid\n            ref={bodyRef}\n            // special attrs\n            data={data}\n            useIsScrolling={useIsScrolling}\n            itemKey={itemKey}\n            // column attrs\n            columnCache={0}\n            columnWidth={isDynamicRowEnabled ? getColumnWidth : bodyWidth}\n            totalColumn={1}\n            // row attrs\n            totalRow={data.length}\n            rowCache={cache}\n            rowHeight={isDynamicRowEnabled ? getRowHeight : rowHeight}\n            // DOM attrs\n            width={width}\n            height={unref(gridHeight)}\n            class={ns.e('body')}\n            role=\"rowgroup\"\n            scrollbarStartGap={scrollbarStartGap}\n            scrollbarEndGap={scrollbarEndGap}\n            scrollbarAlwaysOn={scrollbarAlwaysOn}\n            // handlers\n            onScroll={onScroll}\n            onItemRendered={onItemRendered}\n            perfMode={false}\n          >\n            {{\n              default: (params: GridDefaultSlotParams) => {\n                const rowData = data[params.rowIndex]\n                return slots.row?.({\n                  ...params,\n                  columns,\n                  rowData,\n                })\n              },\n            }}\n          </Grid>\n          {unref(hasHeader) && (\n            <Header\n              ref={headerRef}\n              class={ns.e('header-wrapper')}\n              columns={columns}\n              headerData={data}\n              headerHeight={props.headerHeight}\n              fixedHeaderData={fixedData}\n              rowWidth={headerWidth}\n              rowHeight={rowHeight}\n              width={width}\n              height={Math.min(_headerHeight + unref(fixedRowHeight), height)}\n            >\n              {{\n                dynamic: slots.header,\n                fixed: slots.row,\n              }}\n            </Header>\n          )}\n        </div>\n      )\n    }\n  },\n})\n\nexport default TableGrid\n\nexport type TableGridRowSlotParams = {\n  columns: TableV2GridProps['columns']\n  rowData: any\n} & GridDefaultSlotParams\n\nexport type TableGridInstance = InstanceType<typeof TableGrid> &\n  UnwrapRef<{\n    forceUpdate: () => void\n    /**\n     * @description fetch total height\n     */\n    totalHeight: number\n\n    /**\n     * @description scrollTo a position\n     * @param { number | ScrollToOptions } arg1\n     * @param { number } arg2\n     */\n    scrollTo(leftOrOptions: number | GridScrollOptions, top?: number): void\n\n    /**\n     * @description scroll vertically to position y\n     */\n    scrollToTop(scrollTop: number): void\n    /**\n     * @description scroll to a given row\n     * @params row {Number} which row to scroll to\n     * @params @optional strategy {ScrollStrategy} use what strategy to scroll to\n     */\n    scrollToRow(row: number, strategy: ScrollStrategy): void\n    /**\n     * @description reset rendered state after row index\n     * @param { number } rowIndex\n     * @param { boolean } forceUpdate\n     */\n    resetAfterRowIndex: ResetAfterIndex\n  }>\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}