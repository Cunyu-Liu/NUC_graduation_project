{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport { watch, nextTick, computed, toRefs } from 'vue';\nimport { isEqual, pick, isNil } from 'lodash-unified';\nimport { ElTree } from '../../tree/index.mjs';\nimport component from './tree-select-option.mjs';\nimport { toValidArray, treeFind, isValidValue, treeEach, isValidArray } from './utils.mjs';\nimport { escapeStringRegexp } from '../../../utils/strings.mjs';\nimport { UPDATE_MODEL_EVENT } from '../../../constants/event.mjs';\nimport { isFunction } from '@vue/shared';\nimport { isEmpty } from '../../../utils/types.mjs';\nconst useTree = (props, {\n  attrs,\n  slots,\n  emit\n}, {\n  select,\n  tree,\n  key\n}) => {\n  watch([() => props.modelValue, tree], () => {\n    if (props.showCheckbox) {\n      nextTick(() => {\n        const treeInstance = tree.value;\n        if (treeInstance && !isEqual(treeInstance.getCheckedKeys(), toValidArray(props.modelValue))) {\n          treeInstance.setCheckedKeys(toValidArray(props.modelValue));\n        }\n      });\n    }\n  }, {\n    immediate: true,\n    deep: true\n  });\n  const propsMap = computed(() => ({\n    value: key.value,\n    label: \"label\",\n    children: \"children\",\n    disabled: \"disabled\",\n    isLeaf: \"isLeaf\",\n    ...props.props\n  }));\n  const getNodeValByProp = (prop, data) => {\n    var _a;\n    const propVal = propsMap.value[prop];\n    if (isFunction(propVal)) {\n      return propVal(data, (_a = tree.value) == null ? void 0 : _a.getNode(getNodeValByProp(\"value\", data)));\n    } else {\n      return data[propVal];\n    }\n  };\n  const defaultExpandedParentKeys = toValidArray(props.modelValue).map(value => {\n    return treeFind(props.data || [], data => getNodeValByProp(\"value\", data) === value, data => getNodeValByProp(\"children\", data), (data, index, array, parent) => parent && getNodeValByProp(\"value\", parent));\n  }).filter(item => isValidValue(item));\n  const cacheOptions = computed(() => {\n    if (!props.renderAfterExpand && !props.lazy) return [];\n    const options = [];\n    treeEach(props.data.concat(props.cacheData), node => {\n      const value = getNodeValByProp(\"value\", node);\n      options.push({\n        value,\n        currentLabel: getNodeValByProp(\"label\", node),\n        isDisabled: getNodeValByProp(\"disabled\", node)\n      });\n    }, data => getNodeValByProp(\"children\", data));\n    return options;\n  });\n  const getChildCheckedKeys = () => {\n    var _a;\n    return (_a = tree.value) == null ? void 0 : _a.getCheckedKeys().filter(checkedKey => {\n      var _a2;\n      const node = (_a2 = tree.value) == null ? void 0 : _a2.getNode(checkedKey);\n      return !isNil(node) && isEmpty(node.childNodes);\n    });\n  };\n  return {\n    ...pick(toRefs(props), Object.keys(ElTree.props)),\n    ...attrs,\n    nodeKey: key,\n    expandOnClickNode: computed(() => {\n      return !props.checkStrictly && props.expandOnClickNode;\n    }),\n    defaultExpandedKeys: computed(() => {\n      return props.defaultExpandedKeys ? props.defaultExpandedKeys.concat(defaultExpandedParentKeys) : defaultExpandedParentKeys;\n    }),\n    renderContent: (h, {\n      node,\n      data,\n      store\n    }) => {\n      return h(component, {\n        value: getNodeValByProp(\"value\", data),\n        label: getNodeValByProp(\"label\", data),\n        disabled: getNodeValByProp(\"disabled\", data),\n        visible: node.visible\n      }, props.renderContent ? () => props.renderContent(h, {\n        node,\n        data,\n        store\n      }) : slots.default ? () => slots.default({\n        node,\n        data,\n        store\n      }) : void 0);\n    },\n    filterNodeMethod: (value, data, node) => {\n      if (props.filterNodeMethod) return props.filterNodeMethod(value, data, node);\n      if (!value) return true;\n      const regexp = new RegExp(escapeStringRegexp(value), \"i\");\n      return regexp.test(getNodeValByProp(\"label\", data) || \"\");\n    },\n    onNodeClick: (data, node, e) => {\n      var _a, _b, _c;\n      (_a = attrs.onNodeClick) == null ? void 0 : _a.call(attrs, data, node, e);\n      if (props.showCheckbox && props.checkOnClickNode) return;\n      if (!props.showCheckbox && (props.checkStrictly || node.isLeaf)) {\n        if (!getNodeValByProp(\"disabled\", data)) {\n          const option = (_b = select.value) == null ? void 0 : _b.states.options.get(getNodeValByProp(\"value\", data));\n          (_c = select.value) == null ? void 0 : _c.handleOptionSelect(option);\n        }\n      } else if (props.expandOnClickNode) {\n        e.proxy.handleExpandIconClick();\n      }\n    },\n    onCheck: (data, params) => {\n      var _a;\n      if (!props.showCheckbox) return;\n      const dataValue = getNodeValByProp(\"value\", data);\n      const dataMap = {};\n      treeEach([tree.value.store.root], node => dataMap[node.key] = node, node => node.childNodes);\n      const uncachedCheckedKeys = params.checkedKeys;\n      const cachedKeys = props.multiple ? toValidArray(props.modelValue).filter(item => !(item in dataMap) && !uncachedCheckedKeys.includes(item)) : [];\n      const checkedKeys = cachedKeys.concat(uncachedCheckedKeys);\n      if (props.checkStrictly) {\n        emit(UPDATE_MODEL_EVENT, props.multiple ? checkedKeys : checkedKeys.includes(dataValue) ? dataValue : void 0);\n      } else {\n        if (props.multiple) {\n          const childKeys = getChildCheckedKeys();\n          emit(UPDATE_MODEL_EVENT, cachedKeys.concat(childKeys));\n        } else {\n          const firstLeaf = treeFind([data], data2 => !isValidArray(getNodeValByProp(\"children\", data2)) && !getNodeValByProp(\"disabled\", data2), data2 => getNodeValByProp(\"children\", data2));\n          const firstLeafKey = firstLeaf ? getNodeValByProp(\"value\", firstLeaf) : void 0;\n          const hasCheckedChild = isValidValue(props.modelValue) && !!treeFind([data], data2 => getNodeValByProp(\"value\", data2) === props.modelValue, data2 => getNodeValByProp(\"children\", data2));\n          emit(UPDATE_MODEL_EVENT, firstLeafKey === props.modelValue || hasCheckedChild ? void 0 : firstLeafKey);\n        }\n      }\n      nextTick(() => {\n        var _a2;\n        const checkedKeys2 = toValidArray(props.modelValue);\n        tree.value.setCheckedKeys(checkedKeys2);\n        (_a2 = attrs.onCheck) == null ? void 0 : _a2.call(attrs, data, {\n          checkedKeys: tree.value.getCheckedKeys(),\n          checkedNodes: tree.value.getCheckedNodes(),\n          halfCheckedKeys: tree.value.getHalfCheckedKeys(),\n          halfCheckedNodes: tree.value.getHalfCheckedNodes()\n        });\n      });\n      (_a = select.value) == null ? void 0 : _a.focus();\n    },\n    onNodeExpand: (data, node, e) => {\n      var _a;\n      (_a = attrs.onNodeExpand) == null ? void 0 : _a.call(attrs, data, node, e);\n      nextTick(() => {\n        if (!props.checkStrictly && props.lazy && props.multiple && node.checked) {\n          const dataMap = {};\n          const uncachedCheckedKeys = tree.value.getCheckedKeys();\n          treeEach([tree.value.store.root], node2 => dataMap[node2.key] = node2, node2 => node2.childNodes);\n          const cachedKeys = toValidArray(props.modelValue).filter(item => !(item in dataMap) && !uncachedCheckedKeys.includes(item));\n          const childKeys = getChildCheckedKeys();\n          emit(UPDATE_MODEL_EVENT, cachedKeys.concat(childKeys));\n        }\n      });\n    },\n    cacheOptions\n  };\n};\nexport { useTree };","map":{"version":3,"names":["useTree","props","attrs","slots","emit","select","tree","key","watch","modelValue","showCheckbox","nextTick","treeInstance","value","isEqual","getCheckedKeys","toValidArray","setCheckedKeys","immediate","deep","propsMap","computed","label","children","disabled","isLeaf","getNodeValByProp","prop","data","_a","propVal","isFunction","getNode","defaultExpandedParentKeys","map","treeFind","index","array","parent","filter","item","isValidValue","cacheOptions","renderAfterExpand","lazy","options","treeEach","concat","cacheData","node","push","currentLabel","isDisabled","getChildCheckedKeys","checkedKey","_a2","isNil","isEmpty","childNodes","pick","toRefs","Object","keys","ElTree","nodeKey","expandOnClickNode","checkStrictly","defaultExpandedKeys","renderContent","h","store","component","visible","default","filterNodeMethod","regexp","RegExp","escapeStringRegexp","test","onNodeClick","e","_b","_c","call","checkOnClickNode","option","states","get","handleOptionSelect","proxy","handleExpandIconClick","onCheck","params","dataValue","dataMap","root","uncachedCheckedKeys","checkedKeys","cachedKeys","multiple","includes","UPDATE_MODEL_EVENT","childKeys","firstLeaf","data2","isValidArray","firstLeafKey","hasCheckedChild","checkedKeys2","checkedNodes","getCheckedNodes","halfCheckedKeys","getHalfCheckedKeys","halfCheckedNodes","getHalfCheckedNodes","focus","onNodeExpand","checked","node2"],"sources":["../../../../../../packages/components/tree-select/src/tree.ts"],"sourcesContent":["// @ts-nocheck\nimport { computed, nextTick, toRefs, watch } from 'vue'\nimport { isEqual, isNil, pick } from 'lodash-unified'\nimport { UPDATE_MODEL_EVENT } from '@element-plus/constants'\nimport { escapeStringRegexp, isEmpty, isFunction } from '@element-plus/utils'\nimport ElTree from '@element-plus/components/tree'\nimport TreeSelectOption from './tree-select-option'\nimport {\n  isValidArray,\n  isValidValue,\n  toValidArray,\n  treeEach,\n  treeFind,\n} from './utils'\n\nimport type { CacheOption } from './cache-options'\nimport type { Ref } from 'vue'\nimport type { SelectInstance } from '@element-plus/components/select'\nimport type Node from '@element-plus/components/tree/src/model/node'\nimport type { TreeNodeData } from '@element-plus/components/tree/src/tree.type'\nimport type { TreeInstance } from '@element-plus/components/tree'\n\nexport const useTree = (\n  props,\n  { attrs, slots, emit },\n  {\n    select,\n    tree,\n    key,\n  }: {\n    select: Ref<SelectInstance | undefined>\n    tree: Ref<TreeInstance | undefined>\n    key: Ref<string>\n  }\n) => {\n  watch(\n    [() => props.modelValue, tree],\n    () => {\n      if (props.showCheckbox) {\n        nextTick(() => {\n          const treeInstance = tree.value\n          if (\n            treeInstance &&\n            !isEqual(\n              treeInstance.getCheckedKeys(),\n              toValidArray(props.modelValue)\n            )\n          ) {\n            treeInstance.setCheckedKeys(toValidArray(props.modelValue))\n          }\n        })\n      }\n    },\n    {\n      immediate: true,\n      deep: true,\n    }\n  )\n\n  const propsMap = computed(() => ({\n    value: key.value,\n    label: 'label',\n    children: 'children',\n    disabled: 'disabled',\n    isLeaf: 'isLeaf',\n    ...props.props,\n  }))\n\n  const getNodeValByProp = (\n    prop: 'value' | 'label' | 'children' | 'disabled' | 'isLeaf',\n    data: TreeNodeData\n  ) => {\n    const propVal = propsMap.value[prop]\n    if (isFunction(propVal)) {\n      return propVal(\n        data,\n        tree.value?.getNode(getNodeValByProp('value', data)) as Node\n      )\n    } else {\n      return data[propVal as string]\n    }\n  }\n\n  const defaultExpandedParentKeys = toValidArray(props.modelValue)\n    .map((value) => {\n      return treeFind(\n        props.data || [],\n        (data) => getNodeValByProp('value', data) === value,\n        (data) => getNodeValByProp('children', data),\n        (data, index, array, parent) =>\n          parent && getNodeValByProp('value', parent)\n      )\n    })\n    .filter((item) => isValidValue(item))\n\n  const cacheOptions = computed(() => {\n    if (!props.renderAfterExpand && !props.lazy) return []\n\n    const options: CacheOption[] = []\n\n    treeEach(\n      props.data.concat(props.cacheData),\n      (node) => {\n        const value = getNodeValByProp('value', node)\n        options.push({\n          value,\n          currentLabel: getNodeValByProp('label', node),\n          isDisabled: getNodeValByProp('disabled', node),\n        })\n      },\n      (data) => getNodeValByProp('children', data)\n    )\n\n    return options\n  })\n\n  const getChildCheckedKeys = () => {\n    return tree.value?.getCheckedKeys().filter((checkedKey) => {\n      const node = tree.value?.getNode(checkedKey) as Node\n      return !isNil(node) && isEmpty(node.childNodes)\n    })\n  }\n\n  return {\n    ...pick(toRefs(props), Object.keys(ElTree.props)),\n    ...attrs,\n    nodeKey: key,\n\n    // only expand on click node when the `check-strictly` is false\n    expandOnClickNode: computed(() => {\n      return !props.checkStrictly && props.expandOnClickNode\n    }),\n\n    // show current selected node only first time,\n    // fix the problem of expanding multiple nodes when checking multiple nodes\n    defaultExpandedKeys: computed(() => {\n      return props.defaultExpandedKeys\n        ? props.defaultExpandedKeys.concat(defaultExpandedParentKeys)\n        : defaultExpandedParentKeys\n    }),\n\n    renderContent: (h, { node, data, store }) => {\n      return h(\n        TreeSelectOption,\n        {\n          value: getNodeValByProp('value', data),\n          label: getNodeValByProp('label', data),\n          disabled: getNodeValByProp('disabled', data),\n          visible: node.visible,\n        },\n        props.renderContent\n          ? () => props.renderContent(h, { node, data, store })\n          : slots.default\n            ? () => slots.default({ node, data, store })\n            : undefined\n      )\n    },\n    filterNodeMethod: (value, data, node) => {\n      if (props.filterNodeMethod)\n        return props.filterNodeMethod(value, data, node)\n      if (!value) return true\n      const regexp = new RegExp(escapeStringRegexp(value), 'i')\n      return regexp.test(getNodeValByProp('label', data) || '')\n    },\n    onNodeClick: (data, node, e) => {\n      attrs.onNodeClick?.(data, node, e)\n\n      // `onCheck` is trigger when `checkOnClickNode`\n      if (props.showCheckbox && props.checkOnClickNode) return\n\n      // now `checkOnClickNode` is false, only no checkbox and `checkStrictly` or `isLeaf`\n      if (!props.showCheckbox && (props.checkStrictly || node.isLeaf)) {\n        if (!getNodeValByProp('disabled', data)) {\n          const option = select.value?.states.options.get(\n            getNodeValByProp('value', data)\n          )\n          select.value?.handleOptionSelect(option)\n        }\n      } else if (props.expandOnClickNode) {\n        e.proxy.handleExpandIconClick()\n      }\n    },\n    onCheck: (data, params) => {\n      // ignore when no checkbox, like only `checkOnClickNode` is true\n      if (!props.showCheckbox) return\n\n      const dataValue = getNodeValByProp('value', data)\n      const dataMap = {}\n      treeEach(\n        [tree.value.store.root],\n        (node) => (dataMap[node.key] = node),\n        (node) => node.childNodes\n      )\n\n      // fix: checkedKeys has not cached keys\n      const uncachedCheckedKeys = params.checkedKeys\n      const cachedKeys = props.multiple\n        ? toValidArray(props.modelValue).filter(\n            (item) => !(item in dataMap) && !uncachedCheckedKeys.includes(item)\n          )\n        : []\n      const checkedKeys = cachedKeys.concat(uncachedCheckedKeys)\n\n      if (props.checkStrictly) {\n        emit(\n          UPDATE_MODEL_EVENT,\n          // Checking for changes may come from `check-on-node-click`\n          props.multiple\n            ? checkedKeys\n            : checkedKeys.includes(dataValue)\n              ? dataValue\n              : undefined\n        )\n      }\n      // only can select leaf node\n      else {\n        if (props.multiple) {\n          const childKeys = getChildCheckedKeys()\n\n          emit(UPDATE_MODEL_EVENT, cachedKeys.concat(childKeys))\n        } else {\n          // select first leaf node when check parent\n          const firstLeaf = treeFind(\n            [data],\n            (data) =>\n              !isValidArray(getNodeValByProp('children', data)) &&\n              !getNodeValByProp('disabled', data),\n            (data) => getNodeValByProp('children', data)\n          )\n          const firstLeafKey = firstLeaf\n            ? getNodeValByProp('value', firstLeaf)\n            : undefined\n\n          // unselect when any child checked\n          const hasCheckedChild =\n            isValidValue(props.modelValue) &&\n            !!treeFind(\n              [data],\n              (data) => getNodeValByProp('value', data) === props.modelValue,\n              (data) => getNodeValByProp('children', data)\n            )\n\n          emit(\n            UPDATE_MODEL_EVENT,\n            firstLeafKey === props.modelValue || hasCheckedChild\n              ? undefined\n              : firstLeafKey\n          )\n        }\n      }\n\n      nextTick(() => {\n        const checkedKeys = toValidArray(props.modelValue)\n        tree.value.setCheckedKeys(checkedKeys)\n\n        attrs.onCheck?.(data, {\n          checkedKeys: tree.value.getCheckedKeys(),\n          checkedNodes: tree.value.getCheckedNodes(),\n          halfCheckedKeys: tree.value.getHalfCheckedKeys(),\n          halfCheckedNodes: tree.value.getHalfCheckedNodes(),\n        })\n      })\n\n      select.value?.focus()\n    },\n\n    onNodeExpand: (data, node, e) => {\n      attrs.onNodeExpand?.(data, node, e)\n      nextTick(() => {\n        if (\n          !props.checkStrictly &&\n          props.lazy &&\n          props.multiple &&\n          node.checked\n        ) {\n          const dataMap = {}\n          const uncachedCheckedKeys = (\n            tree.value as TreeInstance\n          ).getCheckedKeys()\n\n          treeEach(\n            [tree.value.store.root],\n            (node) => (dataMap[node.key] = node),\n            (node) => node.childNodes\n          )\n\n          const cachedKeys = toValidArray(props.modelValue).filter(\n            (item) => !(item in dataMap) && !uncachedCheckedKeys.includes(item)\n          )\n\n          const childKeys = getChildCheckedKeys()\n          emit(UPDATE_MODEL_EVENT, cachedKeys.concat(childKeys))\n        }\n      })\n    },\n    // else\n    cacheOptions,\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}