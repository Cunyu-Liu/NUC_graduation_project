{"ast":null,"code":"import { ref, provide } from 'vue';\nimport { useNamespace } from '../../../../hooks/use-namespace/index.mjs';\nimport { isFunction } from '@vue/shared';\nimport { removeClass, addClass } from '../../../../utils/dom/style.mjs';\nconst dragEventsKey = Symbol(\"dragEvents\");\nfunction useDragNodeHandler({\n  props,\n  ctx,\n  el$,\n  dropIndicator$,\n  store\n}) {\n  const ns = useNamespace(\"tree\");\n  const dragState = ref({\n    showDropIndicator: false,\n    draggingNode: null,\n    dropNode: null,\n    allowDrop: true,\n    dropType: null\n  });\n  const treeNodeDragStart = ({\n    event,\n    treeNode\n  }) => {\n    if (!event.dataTransfer) return;\n    if (isFunction(props.allowDrag) && !props.allowDrag(treeNode.node)) {\n      event.preventDefault();\n      return false;\n    }\n    event.dataTransfer.effectAllowed = \"move\";\n    try {\n      event.dataTransfer.setData(\"text/plain\", \"\");\n    } catch (e) {}\n    dragState.value.draggingNode = treeNode;\n    ctx.emit(\"node-drag-start\", treeNode.node, event);\n  };\n  const treeNodeDragOver = ({\n    event,\n    treeNode\n  }) => {\n    if (!event.dataTransfer) return;\n    const dropNode = treeNode;\n    const oldDropNode = dragState.value.dropNode;\n    if (oldDropNode && oldDropNode.node.id !== dropNode.node.id) {\n      removeClass(oldDropNode.$el, ns.is(\"drop-inner\"));\n    }\n    const draggingNode = dragState.value.draggingNode;\n    if (!draggingNode || !dropNode) return;\n    let dropPrev = true;\n    let dropInner = true;\n    let dropNext = true;\n    let userAllowDropInner = true;\n    if (isFunction(props.allowDrop)) {\n      dropPrev = props.allowDrop(draggingNode.node, dropNode.node, \"prev\");\n      userAllowDropInner = dropInner = props.allowDrop(draggingNode.node, dropNode.node, \"inner\");\n      dropNext = props.allowDrop(draggingNode.node, dropNode.node, \"next\");\n    }\n    event.dataTransfer.dropEffect = dropInner || dropPrev || dropNext ? \"move\" : \"none\";\n    if ((dropPrev || dropInner || dropNext) && (oldDropNode == null ? void 0 : oldDropNode.node.id) !== dropNode.node.id) {\n      if (oldDropNode) {\n        ctx.emit(\"node-drag-leave\", draggingNode.node, oldDropNode.node, event);\n      }\n      ctx.emit(\"node-drag-enter\", draggingNode.node, dropNode.node, event);\n    }\n    if (dropPrev || dropInner || dropNext) {\n      dragState.value.dropNode = dropNode;\n    } else {\n      dragState.value.dropNode = null;\n    }\n    if (dropNode.node.nextSibling === draggingNode.node) {\n      dropNext = false;\n    }\n    if (dropNode.node.previousSibling === draggingNode.node) {\n      dropPrev = false;\n    }\n    if (dropNode.node.contains(draggingNode.node, false)) {\n      dropInner = false;\n    }\n    if (draggingNode.node === dropNode.node || draggingNode.node.contains(dropNode.node)) {\n      dropPrev = false;\n      dropInner = false;\n      dropNext = false;\n    }\n    const dropEl = dropNode.$el;\n    const targetPosition = dropEl.querySelector(`.${ns.be(\"node\", \"content\")}`).getBoundingClientRect();\n    const treePosition = el$.value.getBoundingClientRect();\n    const treeScrollTop = el$.value.scrollTop;\n    let dropType;\n    const prevPercent = dropPrev ? dropInner ? 0.25 : dropNext ? 0.45 : 1 : Number.NEGATIVE_INFINITY;\n    const nextPercent = dropNext ? dropInner ? 0.75 : dropPrev ? 0.55 : 0 : Number.POSITIVE_INFINITY;\n    let indicatorTop = -9999;\n    const distance = event.clientY - targetPosition.top;\n    if (distance < targetPosition.height * prevPercent) {\n      dropType = \"before\";\n    } else if (distance > targetPosition.height * nextPercent) {\n      dropType = \"after\";\n    } else if (dropInner) {\n      dropType = \"inner\";\n    } else {\n      dropType = \"none\";\n    }\n    const iconPosition = dropEl.querySelector(`.${ns.be(\"node\", \"expand-icon\")}`).getBoundingClientRect();\n    const dropIndicator = dropIndicator$.value;\n    if (dropType === \"before\") {\n      indicatorTop = iconPosition.top - treePosition.top + treeScrollTop;\n    } else if (dropType === \"after\") {\n      indicatorTop = iconPosition.bottom - treePosition.top + treeScrollTop;\n    }\n    dropIndicator.style.top = `${indicatorTop}px`;\n    dropIndicator.style.left = `${iconPosition.right - treePosition.left}px`;\n    if (dropType === \"inner\") {\n      addClass(dropEl, ns.is(\"drop-inner\"));\n    } else {\n      removeClass(dropEl, ns.is(\"drop-inner\"));\n    }\n    dragState.value.showDropIndicator = dropType === \"before\" || dropType === \"after\";\n    dragState.value.allowDrop = dragState.value.showDropIndicator || userAllowDropInner;\n    dragState.value.dropType = dropType;\n    ctx.emit(\"node-drag-over\", draggingNode.node, dropNode.node, event);\n  };\n  const treeNodeDragEnd = event => {\n    var _a, _b;\n    const {\n      draggingNode,\n      dropType,\n      dropNode\n    } = dragState.value;\n    event.preventDefault();\n    if (event.dataTransfer) {\n      event.dataTransfer.dropEffect = \"move\";\n    }\n    if ((draggingNode == null ? void 0 : draggingNode.node.data) && dropNode) {\n      const draggingNodeCopy = {\n        data: draggingNode.node.data\n      };\n      if (dropType !== \"none\") {\n        draggingNode.node.remove();\n      }\n      if (dropType === \"before\") {\n        (_a = dropNode.node.parent) == null ? void 0 : _a.insertBefore(draggingNodeCopy, dropNode.node);\n      } else if (dropType === \"after\") {\n        (_b = dropNode.node.parent) == null ? void 0 : _b.insertAfter(draggingNodeCopy, dropNode.node);\n      } else if (dropType === \"inner\") {\n        dropNode.node.insertChild(draggingNodeCopy);\n      }\n      if (dropType !== \"none\") {\n        store.value.registerNode(draggingNodeCopy);\n        if (store.value.key) {\n          draggingNode.node.eachNode(node => {\n            var _a2;\n            (_a2 = store.value.nodesMap[node.data[store.value.key]]) == null ? void 0 : _a2.setChecked(node.checked, !store.value.checkStrictly);\n          });\n        }\n      }\n      removeClass(dropNode.$el, ns.is(\"drop-inner\"));\n      ctx.emit(\"node-drag-end\", draggingNode.node, dropNode.node, dropType, event);\n      if (dropType !== \"none\") {\n        ctx.emit(\"node-drop\", draggingNode.node, dropNode.node, dropType, event);\n      }\n    }\n    if (draggingNode && !dropNode) {\n      ctx.emit(\"node-drag-end\", draggingNode.node, null, dropType, event);\n    }\n    dragState.value.showDropIndicator = false;\n    dragState.value.draggingNode = null;\n    dragState.value.dropNode = null;\n    dragState.value.allowDrop = true;\n  };\n  provide(dragEventsKey, {\n    treeNodeDragStart,\n    treeNodeDragOver,\n    treeNodeDragEnd\n  });\n  return {\n    dragState\n  };\n}\nexport { dragEventsKey, useDragNodeHandler };","map":{"version":3,"names":["dragEventsKey","Symbol","useDragNodeHandler","props","ctx","el$","dropIndicator$","store","ns","useNamespace","dragState","ref","showDropIndicator","draggingNode","dropNode","allowDrop","dropType","treeNodeDragStart","event","treeNode","dataTransfer","isFunction","allowDrag","node","preventDefault","effectAllowed","setData","e","value","emit","treeNodeDragOver","oldDropNode","id","removeClass","$el","is","dropPrev","dropInner","dropNext","userAllowDropInner","dropEffect","nextSibling","previousSibling","contains","dropEl","targetPosition","querySelector","be","getBoundingClientRect","treePosition","treeScrollTop","scrollTop","prevPercent","Number","NEGATIVE_INFINITY","nextPercent","POSITIVE_INFINITY","indicatorTop","distance","clientY","top","height","iconPosition","dropIndicator","bottom","style","left","right","addClass","treeNodeDragEnd","_a","_b","data","draggingNodeCopy","remove","parent","insertBefore","insertAfter","insertChild","registerNode","key","eachNode","_a2","nodesMap","setChecked","checked","checkStrictly","provide"],"sources":["../../../../../../../packages/components/tree/src/model/useDragNode.ts"],"sourcesContent":["import { provide, ref } from 'vue'\nimport { addClass, isFunction, removeClass } from '@element-plus/utils'\nimport { useNamespace } from '@element-plus/hooks'\n\nimport type { InjectionKey, Ref, SetupContext } from 'vue'\nimport type {\n  AllowDragFunction,\n  AllowDropFunction,\n  FakeNode,\n  NodeDropType,\n} from '../tree.type'\nimport type TreeStore from './tree-store'\nimport type Node from './node'\nimport type { treeEmits } from '../tree'\n\nexport interface TreeNode {\n  node: Node\n  $el?: HTMLElement\n}\n\ninterface DragOptions {\n  event: DragEvent\n  treeNode: TreeNode\n}\n\ninterface Props {\n  props: {\n    allowDrag?: AllowDragFunction\n    allowDrop?: AllowDropFunction\n  }\n  ctx: SetupContext<typeof treeEmits>\n  el$: Ref<HTMLElement | null>\n  dropIndicator$: Ref<HTMLElement | null>\n  store: Ref<TreeStore>\n}\n\nexport interface DragEvents {\n  treeNodeDragStart: (options: DragOptions) => void\n  treeNodeDragOver: (options: DragOptions) => void\n  treeNodeDragEnd: (event: DragEvent) => void\n}\n\nexport const dragEventsKey: InjectionKey<DragEvents> = Symbol('dragEvents')\n\nexport function useDragNodeHandler({\n  props,\n  ctx,\n  el$,\n  dropIndicator$,\n  store,\n}: Props) {\n  const ns = useNamespace('tree')\n  const dragState = ref<{\n    allowDrop: boolean\n    dropType: NodeDropType | null\n    draggingNode: TreeNode | null\n    showDropIndicator: boolean\n    dropNode: TreeNode | null\n  }>({\n    showDropIndicator: false,\n    draggingNode: null,\n    dropNode: null,\n    allowDrop: true,\n    dropType: null,\n  })\n\n  const treeNodeDragStart = ({ event, treeNode }: DragOptions) => {\n    if (!event.dataTransfer) return\n    if (isFunction(props.allowDrag) && !props.allowDrag(treeNode.node)) {\n      event.preventDefault()\n      return false\n    }\n    event.dataTransfer.effectAllowed = 'move'\n\n    // wrap in try catch to address IE's error when first param is 'text/plain'\n    try {\n      // setData is required for draggable to work in FireFox\n      // the content has to be '' so dragging a node out of the tree won't open a new tab in FireFox\n      event.dataTransfer.setData('text/plain', '')\n    } catch {}\n    dragState.value.draggingNode = treeNode\n    ctx.emit('node-drag-start', treeNode.node, event)\n  }\n\n  const treeNodeDragOver = ({ event, treeNode }: DragOptions) => {\n    if (!event.dataTransfer) return\n    const dropNode = treeNode\n    const oldDropNode = dragState.value.dropNode\n    if (oldDropNode && oldDropNode.node.id !== dropNode.node.id) {\n      removeClass(oldDropNode.$el!, ns.is('drop-inner'))\n    }\n    const draggingNode = dragState.value.draggingNode\n    if (!draggingNode || !dropNode) return\n\n    let dropPrev = true\n    let dropInner = true\n    let dropNext = true\n    let userAllowDropInner = true\n    if (isFunction(props.allowDrop)) {\n      dropPrev = props.allowDrop(draggingNode.node, dropNode.node, 'prev')\n      userAllowDropInner = dropInner = props.allowDrop(\n        draggingNode.node,\n        dropNode.node,\n        'inner'\n      )\n      dropNext = props.allowDrop(draggingNode.node, dropNode.node, 'next')\n    }\n    event.dataTransfer.dropEffect =\n      dropInner || dropPrev || dropNext ? 'move' : 'none'\n    if (\n      (dropPrev || dropInner || dropNext) &&\n      oldDropNode?.node.id !== dropNode.node.id\n    ) {\n      if (oldDropNode) {\n        ctx.emit('node-drag-leave', draggingNode.node, oldDropNode.node, event)\n      }\n      ctx.emit('node-drag-enter', draggingNode.node, dropNode.node, event)\n    }\n\n    if (dropPrev || dropInner || dropNext) {\n      dragState.value.dropNode = dropNode\n    } else {\n      // Reset dragState.value.dropNode to null when allowDrop is transfer from true to false.(For issue #14704)\n      dragState.value.dropNode = null\n    }\n\n    if (dropNode.node.nextSibling === draggingNode.node) {\n      dropNext = false\n    }\n    if (dropNode.node.previousSibling === draggingNode.node) {\n      dropPrev = false\n    }\n    if (dropNode.node.contains(draggingNode.node, false)) {\n      dropInner = false\n    }\n    if (\n      draggingNode.node === dropNode.node ||\n      draggingNode.node.contains(dropNode.node)\n    ) {\n      dropPrev = false\n      dropInner = false\n      dropNext = false\n    }\n    const dropEl = dropNode.$el!\n\n    // find target node without children, just calc content node height\n    const targetPosition = dropEl\n      .querySelector(`.${ns.be('node', 'content')}`)!\n      .getBoundingClientRect()\n    const treePosition = el$.value!.getBoundingClientRect()\n    const treeScrollTop = el$.value!.scrollTop\n    let dropType: NodeDropType\n    const prevPercent = dropPrev\n      ? dropInner\n        ? 0.25\n        : dropNext\n          ? 0.45\n          : 1\n      : Number.NEGATIVE_INFINITY\n    const nextPercent = dropNext\n      ? dropInner\n        ? 0.75\n        : dropPrev\n          ? 0.55\n          : 0\n      : Number.POSITIVE_INFINITY\n\n    let indicatorTop = -9999\n    const distance = event.clientY - targetPosition.top\n    if (distance < targetPosition.height * prevPercent) {\n      dropType = 'before'\n    } else if (distance > targetPosition.height * nextPercent) {\n      dropType = 'after'\n    } else if (dropInner) {\n      dropType = 'inner'\n    } else {\n      dropType = 'none'\n    }\n\n    const iconPosition = dropEl\n      .querySelector(`.${ns.be('node', 'expand-icon')}`)!\n      .getBoundingClientRect()\n    const dropIndicator = dropIndicator$.value\n    if (dropType === 'before') {\n      indicatorTop = iconPosition.top - treePosition.top + treeScrollTop\n    } else if (dropType === 'after') {\n      indicatorTop = iconPosition.bottom - treePosition.top + treeScrollTop\n    }\n    dropIndicator!.style.top = `${indicatorTop}px`\n    dropIndicator!.style.left = `${iconPosition.right - treePosition.left}px`\n\n    if (dropType === 'inner') {\n      addClass(dropEl, ns.is('drop-inner'))\n    } else {\n      removeClass(dropEl, ns.is('drop-inner'))\n    }\n\n    dragState.value.showDropIndicator =\n      dropType === 'before' || dropType === 'after'\n    dragState.value.allowDrop =\n      dragState.value.showDropIndicator || userAllowDropInner\n    dragState.value.dropType = dropType\n    ctx.emit('node-drag-over', draggingNode.node, dropNode.node, event)\n  }\n\n  const treeNodeDragEnd = (event: DragEvent) => {\n    const { draggingNode, dropType, dropNode } = dragState.value\n    event.preventDefault()\n\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1911486\n    if (event.dataTransfer) {\n      event.dataTransfer.dropEffect = 'move'\n    }\n\n    if (draggingNode?.node.data && dropNode) {\n      const draggingNodeCopy: FakeNode = { data: draggingNode.node.data }\n      if (dropType !== 'none') {\n        draggingNode.node.remove()\n      }\n      if (dropType === 'before') {\n        dropNode.node.parent?.insertBefore(draggingNodeCopy, dropNode.node)\n      } else if (dropType === 'after') {\n        dropNode.node.parent?.insertAfter(draggingNodeCopy, dropNode.node)\n      } else if (dropType === 'inner') {\n        dropNode.node.insertChild(draggingNodeCopy)\n      }\n      if (dropType !== 'none') {\n        store.value.registerNode(draggingNodeCopy as any)\n        if (store.value.key) {\n          //restore checkbox state after dragging\n          draggingNode.node.eachNode((node) => {\n            store.value.nodesMap[node.data[store.value.key]]?.setChecked(\n              node.checked,\n              !store.value.checkStrictly\n            )\n          })\n        }\n      }\n\n      removeClass(dropNode.$el!, ns.is('drop-inner'))\n\n      ctx.emit(\n        'node-drag-end',\n        draggingNode.node,\n        dropNode.node,\n        dropType!,\n        event\n      )\n      if (dropType !== 'none') {\n        ctx.emit(\n          'node-drop',\n          draggingNode.node,\n          dropNode.node,\n          dropType!,\n          event\n        )\n      }\n    }\n    if (draggingNode && !dropNode) {\n      ctx.emit('node-drag-end', draggingNode.node, null, dropType!, event)\n    }\n\n    dragState.value.showDropIndicator = false\n    dragState.value.draggingNode = null\n    dragState.value.dropNode = null\n    dragState.value.allowDrop = true\n  }\n\n  provide(dragEventsKey, {\n    treeNodeDragStart,\n    treeNodeDragOver,\n    treeNodeDragEnd,\n  })\n\n  return {\n    dragState,\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}