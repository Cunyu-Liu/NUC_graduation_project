{"ast":null,"code":"import { getCurrentInstance, computed, watch, onMounted } from 'vue';\nimport { buildProp, definePropType } from '../../utils/vue/props/runtime.mjs';\nimport { isClient } from '@vueuse/core';\nimport { isBoolean } from '../../utils/types.mjs';\nimport { isFunction } from '@vue/shared';\nconst _prop = buildProp({\n  type: definePropType(Boolean),\n  default: null\n});\nconst _event = buildProp({\n  type: definePropType(Function)\n});\nconst createModelToggleComposable = name => {\n  const updateEventKey = `update:${name}`;\n  const updateEventKeyRaw = `onUpdate:${name}`;\n  const useModelToggleEmits2 = [updateEventKey];\n  const useModelToggleProps2 = {\n    [name]: _prop,\n    [updateEventKeyRaw]: _event\n  };\n  const useModelToggle2 = ({\n    indicator,\n    toggleReason,\n    shouldHideWhenRouteChanges,\n    shouldProceed,\n    onShow,\n    onHide\n  }) => {\n    const instance = getCurrentInstance();\n    const {\n      emit\n    } = instance;\n    const props = instance.props;\n    const hasUpdateHandler = computed(() => isFunction(props[updateEventKeyRaw]));\n    const isModelBindingAbsent = computed(() => props[name] === null);\n    const doShow = event => {\n      if (indicator.value === true) {\n        return;\n      }\n      indicator.value = true;\n      if (toggleReason) {\n        toggleReason.value = event;\n      }\n      if (isFunction(onShow)) {\n        onShow(event);\n      }\n    };\n    const doHide = event => {\n      if (indicator.value === false) {\n        return;\n      }\n      indicator.value = false;\n      if (toggleReason) {\n        toggleReason.value = event;\n      }\n      if (isFunction(onHide)) {\n        onHide(event);\n      }\n    };\n    const show = event => {\n      if (props.disabled === true || isFunction(shouldProceed) && !shouldProceed()) return;\n      const shouldEmit = hasUpdateHandler.value && isClient;\n      if (shouldEmit) {\n        emit(updateEventKey, true);\n      }\n      if (isModelBindingAbsent.value || !shouldEmit) {\n        doShow(event);\n      }\n    };\n    const hide = event => {\n      if (props.disabled === true || !isClient) return;\n      const shouldEmit = hasUpdateHandler.value && isClient;\n      if (shouldEmit) {\n        emit(updateEventKey, false);\n      }\n      if (isModelBindingAbsent.value || !shouldEmit) {\n        doHide(event);\n      }\n    };\n    const onChange = val => {\n      if (!isBoolean(val)) return;\n      if (props.disabled && val) {\n        if (hasUpdateHandler.value) {\n          emit(updateEventKey, false);\n        }\n      } else if (indicator.value !== val) {\n        if (val) {\n          doShow();\n        } else {\n          doHide();\n        }\n      }\n    };\n    const toggle = () => {\n      if (indicator.value) {\n        hide();\n      } else {\n        show();\n      }\n    };\n    watch(() => props[name], onChange);\n    if (shouldHideWhenRouteChanges && instance.appContext.config.globalProperties.$route !== void 0) {\n      watch(() => ({\n        ...instance.proxy.$route\n      }), () => {\n        if (shouldHideWhenRouteChanges.value && indicator.value) {\n          hide();\n        }\n      });\n    }\n    onMounted(() => {\n      onChange(props[name]);\n    });\n    return {\n      hide,\n      show,\n      toggle,\n      hasUpdateHandler\n    };\n  };\n  return {\n    useModelToggle: useModelToggle2,\n    useModelToggleProps: useModelToggleProps2,\n    useModelToggleEmits: useModelToggleEmits2\n  };\n};\nconst {\n  useModelToggle,\n  useModelToggleProps,\n  useModelToggleEmits\n} = createModelToggleComposable(\"modelValue\");\nexport { createModelToggleComposable, useModelToggle, useModelToggleEmits, useModelToggleProps };","map":{"version":3,"names":["_prop","buildProp","type","definePropType","Boolean","default","_event","Function","createModelToggleComposable","name","updateEventKey","updateEventKeyRaw","useModelToggleEmits2","useModelToggleProps2","useModelToggle2","useModelToggle","indicator","toggleReason","shouldHideWhenRouteChanges","shouldProceed","onShow","onHide","instance","getCurrentInstance","emit","props","hasUpdateHandler","computed","isFunction","isModelBindingAbsent","doShow","event","value","doHide","show","disabled","shouldEmit","isClient","hide","onChange","val","isBoolean","toggle","watch","appContext","config","globalProperties","$route","proxy","onMounted","useModelToggleProps","useModelToggleEmits"],"sources":["../../../../../packages/hooks/use-model-toggle/index.ts"],"sourcesContent":["import { computed, getCurrentInstance, onMounted, watch } from 'vue'\nimport {\n  buildProp,\n  definePropType,\n  isBoolean,\n  isClient,\n  isFunction,\n} from '@element-plus/utils'\n\nimport type { ExtractPropType } from '@element-plus/utils'\nimport type { RouteLocationNormalizedLoaded } from 'vue-router'\nimport type {\n  ComponentPublicInstance,\n  ExtractPropTypes,\n  ExtractPublicPropTypes,\n  Ref,\n} from 'vue'\n\nconst _prop = buildProp({\n  type: definePropType<boolean | null>(Boolean),\n  default: null,\n} as const)\nconst _event = buildProp({\n  type: definePropType<(val: boolean) => void>(Function),\n} as const)\n\nexport type UseModelTogglePropsRaw<T extends string> = {\n  [K in T]: typeof _prop\n} & {\n  [K in `onUpdate:${T}`]: typeof _event\n}\n\nexport type UseModelTogglePropsGeneric<T extends string> = {\n  [K in T]: ExtractPropType<typeof _prop>\n} & {\n  [K in `onUpdate:${T}`]: ExtractPropType<typeof _event>\n}\n\nexport const createModelToggleComposable = <T extends string>(name: T) => {\n  const updateEventKey = `update:${name}` as const\n  const updateEventKeyRaw = `onUpdate:${name}` as const\n  const useModelToggleEmits = [updateEventKey]\n\n  const useModelToggleProps = {\n    [name]: _prop,\n    [updateEventKeyRaw]: _event,\n  } as UseModelTogglePropsRaw<T>\n\n  const useModelToggle = ({\n    indicator,\n    toggleReason,\n    shouldHideWhenRouteChanges,\n    shouldProceed,\n    onShow,\n    onHide,\n  }: ModelToggleParams) => {\n    const instance = getCurrentInstance()!\n    const { emit } = instance\n    const props = instance.props as UseModelTogglePropsGeneric<T> & {\n      disabled: boolean\n    }\n    const hasUpdateHandler = computed(() =>\n      isFunction(props[updateEventKeyRaw])\n    )\n    // when it matches the default value we say this is absent\n    // though this could be mistakenly passed from the user but we need to rule out that\n    // condition\n    const isModelBindingAbsent = computed(() => props[name] === null)\n\n    const doShow = (event?: Event) => {\n      if (indicator.value === true) {\n        return\n      }\n\n      indicator.value = true\n      if (toggleReason) {\n        toggleReason.value = event\n      }\n      if (isFunction(onShow)) {\n        onShow(event)\n      }\n    }\n\n    const doHide = (event?: Event) => {\n      if (indicator.value === false) {\n        return\n      }\n\n      indicator.value = false\n      if (toggleReason) {\n        toggleReason.value = event\n      }\n      if (isFunction(onHide)) {\n        onHide(event)\n      }\n    }\n\n    const show = (event?: Event) => {\n      if (\n        props.disabled === true ||\n        (isFunction(shouldProceed) && !shouldProceed())\n      )\n        return\n\n      const shouldEmit = hasUpdateHandler.value && isClient\n\n      if (shouldEmit) {\n        emit(updateEventKey, true)\n      }\n\n      if (isModelBindingAbsent.value || !shouldEmit) {\n        doShow(event)\n      }\n    }\n\n    const hide = (event?: Event) => {\n      if (props.disabled === true || !isClient) return\n\n      const shouldEmit = hasUpdateHandler.value && isClient\n\n      if (shouldEmit) {\n        emit(updateEventKey, false)\n      }\n\n      if (isModelBindingAbsent.value || !shouldEmit) {\n        doHide(event)\n      }\n    }\n\n    const onChange = (val: boolean) => {\n      if (!isBoolean(val)) return\n      if (props.disabled && val) {\n        if (hasUpdateHandler.value) {\n          emit(updateEventKey, false)\n        }\n      } else if (indicator.value !== val) {\n        if (val) {\n          doShow()\n        } else {\n          doHide()\n        }\n      }\n    }\n\n    const toggle = () => {\n      if (indicator.value) {\n        hide()\n      } else {\n        show()\n      }\n    }\n\n    watch(() => props[name], onChange)\n\n    if (\n      shouldHideWhenRouteChanges &&\n      instance.appContext.config.globalProperties.$route !== undefined\n    ) {\n      watch(\n        () => ({\n          ...(\n            instance.proxy as ComponentPublicInstance<{\n              $route: RouteLocationNormalizedLoaded\n            }>\n          ).$route,\n        }),\n        () => {\n          if (shouldHideWhenRouteChanges.value && indicator.value) {\n            hide()\n          }\n        }\n      )\n    }\n\n    onMounted(() => {\n      onChange(props[name])\n    })\n\n    return {\n      hide,\n      show,\n      toggle,\n      hasUpdateHandler,\n    }\n  }\n\n  return {\n    useModelToggle,\n    useModelToggleProps,\n    useModelToggleEmits,\n  }\n}\n\nconst { useModelToggle, useModelToggleProps, useModelToggleEmits } =\n  createModelToggleComposable('modelValue')\n\nexport { useModelToggle, useModelToggleEmits, useModelToggleProps }\n\nexport type UseModelToggleProps = ExtractPropTypes<typeof useModelToggleProps>\nexport type UseModelTogglePropsPublic = ExtractPublicPropTypes<\n  typeof useModelToggleProps\n>\n\nexport type ModelToggleParams = {\n  indicator: Ref<boolean>\n  toggleReason?: Ref<Event | undefined>\n  shouldHideWhenRouteChanges?: Ref<boolean>\n  shouldProceed?: () => boolean\n  onShow?: (event?: Event) => void\n  onHide?: (event?: Event) => void\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}