{"ast":null,"code":"import \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport { isFirefox } from '../../../utils/browser.mjs';\nimport { isNumber } from '../../../utils/types.mjs';\nlet hiddenTextarea = void 0;\nconst HIDDEN_STYLE = {\n  height: \"0\",\n  visibility: \"hidden\",\n  overflow: isFirefox() ? \"\" : \"hidden\",\n  position: \"absolute\",\n  \"z-index\": \"-1000\",\n  top: \"0\",\n  right: \"0\"\n};\nconst CONTEXT_STYLE = [\"letter-spacing\", \"line-height\", \"padding-top\", \"padding-bottom\", \"font-family\", \"font-weight\", \"font-size\", \"text-rendering\", \"text-transform\", \"width\", \"text-indent\", \"padding-left\", \"padding-right\", \"border-width\", \"box-sizing\", \"word-break\"];\nconst looseToNumber = val => {\n  const n = Number.parseFloat(val);\n  return Number.isNaN(n) ? val : n;\n};\nfunction calculateNodeStyling(targetElement) {\n  const style = window.getComputedStyle(targetElement);\n  const boxSizing = style.getPropertyValue(\"box-sizing\");\n  const paddingSize = Number.parseFloat(style.getPropertyValue(\"padding-bottom\")) + Number.parseFloat(style.getPropertyValue(\"padding-top\"));\n  const borderSize = Number.parseFloat(style.getPropertyValue(\"border-bottom-width\")) + Number.parseFloat(style.getPropertyValue(\"border-top-width\"));\n  const contextStyle = CONTEXT_STYLE.map(name => [name, style.getPropertyValue(name)]);\n  return {\n    contextStyle,\n    paddingSize,\n    borderSize,\n    boxSizing\n  };\n}\nfunction calcTextareaHeight(targetElement, minRows = 1, maxRows) {\n  var _a, _b;\n  if (!hiddenTextarea) {\n    hiddenTextarea = document.createElement(\"textarea\");\n    ((_a = targetElement.parentNode) != null ? _a : document.body).appendChild(hiddenTextarea);\n  }\n  const {\n    paddingSize,\n    borderSize,\n    boxSizing,\n    contextStyle\n  } = calculateNodeStyling(targetElement);\n  contextStyle.forEach(([key, value]) => hiddenTextarea == null ? void 0 : hiddenTextarea.style.setProperty(key, value));\n  Object.entries(HIDDEN_STYLE).forEach(([key, value]) => hiddenTextarea == null ? void 0 : hiddenTextarea.style.setProperty(key, value, \"important\"));\n  hiddenTextarea.value = targetElement.value || targetElement.placeholder || \"\";\n  let height = hiddenTextarea.scrollHeight;\n  const result = {};\n  if (boxSizing === \"border-box\") {\n    height = height + borderSize;\n  } else if (boxSizing === \"content-box\") {\n    height = height - paddingSize;\n  }\n  hiddenTextarea.value = \"\";\n  const singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;\n  if (isNumber(minRows)) {\n    let minHeight = singleRowHeight * minRows;\n    if (boxSizing === \"border-box\") {\n      minHeight = minHeight + paddingSize + borderSize;\n    }\n    height = Math.max(minHeight, height);\n    result.minHeight = `${minHeight}px`;\n  }\n  if (isNumber(maxRows)) {\n    let maxHeight = singleRowHeight * maxRows;\n    if (boxSizing === \"border-box\") {\n      maxHeight = maxHeight + paddingSize + borderSize;\n    }\n    height = Math.min(maxHeight, height);\n  }\n  result.height = `${height}px`;\n  (_b = hiddenTextarea.parentNode) == null ? void 0 : _b.removeChild(hiddenTextarea);\n  hiddenTextarea = void 0;\n  return result;\n}\nexport { calcTextareaHeight, looseToNumber };","map":{"version":3,"names":["hiddenTextarea","HIDDEN_STYLE","height","visibility","overflow","isFirefox","position","top","right","CONTEXT_STYLE","looseToNumber","val","n","Number","parseFloat","isNaN","calculateNodeStyling","targetElement","style","window","getComputedStyle","boxSizing","getPropertyValue","paddingSize","borderSize","contextStyle","map","name","calcTextareaHeight","minRows","maxRows","_a","_b","document","createElement","parentNode","body","appendChild","forEach","key","value","setProperty","Object","entries","placeholder","scrollHeight","result","singleRowHeight","isNumber","minHeight","Math","max","maxHeight","min","removeChild"],"sources":["../../../../../../packages/components/input/src/utils.ts"],"sourcesContent":["import { isFirefox, isNumber } from '@element-plus/utils'\n\nlet hiddenTextarea: HTMLTextAreaElement | undefined = undefined\n\nconst HIDDEN_STYLE = {\n  height: '0',\n  visibility: 'hidden',\n  overflow: isFirefox() ? '' : 'hidden',\n  position: 'absolute',\n  'z-index': '-1000',\n  top: '0',\n  right: '0',\n}\n\nconst CONTEXT_STYLE = [\n  'letter-spacing',\n  'line-height',\n  'padding-top',\n  'padding-bottom',\n  'font-family',\n  'font-weight',\n  'font-size',\n  'text-rendering',\n  'text-transform',\n  'width',\n  'text-indent',\n  'padding-left',\n  'padding-right',\n  'border-width',\n  'box-sizing',\n  'word-break',\n]\n\ntype NodeStyle = {\n  contextStyle: string[][]\n  boxSizing: string\n  paddingSize: number\n  borderSize: number\n}\n\ntype TextAreaHeight = {\n  height: string\n  minHeight?: string\n}\n\nexport const looseToNumber = (val: any): any => {\n  const n = Number.parseFloat(val)\n  return Number.isNaN(n) ? val : n\n}\n\nfunction calculateNodeStyling(targetElement: Element): NodeStyle {\n  const style = window.getComputedStyle(targetElement)\n\n  const boxSizing = style.getPropertyValue('box-sizing')\n\n  const paddingSize =\n    Number.parseFloat(style.getPropertyValue('padding-bottom')) +\n    Number.parseFloat(style.getPropertyValue('padding-top'))\n\n  const borderSize =\n    Number.parseFloat(style.getPropertyValue('border-bottom-width')) +\n    Number.parseFloat(style.getPropertyValue('border-top-width'))\n\n  const contextStyle = CONTEXT_STYLE.map((name) => [\n    name,\n    style.getPropertyValue(name),\n  ])\n\n  return { contextStyle, paddingSize, borderSize, boxSizing }\n}\n\nexport function calcTextareaHeight(\n  targetElement: HTMLTextAreaElement,\n  minRows = 1,\n  maxRows?: number\n): TextAreaHeight {\n  if (!hiddenTextarea) {\n    hiddenTextarea = document.createElement('textarea')\n    ;(targetElement.parentNode ?? document.body).appendChild(hiddenTextarea)\n  }\n\n  const { paddingSize, borderSize, boxSizing, contextStyle } =\n    calculateNodeStyling(targetElement)\n\n  contextStyle.forEach(([key, value]) =>\n    hiddenTextarea?.style.setProperty(key, value)\n  )\n\n  Object.entries(HIDDEN_STYLE).forEach(([key, value]) =>\n    hiddenTextarea?.style.setProperty(key, value, 'important')\n  )\n\n  hiddenTextarea.value = targetElement.value || targetElement.placeholder || ''\n\n  let height = hiddenTextarea.scrollHeight\n  const result = {} as TextAreaHeight\n\n  if (boxSizing === 'border-box') {\n    height = height + borderSize\n  } else if (boxSizing === 'content-box') {\n    height = height - paddingSize\n  }\n\n  hiddenTextarea.value = ''\n  const singleRowHeight = hiddenTextarea.scrollHeight - paddingSize\n\n  if (isNumber(minRows)) {\n    let minHeight = singleRowHeight * minRows\n    if (boxSizing === 'border-box') {\n      minHeight = minHeight + paddingSize + borderSize\n    }\n    height = Math.max(minHeight, height)\n    result.minHeight = `${minHeight}px`\n  }\n  if (isNumber(maxRows)) {\n    let maxHeight = singleRowHeight * maxRows\n    if (boxSizing === 'border-box') {\n      maxHeight = maxHeight + paddingSize + borderSize\n    }\n    height = Math.min(maxHeight, height)\n  }\n  result.height = `${height}px`\n  hiddenTextarea.parentNode?.removeChild(hiddenTextarea)\n  hiddenTextarea = undefined\n\n  return result\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}