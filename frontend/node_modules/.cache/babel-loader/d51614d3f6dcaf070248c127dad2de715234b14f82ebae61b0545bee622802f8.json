{"ast":null,"code":"import { inject, getCurrentInstance, ref, reactive, onBeforeUnmount, unref } from 'vue';\nimport { carouselContextKey, CAROUSEL_ITEM_NAME } from './constants.mjs';\nimport { debugWarn } from '../../../utils/error.mjs';\nimport { isUndefined } from '../../../utils/types.mjs';\nconst useCarouselItem = props => {\n  const carouselContext = inject(carouselContextKey);\n  const instance = getCurrentInstance();\n  if (!carouselContext) {\n    debugWarn(CAROUSEL_ITEM_NAME, \"usage: <el-carousel></el-carousel-item></el-carousel>\");\n  }\n  if (!instance) {\n    debugWarn(CAROUSEL_ITEM_NAME, \"compositional hook can only be invoked inside setups\");\n  }\n  const carouselItemRef = ref();\n  const hover = ref(false);\n  const translate = ref(0);\n  const scale = ref(1);\n  const active = ref(false);\n  const ready = ref(false);\n  const inStage = ref(false);\n  const animating = ref(false);\n  const {\n    isCardType,\n    isVertical,\n    cardScale\n  } = carouselContext;\n  function processIndex(index, activeIndex, length) {\n    const lastItemIndex = length - 1;\n    const prevItemIndex = activeIndex - 1;\n    const nextItemIndex = activeIndex + 1;\n    const halfItemIndex = length / 2;\n    if (activeIndex === 0 && index === lastItemIndex) {\n      return -1;\n    } else if (activeIndex === lastItemIndex && index === 0) {\n      return length;\n    } else if (index < prevItemIndex && activeIndex - index >= halfItemIndex) {\n      return length + 1;\n    } else if (index > nextItemIndex && index - activeIndex >= halfItemIndex) {\n      return -2;\n    }\n    return index;\n  }\n  function calcCardTranslate(index, activeIndex) {\n    var _a, _b;\n    const parentWidth = unref(isVertical) ? ((_a = carouselContext.root.value) == null ? void 0 : _a.offsetHeight) || 0 : ((_b = carouselContext.root.value) == null ? void 0 : _b.offsetWidth) || 0;\n    if (inStage.value) {\n      return parentWidth * ((2 - cardScale) * (index - activeIndex) + 1) / 4;\n    } else if (index < activeIndex) {\n      return -(1 + cardScale) * parentWidth / 4;\n    } else {\n      return (3 + cardScale) * parentWidth / 4;\n    }\n  }\n  function calcTranslate(index, activeIndex, isVertical2) {\n    const rootEl = carouselContext.root.value;\n    if (!rootEl) return 0;\n    const distance = (isVertical2 ? rootEl.offsetHeight : rootEl.offsetWidth) || 0;\n    return distance * (index - activeIndex);\n  }\n  const translateItem = (index, activeIndex, oldIndex) => {\n    var _a;\n    const _isCardType = unref(isCardType);\n    const carouselItemLength = (_a = carouselContext.items.value.length) != null ? _a : Number.NaN;\n    const isActive = index === activeIndex;\n    if (!_isCardType && !isUndefined(oldIndex)) {\n      animating.value = isActive || index === oldIndex;\n    }\n    if (!isActive && carouselItemLength > 2 && carouselContext.loop) {\n      index = processIndex(index, activeIndex, carouselItemLength);\n    }\n    const _isVertical = unref(isVertical);\n    active.value = isActive;\n    if (_isCardType) {\n      inStage.value = Math.round(Math.abs(index - activeIndex)) <= 1;\n      translate.value = calcCardTranslate(index, activeIndex);\n      scale.value = unref(active) ? 1 : cardScale;\n    } else {\n      translate.value = calcTranslate(index, activeIndex, _isVertical);\n    }\n    ready.value = true;\n    if (isActive && carouselItemRef.value) {\n      carouselContext.setContainerHeight(carouselItemRef.value.offsetHeight);\n    }\n  };\n  function handleItemClick() {\n    if (carouselContext && unref(isCardType)) {\n      const index = carouselContext.items.value.findIndex(({\n        uid\n      }) => uid === instance.uid);\n      carouselContext.setActiveItem(index);\n    }\n  }\n  const carouselItemContext = {\n    props,\n    states: reactive({\n      hover,\n      translate,\n      scale,\n      active,\n      ready,\n      inStage,\n      animating\n    }),\n    uid: instance.uid,\n    getVnode: () => instance.vnode,\n    translateItem\n  };\n  carouselContext.addItem(carouselItemContext);\n  onBeforeUnmount(() => {\n    carouselContext.removeItem(carouselItemContext);\n  });\n  return {\n    carouselItemRef,\n    active,\n    animating,\n    hover,\n    inStage,\n    isVertical,\n    translate,\n    isCardType,\n    scale,\n    ready,\n    handleItemClick\n  };\n};\nexport { useCarouselItem };","map":{"version":3,"names":["useCarouselItem","props","carouselContext","inject","carouselContextKey","instance","getCurrentInstance","debugWarn","CAROUSEL_ITEM_NAME","carouselItemRef","ref","hover","translate","scale","active","ready","inStage","animating","isCardType","isVertical","cardScale","processIndex","index","activeIndex","length","lastItemIndex","prevItemIndex","nextItemIndex","halfItemIndex","calcCardTranslate","_a","_b","parentWidth","unref","root","value","offsetHeight","offsetWidth","calcTranslate","isVertical2","rootEl","distance","translateItem","oldIndex","_isCardType","carouselItemLength","items","Number","NaN","isActive","isUndefined","loop","_isVertical","Math","round","abs","setContainerHeight","handleItemClick","findIndex","uid","setActiveItem","carouselItemContext","states","reactive","getVnode","vnode","addItem","onBeforeUnmount","removeItem"],"sources":["../../../../../../packages/components/carousel/src/use-carousel-item.ts"],"sourcesContent":["import {\n  getCurrentInstance,\n  inject,\n  onBeforeUnmount,\n  reactive,\n  ref,\n  unref,\n} from 'vue'\nimport { debugWarn, isUndefined } from '@element-plus/utils'\nimport { CAROUSEL_ITEM_NAME, carouselContextKey } from './constants'\n\nimport type { CarouselItemProps } from './carousel-item'\n\nexport const useCarouselItem = (props: CarouselItemProps) => {\n  const carouselContext = inject(carouselContextKey)!\n  // instance\n  const instance = getCurrentInstance()!\n  if (!carouselContext) {\n    debugWarn(\n      CAROUSEL_ITEM_NAME,\n      'usage: <el-carousel></el-carousel-item></el-carousel>'\n    )\n  }\n\n  if (!instance) {\n    debugWarn(\n      CAROUSEL_ITEM_NAME,\n      'compositional hook can only be invoked inside setups'\n    )\n  }\n\n  const carouselItemRef = ref<HTMLElement>()\n  const hover = ref(false)\n  const translate = ref(0)\n  const scale = ref(1)\n  const active = ref(false)\n  const ready = ref(false)\n  const inStage = ref(false)\n  const animating = ref(false)\n\n  // computed\n  const { isCardType, isVertical, cardScale } = carouselContext\n\n  // methods\n\n  function processIndex(index: number, activeIndex: number, length: number) {\n    const lastItemIndex = length - 1\n    const prevItemIndex = activeIndex - 1\n    const nextItemIndex = activeIndex + 1\n    const halfItemIndex = length / 2\n\n    if (activeIndex === 0 && index === lastItemIndex) {\n      return -1\n    } else if (activeIndex === lastItemIndex && index === 0) {\n      return length\n    } else if (index < prevItemIndex && activeIndex - index >= halfItemIndex) {\n      return length + 1\n    } else if (index > nextItemIndex && index - activeIndex >= halfItemIndex) {\n      return -2\n    }\n    return index\n  }\n\n  function calcCardTranslate(index: number, activeIndex: number) {\n    const parentWidth = unref(isVertical)\n      ? carouselContext.root.value?.offsetHeight || 0\n      : carouselContext.root.value?.offsetWidth || 0\n\n    if (inStage.value) {\n      return (parentWidth * ((2 - cardScale) * (index - activeIndex) + 1)) / 4\n    } else if (index < activeIndex) {\n      return (-(1 + cardScale) * parentWidth) / 4\n    } else {\n      return ((3 + cardScale) * parentWidth) / 4\n    }\n  }\n\n  function calcTranslate(\n    index: number,\n    activeIndex: number,\n    isVertical: boolean\n  ) {\n    const rootEl = carouselContext.root.value\n    if (!rootEl) return 0\n\n    const distance =\n      (isVertical ? rootEl.offsetHeight : rootEl.offsetWidth) || 0\n    return distance * (index - activeIndex)\n  }\n\n  const translateItem = (\n    index: number,\n    activeIndex: number,\n    oldIndex?: number\n  ) => {\n    const _isCardType = unref(isCardType)\n    const carouselItemLength = carouselContext.items.value.length ?? Number.NaN\n\n    const isActive = index === activeIndex\n    if (!_isCardType && !isUndefined(oldIndex)) {\n      animating.value = isActive || index === oldIndex\n    }\n\n    if (!isActive && carouselItemLength > 2 && carouselContext.loop) {\n      index = processIndex(index, activeIndex, carouselItemLength)\n    }\n\n    const _isVertical = unref(isVertical)\n    active.value = isActive\n\n    if (_isCardType) {\n      inStage.value = Math.round(Math.abs(index - activeIndex)) <= 1\n      translate.value = calcCardTranslate(index, activeIndex)\n      scale.value = unref(active) ? 1 : cardScale\n    } else {\n      translate.value = calcTranslate(index, activeIndex, _isVertical)\n    }\n\n    ready.value = true\n\n    if (isActive && carouselItemRef.value) {\n      carouselContext.setContainerHeight(carouselItemRef.value.offsetHeight)\n    }\n  }\n\n  function handleItemClick() {\n    if (carouselContext && unref(isCardType)) {\n      const index = carouselContext.items.value.findIndex(\n        ({ uid }) => uid === instance.uid\n      )\n      carouselContext.setActiveItem(index)\n    }\n  }\n\n  const carouselItemContext = {\n    props,\n    states: reactive({\n      hover,\n      translate,\n      scale,\n      active,\n      ready,\n      inStage,\n      animating,\n    }),\n    uid: instance.uid,\n    getVnode: () => instance.vnode,\n    translateItem,\n  }\n\n  carouselContext.addItem(carouselItemContext)\n\n  onBeforeUnmount(() => {\n    carouselContext.removeItem(carouselItemContext)\n  })\n\n  return {\n    carouselItemRef,\n    active,\n    animating,\n    hover,\n    inStage,\n    isVertical,\n    translate,\n    isCardType,\n    scale,\n    ready,\n    handleItemClick,\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}