{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.find.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.iterator.reduce.js\";\nimport { isEqual } from 'lodash-unified';\nimport Node from './node.mjs';\nimport { isPropAbsent } from '../../../utils/types.mjs';\nconst flatNodes = (nodes, leafOnly) => {\n  return nodes.reduce((res, node) => {\n    if (node.isLeaf) {\n      res.push(node);\n    } else {\n      !leafOnly && res.push(node);\n      res = res.concat(flatNodes(node.children, leafOnly));\n    }\n    return res;\n  }, []);\n};\nclass Store {\n  constructor(data, config) {\n    this.config = config;\n    const nodes = (data || []).map(nodeData => new Node(nodeData, this.config));\n    this.nodes = nodes;\n    this.allNodes = flatNodes(nodes, false);\n    this.leafNodes = flatNodes(nodes, true);\n  }\n  getNodes() {\n    return this.nodes;\n  }\n  getFlattedNodes(leafOnly) {\n    return leafOnly ? this.leafNodes : this.allNodes;\n  }\n  appendNode(nodeData, parentNode) {\n    const node = parentNode ? parentNode.appendChild(nodeData) : new Node(nodeData, this.config);\n    if (!parentNode) this.nodes.push(node);\n    this.appendAllNodesAndLeafNodes(node);\n  }\n  appendNodes(nodeDataList, parentNode) {\n    if (nodeDataList.length > 0) {\n      nodeDataList.forEach(nodeData => this.appendNode(nodeData, parentNode));\n    } else {\n      parentNode && parentNode.isLeaf && this.leafNodes.push(parentNode);\n    }\n  }\n  appendAllNodesAndLeafNodes(node) {\n    this.allNodes.push(node);\n    node.isLeaf && this.leafNodes.push(node);\n    if (node.children) {\n      node.children.forEach(subNode => {\n        this.appendAllNodesAndLeafNodes(subNode);\n      });\n    }\n  }\n  getNodeByValue(value, leafOnly = false) {\n    if (isPropAbsent(value)) return null;\n    const node = this.getFlattedNodes(leafOnly).find(node2 => isEqual(node2.value, value) || isEqual(node2.pathValues, value));\n    return node || null;\n  }\n  getSameNode(node) {\n    if (!node) return null;\n    const node_ = this.getFlattedNodes(false).find(({\n      value,\n      level\n    }) => isEqual(node.value, value) && node.level === level);\n    return node_ || null;\n  }\n}\nexport { Store as default };","map":{"version":3,"names":["flatNodes","nodes","leafOnly","reduce","res","node","isLeaf","push","concat","children","Store","constructor","data","config","map","nodeData","Node","allNodes","leafNodes","getNodes","getFlattedNodes","appendNode","parentNode","appendChild","appendAllNodesAndLeafNodes","appendNodes","nodeDataList","length","forEach","subNode","getNodeByValue","value","isPropAbsent","find","node2","isEqual","pathValues","getSameNode","node_","level"],"sources":["../../../../../../packages/components/cascader-panel/src/store.ts"],"sourcesContent":["import { isEqual } from 'lodash-unified'\nimport { isPropAbsent } from '@element-plus/utils'\nimport Node from './node'\n\nimport type { Nullable } from '@element-plus/utils'\nimport type {\n  CascaderConfig,\n  CascaderNodePathValue,\n  CascaderNodeValue,\n  CascaderOption,\n} from './types'\n\nconst flatNodes = (nodes: Node[], leafOnly: boolean) => {\n  return nodes.reduce((res, node) => {\n    if (node.isLeaf) {\n      res.push(node)\n    } else {\n      !leafOnly && res.push(node)\n      res = res.concat(flatNodes(node.children, leafOnly))\n    }\n    return res\n  }, [] as Node[])\n}\n\nexport default class Store {\n  readonly nodes: Node[]\n  readonly allNodes: Node[]\n  readonly leafNodes: Node[]\n\n  constructor(\n    data: CascaderOption[],\n    readonly config: CascaderConfig\n  ) {\n    const nodes = (data || []).map(\n      (nodeData) => new Node(nodeData, this.config)\n    )\n    this.nodes = nodes\n    this.allNodes = flatNodes(nodes, false)\n    this.leafNodes = flatNodes(nodes, true)\n  }\n\n  getNodes() {\n    return this.nodes\n  }\n\n  getFlattedNodes(leafOnly: boolean) {\n    return leafOnly ? this.leafNodes : this.allNodes\n  }\n\n  appendNode(nodeData: CascaderOption, parentNode?: Node) {\n    const node = parentNode\n      ? parentNode.appendChild(nodeData)\n      : new Node(nodeData, this.config)\n\n    if (!parentNode) this.nodes.push(node)\n\n    this.appendAllNodesAndLeafNodes(node)\n  }\n\n  appendNodes(nodeDataList: CascaderOption[], parentNode: Node) {\n    if (nodeDataList.length > 0) {\n      nodeDataList.forEach((nodeData) => this.appendNode(nodeData, parentNode))\n    } else {\n      parentNode && parentNode.isLeaf && this.leafNodes.push(parentNode)\n    }\n  }\n\n  appendAllNodesAndLeafNodes(node: Node) {\n    this.allNodes.push(node)\n    node.isLeaf && this.leafNodes.push(node)\n    if (node.children) {\n      node.children.forEach((subNode) => {\n        this.appendAllNodesAndLeafNodes(subNode)\n      })\n    }\n  }\n\n  // when checkStrictly, leaf node first\n  getNodeByValue(\n    value: CascaderNodeValue | CascaderNodePathValue,\n    leafOnly = false\n  ): Nullable<Node> {\n    if (isPropAbsent(value)) return null\n\n    const node = this.getFlattedNodes(leafOnly).find(\n      (node) => isEqual(node.value, value) || isEqual(node.pathValues, value)\n    )\n\n    return node || null\n  }\n\n  getSameNode(node: Node): Nullable<Node> {\n    if (!node) return null\n\n    const node_ = this.getFlattedNodes(false).find(\n      ({ value, level }) => isEqual(node.value, value) && node.level === level\n    )\n\n    return node_ || null\n  }\n}\n"],"mappings":";;;;;;;;;AAYA,MAAMA,SAAA,GAAYA,CAACC,KAAA,EAAeC,QAAsB;EACtD,OAAOD,KAAM,CAAAE,MAAA,CAAO,CAACC,GAAA,EAAKC,IAAS;IACjC,IAAIA,IAAA,CAAKC,MAAQ;MACfF,GAAA,CAAIG,IAAA,CAAKF,IAAI;IAAA,CACR;MACJ,CAAAH,QAAA,IAAYE,GAAI,CAAAG,IAAA,CAAKF,IAAI;MAC1BD,GAAA,GAAMA,GAAA,CAAII,MAAO,CAAAR,SAAA,CAAUK,IAAK,CAAAI,QAAA,EAAUP,QAAQ,CAAC;IAAA;IAE9C,OAAAE,GAAA;EAAA,CACT,EAAG,EAAY;AACjB;AAEA,MAAqBM,KAAM;EAKzBC,YACEC,IAAA,EACSC,MACT;IADS,KAAAA,MAAA,GAAAA,MAAA;IAEH,MAAAZ,KAAA,IAASW,IAAQ,MAAI,EAAAE,GAAA,CACxBC,QAAa,QAAIC,IAAK,CAAAD,QAAA,EAAU,KAAKF,MAAM,EAC9C;IACA,KAAKZ,KAAQ,GAAAA,KAAA;IACR,KAAAgB,QAAA,GAAWjB,SAAU,CAAAC,KAAA,EAAO,KAAK;IACjC,KAAAiB,SAAA,GAAYlB,SAAU,CAAAC,KAAA,EAAO,IAAI;EAAA;EAGxCkB,QAAWA,CAAA;IACT,OAAO,IAAK,CAAAlB,KAAA;EAAA;EAGdmB,gBAAgBlB,QAAmB;IAC1B,OAAAA,QAAA,GAAW,IAAK,CAAAgB,SAAA,GAAY,IAAK,CAAAD,QAAA;EAAA;EAG1CI,WAAWN,QAAA,EAA0BO,UAAmB;IAChD,MAAAjB,IAAA,GAAOiB,UACT,GAAAA,UAAA,CAAWC,WAAY,CAAAR,QAAQ,IAC/B,IAAIC,IAAA,CAAKD,QAAU,OAAKF,MAAM;IAElC,IAAI,CAACS,UAAA,EAAiB,KAAArB,KAAA,CAAMM,IAAA,CAAKF,IAAI;IAErC,KAAKmB,0BAAA,CAA2BnB,IAAI;EAAA;EAGtCoB,YAAYC,YAAA,EAAgCJ,UAAkB;IACxD,IAAAI,YAAA,CAAaC,MAAA,GAAS,CAAG;MAC3BD,YAAA,CAAaE,OAAA,CAASb,QAAA,IAAa,KAAKM,UAAW,CAAAN,QAAA,EAAUO,UAAU,CAAC;IAAA,CACnE;MACLA,UAAA,IAAcA,UAAW,CAAAhB,MAAA,IAAU,IAAK,CAAAY,SAAA,CAAUX,IAAA,CAAKe,UAAU;IAAA;EACnE;EAGFE,2BAA2BnB,IAAY;IAChC,KAAAY,QAAA,CAASV,IAAA,CAAKF,IAAI;IACvBA,IAAA,CAAKC,MAAU,SAAKY,SAAU,CAAAX,IAAA,CAAKF,IAAI;IACvC,IAAIA,IAAA,CAAKI,QAAU;MACZJ,IAAA,CAAAI,QAAA,CAASmB,OAAQ,CAACC,OAAY;QACjC,KAAKL,0BAAA,CAA2BK,OAAO;MAAA,CACxC;IAAA;EACH;EAIFC,eACEC,KACA,EAAA7B,QAAA,GAAW,KACK;IAChB,IAAI8B,YAAA,CAAaD,KAAK,GAAU;IAEhC,MAAM1B,IAAO,QAAKe,eAAgB,CAAAlB,QAAQ,CAAE,CAAA+B,IAAA,CACzCC,KAAS,IAAAC,OAAA,CAAQD,KAAK,CAAAH,KAAA,EAAOA,KAAK,CAAK,IAAAI,OAAA,CAAQD,KAAK,CAAAE,UAAA,EAAYL,KAAK,EACxE;IAEA,OAAO1B,IAAQ;EAAA;EAGjBgC,YAAYhC,IAA4B;IACtC,IAAI,CAACA,IAAA,EAAa;IAElB,MAAMiC,KAAQ,QAAKlB,eAAgB,MAAK,CAAE,CAAAa,IAAA,CACxC,CAAC;MAAEF,KAAA;MAAOQ;IAAM,MAAMJ,OAAQ,CAAA9B,IAAA,CAAK0B,KAAO,EAAAA,KAAK,CAAK,IAAA1B,IAAA,CAAKkC,KAAU,KAAAA,KAAA,CACrE;IAEA,OAAOD,KAAS;EAAA;AAEpB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}