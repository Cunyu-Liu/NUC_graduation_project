{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.find.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.iterator.some.js\";\nimport { getCurrentInstance, toRefs, ref, computed, watch, unref } from 'vue';\nimport { getKeysMap, getRowIdentity, toggleRowStatus, getColumnById, getColumnByKey, orderBy } from '../util.mjs';\nimport useExpand from './expand.mjs';\nimport useCurrent from './current.mjs';\nimport useTree from './tree.mjs';\nimport { hasOwn, isString, isArray } from '@vue/shared';\nimport { castArray } from 'lodash-unified';\nconst sortData = (data, states) => {\n  const sortingColumn = states.sortingColumn;\n  if (!sortingColumn || isString(sortingColumn.sortable)) {\n    return data;\n  }\n  return orderBy(data, states.sortProp, states.sortOrder, sortingColumn.sortMethod, sortingColumn.sortBy);\n};\nconst doFlattenColumns = columns => {\n  const result = [];\n  columns.forEach(column => {\n    if (column.children && column.children.length > 0) {\n      result.push.apply(result, doFlattenColumns(column.children));\n    } else {\n      result.push(column);\n    }\n  });\n  return result;\n};\nfunction useWatcher() {\n  var _a;\n  const instance = getCurrentInstance();\n  const {\n    size: tableSize\n  } = toRefs((_a = instance.proxy) == null ? void 0 : _a.$props);\n  const rowKey = ref(null);\n  const data = ref([]);\n  const _data = ref([]);\n  const isComplex = ref(false);\n  const _columns = ref([]);\n  const originColumns = ref([]);\n  const columns = ref([]);\n  const fixedColumns = ref([]);\n  const rightFixedColumns = ref([]);\n  const leafColumns = ref([]);\n  const fixedLeafColumns = ref([]);\n  const rightFixedLeafColumns = ref([]);\n  const updateOrderFns = [];\n  const leafColumnsLength = ref(0);\n  const fixedLeafColumnsLength = ref(0);\n  const rightFixedLeafColumnsLength = ref(0);\n  const isAllSelected = ref(false);\n  const selection = ref([]);\n  const reserveSelection = ref(false);\n  const selectOnIndeterminate = ref(false);\n  const selectable = ref(null);\n  const filters = ref({});\n  const filteredData = ref(null);\n  const sortingColumn = ref(null);\n  const sortProp = ref(null);\n  const sortOrder = ref(null);\n  const hoverRow = ref(null);\n  const selectedMap = computed(() => {\n    return rowKey.value ? getKeysMap(selection.value, rowKey.value) : void 0;\n  });\n  watch(data, () => {\n    var _a2;\n    if (instance.state) {\n      scheduleLayout(false);\n      const needUpdateFixed = instance.props.tableLayout === \"auto\";\n      if (needUpdateFixed) {\n        (_a2 = instance.refs.tableHeaderRef) == null ? void 0 : _a2.updateFixedColumnStyle();\n      }\n    }\n  }, {\n    deep: true\n  });\n  const assertRowKey = () => {\n    if (!rowKey.value) throw new Error(\"[ElTable] prop row-key is required\");\n  };\n  const updateChildFixed = column => {\n    var _a2;\n    (_a2 = column.children) == null ? void 0 : _a2.forEach(childColumn => {\n      childColumn.fixed = column.fixed;\n      updateChildFixed(childColumn);\n    });\n  };\n  const updateColumns = () => {\n    _columns.value.forEach(column => {\n      updateChildFixed(column);\n    });\n    fixedColumns.value = _columns.value.filter(column => [true, \"left\"].includes(column.fixed));\n    const selectColumn = _columns.value.find(column => column.type === \"selection\");\n    let selectColFixLeft;\n    if (selectColumn && selectColumn.fixed !== \"right\" && !fixedColumns.value.includes(selectColumn)) {\n      const selectColumnIndex = _columns.value.indexOf(selectColumn);\n      if (selectColumnIndex === 0 && fixedColumns.value.length) {\n        fixedColumns.value.unshift(selectColumn);\n        selectColFixLeft = true;\n      }\n    }\n    rightFixedColumns.value = _columns.value.filter(column => column.fixed === \"right\");\n    const notFixedColumns = _columns.value.filter(column => (selectColFixLeft ? column.type !== \"selection\" : true) && !column.fixed);\n    originColumns.value = Array.from(fixedColumns.value).concat(notFixedColumns).concat(rightFixedColumns.value);\n    const leafColumns2 = doFlattenColumns(notFixedColumns);\n    const fixedLeafColumns2 = doFlattenColumns(fixedColumns.value);\n    const rightFixedLeafColumns2 = doFlattenColumns(rightFixedColumns.value);\n    leafColumnsLength.value = leafColumns2.length;\n    fixedLeafColumnsLength.value = fixedLeafColumns2.length;\n    rightFixedLeafColumnsLength.value = rightFixedLeafColumns2.length;\n    columns.value = Array.from(fixedLeafColumns2).concat(leafColumns2).concat(rightFixedLeafColumns2);\n    isComplex.value = fixedColumns.value.length > 0 || rightFixedColumns.value.length > 0;\n  };\n  const scheduleLayout = (needUpdateColumns, immediate = false) => {\n    if (needUpdateColumns) {\n      updateColumns();\n    }\n    if (immediate) {\n      instance.state.doLayout();\n    } else {\n      instance.state.debouncedUpdateLayout();\n    }\n  };\n  const isSelected = row => {\n    if (selectedMap.value) {\n      return !!selectedMap.value[getRowIdentity(row, rowKey.value)];\n    } else {\n      return selection.value.includes(row);\n    }\n  };\n  const clearSelection = () => {\n    isAllSelected.value = false;\n    const oldSelection = selection.value;\n    selection.value = [];\n    if (oldSelection.length) {\n      instance.emit(\"selection-change\", []);\n    }\n  };\n  const cleanSelection = () => {\n    var _a2, _b;\n    let deleted;\n    if (rowKey.value) {\n      deleted = [];\n      const childrenKey = (_b = (_a2 = instance == null ? void 0 : instance.store) == null ? void 0 : _a2.states) == null ? void 0 : _b.childrenColumnName.value;\n      const dataMap = getKeysMap(data.value, rowKey.value, true, childrenKey);\n      for (const key in selectedMap.value) {\n        if (hasOwn(selectedMap.value, key) && !dataMap[key]) {\n          deleted.push(selectedMap.value[key].row);\n        }\n      }\n    } else {\n      deleted = selection.value.filter(item => !data.value.includes(item));\n    }\n    if (deleted.length) {\n      const newSelection = selection.value.filter(item => !deleted.includes(item));\n      selection.value = newSelection;\n      instance.emit(\"selection-change\", newSelection.slice());\n    }\n  };\n  const getSelectionRows = () => {\n    return (selection.value || []).slice();\n  };\n  const toggleRowSelection = (row, selected, emitChange = true, ignoreSelectable = false) => {\n    var _a2, _b, _c, _d;\n    const treeProps = {\n      children: (_b = (_a2 = instance == null ? void 0 : instance.store) == null ? void 0 : _a2.states) == null ? void 0 : _b.childrenColumnName.value,\n      checkStrictly: (_d = (_c = instance == null ? void 0 : instance.store) == null ? void 0 : _c.states) == null ? void 0 : _d.checkStrictly.value\n    };\n    const changed = toggleRowStatus(selection.value, row, selected, treeProps, ignoreSelectable ? void 0 : selectable.value, data.value.indexOf(row), rowKey.value);\n    if (changed) {\n      const newSelection = (selection.value || []).slice();\n      if (emitChange) {\n        instance.emit(\"select\", newSelection, row);\n      }\n      instance.emit(\"selection-change\", newSelection);\n    }\n  };\n  const _toggleAllSelection = () => {\n    var _a2, _b;\n    const value = selectOnIndeterminate.value ? !isAllSelected.value : !(isAllSelected.value || selection.value.length);\n    isAllSelected.value = value;\n    let selectionChanged = false;\n    let childrenCount = 0;\n    const rowKey2 = (_b = (_a2 = instance == null ? void 0 : instance.store) == null ? void 0 : _a2.states) == null ? void 0 : _b.rowKey.value;\n    const {\n      childrenColumnName\n    } = instance.store.states;\n    const treeProps = {\n      children: childrenColumnName.value,\n      checkStrictly: false\n    };\n    data.value.forEach((row, index) => {\n      const rowIndex = index + childrenCount;\n      if (toggleRowStatus(selection.value, row, value, treeProps, selectable.value, rowIndex, rowKey2)) {\n        selectionChanged = true;\n      }\n      childrenCount += getChildrenCount(getRowIdentity(row, rowKey2));\n    });\n    if (selectionChanged) {\n      instance.emit(\"selection-change\", selection.value ? selection.value.slice() : []);\n    }\n    instance.emit(\"select-all\", (selection.value || []).slice());\n  };\n  const updateAllSelected = () => {\n    var _a2;\n    if (((_a2 = data.value) == null ? void 0 : _a2.length) === 0) {\n      isAllSelected.value = false;\n      return;\n    }\n    const {\n      childrenColumnName\n    } = instance.store.states;\n    let rowIndex = 0;\n    let selectedCount = 0;\n    const checkSelectedStatus = data2 => {\n      var _a3;\n      for (const row of data2) {\n        const isRowSelectable = selectable.value && selectable.value.call(null, row, rowIndex);\n        if (!isSelected(row)) {\n          if (!selectable.value || isRowSelectable) {\n            return false;\n          }\n        } else {\n          selectedCount++;\n        }\n        rowIndex++;\n        if (((_a3 = row[childrenColumnName.value]) == null ? void 0 : _a3.length) && !checkSelectedStatus(row[childrenColumnName.value])) {\n          return false;\n        }\n      }\n      return true;\n    };\n    const isAllSelected_ = checkSelectedStatus(data.value || []);\n    isAllSelected.value = selectedCount === 0 ? false : isAllSelected_;\n  };\n  const getChildrenCount = rowKey2 => {\n    var _a2;\n    if (!instance || !instance.store) return 0;\n    const {\n      treeData\n    } = instance.store.states;\n    let count = 0;\n    const children = (_a2 = treeData.value[rowKey2]) == null ? void 0 : _a2.children;\n    if (children) {\n      count += children.length;\n      children.forEach(childKey => {\n        count += getChildrenCount(childKey);\n      });\n    }\n    return count;\n  };\n  const updateFilters = (column, values) => {\n    const filters_ = {};\n    castArray(column).forEach(col => {\n      filters.value[col.id] = values;\n      filters_[col.columnKey || col.id] = values;\n    });\n    return filters_;\n  };\n  const updateSort = (column, prop, order) => {\n    if (sortingColumn.value && sortingColumn.value !== column) {\n      sortingColumn.value.order = null;\n    }\n    sortingColumn.value = column;\n    sortProp.value = prop;\n    sortOrder.value = order;\n  };\n  const execFilter = () => {\n    let sourceData = unref(_data);\n    Object.keys(filters.value).forEach(columnId => {\n      const values = filters.value[columnId];\n      if (!values || values.length === 0) return;\n      const column = getColumnById({\n        columns: columns.value\n      }, columnId);\n      if (column && column.filterMethod) {\n        sourceData = sourceData.filter(row => {\n          return values.some(value => column.filterMethod.call(null, value, row, column));\n        });\n      }\n    });\n    filteredData.value = sourceData;\n  };\n  const execSort = () => {\n    var _a2;\n    data.value = sortData((_a2 = filteredData.value) != null ? _a2 : [], {\n      sortingColumn: sortingColumn.value,\n      sortProp: sortProp.value,\n      sortOrder: sortOrder.value\n    });\n  };\n  const execQuery = (ignore = void 0) => {\n    if (!(ignore == null ? void 0 : ignore.filter)) {\n      execFilter();\n    }\n    execSort();\n  };\n  const clearFilter = columnKeys => {\n    const {\n      tableHeaderRef\n    } = instance.refs;\n    if (!tableHeaderRef) return;\n    const panels = Object.assign({}, tableHeaderRef.filterPanels);\n    const keys = Object.keys(panels);\n    if (!keys.length) return;\n    if (isString(columnKeys)) {\n      columnKeys = [columnKeys];\n    }\n    if (isArray(columnKeys)) {\n      const columns_ = columnKeys.map(key => getColumnByKey({\n        columns: columns.value\n      }, key));\n      keys.forEach(key => {\n        const column = columns_.find(col => col.id === key);\n        if (column) {\n          column.filteredValue = [];\n        }\n      });\n      instance.store.commit(\"filterChange\", {\n        column: columns_,\n        values: [],\n        silent: true,\n        multi: true\n      });\n    } else {\n      keys.forEach(key => {\n        const column = columns.value.find(col => col.id === key);\n        if (column) {\n          column.filteredValue = [];\n        }\n      });\n      filters.value = {};\n      instance.store.commit(\"filterChange\", {\n        column: {},\n        values: [],\n        silent: true\n      });\n    }\n  };\n  const clearSort = () => {\n    if (!sortingColumn.value) return;\n    updateSort(null, null, null);\n    instance.store.commit(\"changeSortCondition\", {\n      silent: true\n    });\n  };\n  const {\n    setExpandRowKeys,\n    toggleRowExpansion,\n    updateExpandRows,\n    states: expandStates,\n    isRowExpanded\n  } = useExpand({\n    data,\n    rowKey\n  });\n  const {\n    updateTreeExpandKeys,\n    toggleTreeExpansion,\n    updateTreeData,\n    updateKeyChildren,\n    loadOrToggle,\n    states: treeStates\n  } = useTree({\n    data,\n    rowKey\n  });\n  const {\n    updateCurrentRowData,\n    updateCurrentRow,\n    setCurrentRowKey,\n    states: currentData\n  } = useCurrent({\n    data,\n    rowKey\n  });\n  const setExpandRowKeysAdapter = val => {\n    setExpandRowKeys(val);\n    updateTreeExpandKeys(val);\n  };\n  const toggleRowExpansionAdapter = (row, expanded) => {\n    const hasExpandColumn = columns.value.some(({\n      type\n    }) => type === \"expand\");\n    if (hasExpandColumn) {\n      toggleRowExpansion(row, expanded);\n    } else {\n      toggleTreeExpansion(row, expanded);\n    }\n  };\n  return {\n    assertRowKey,\n    updateColumns,\n    scheduleLayout,\n    isSelected,\n    clearSelection,\n    cleanSelection,\n    getSelectionRows,\n    toggleRowSelection,\n    _toggleAllSelection,\n    toggleAllSelection: null,\n    updateAllSelected,\n    updateFilters,\n    updateCurrentRow,\n    updateSort,\n    execFilter,\n    execSort,\n    execQuery,\n    clearFilter,\n    clearSort,\n    toggleRowExpansion,\n    setExpandRowKeysAdapter,\n    setCurrentRowKey,\n    toggleRowExpansionAdapter,\n    isRowExpanded,\n    updateExpandRows,\n    updateCurrentRowData,\n    loadOrToggle,\n    updateTreeData,\n    updateKeyChildren,\n    states: {\n      tableSize,\n      rowKey,\n      data,\n      _data,\n      isComplex,\n      _columns,\n      originColumns,\n      columns,\n      fixedColumns,\n      rightFixedColumns,\n      leafColumns,\n      fixedLeafColumns,\n      rightFixedLeafColumns,\n      updateOrderFns,\n      leafColumnsLength,\n      fixedLeafColumnsLength,\n      rightFixedLeafColumnsLength,\n      isAllSelected,\n      selection,\n      reserveSelection,\n      selectOnIndeterminate,\n      selectable,\n      filters,\n      filteredData,\n      sortingColumn,\n      sortProp,\n      sortOrder,\n      hoverRow,\n      ...expandStates,\n      ...treeStates,\n      ...currentData\n    }\n  };\n}\nexport { useWatcher as default };","map":{"version":3,"names":["sortData","data","states","sortingColumn","isString","sortable","orderBy","sortProp","sortOrder","sortMethod","sortBy","doFlattenColumns","columns","result","forEach","column","children","length","push","apply","useWatcher","_a","instance","getCurrentInstance","size","tableSize","toRefs","proxy","$props","rowKey","ref","_data","isComplex","_columns","originColumns","fixedColumns","rightFixedColumns","leafColumns","fixedLeafColumns","rightFixedLeafColumns","updateOrderFns","leafColumnsLength","fixedLeafColumnsLength","rightFixedLeafColumnsLength","isAllSelected","selection","reserveSelection","selectOnIndeterminate","selectable","filters","filteredData","hoverRow","selectedMap","computed","value","getKeysMap","watch","_a2","state","scheduleLayout","needUpdateFixed","props","tableLayout","refs","tableHeaderRef","updateFixedColumnStyle","deep","assertRowKey","Error","updateChildFixed","childColumn","fixed","updateColumns","filter","includes","selectColumn","find","type","selectColFixLeft","selectColumnIndex","indexOf","unshift","notFixedColumns","Array","from","concat","leafColumns2","fixedLeafColumns2","rightFixedLeafColumns2","needUpdateColumns","immediate","doLayout","debouncedUpdateLayout","isSelected","row","getRowIdentity","clearSelection","oldSelection","emit","cleanSelection","_b","deleted","childrenKey","store","childrenColumnName","dataMap","key","hasOwn","item","newSelection","slice","getSelectionRows","toggleRowSelection","selected","emitChange","ignoreSelectable","_c","_d","treeProps","checkStrictly","changed","toggleRowStatus","_toggleAllSelection","selectionChanged","childrenCount","rowKey2","index","rowIndex","getChildrenCount","updateAllSelected","selectedCount","checkSelectedStatus","data2","_a3","isRowSelectable","call","isAllSelected_","treeData","count","childKey","updateFilters","values","filters_","castArray","col","id","columnKey","updateSort","prop","order","execFilter","sourceData","unref","Object","keys","columnId","getColumnById","filterMethod","some","execSort","execQuery","ignore","clearFilter","columnKeys","panels","assign","filterPanels","isArray","columns_","map","getColumnByKey","filteredValue","commit","silent","multi","clearSort","setExpandRowKeys","toggleRowExpansion","updateExpandRows","expandStates","isRowExpanded","useExpand","updateTreeExpandKeys","toggleTreeExpansion","updateTreeData","updateKeyChildren","loadOrToggle","treeStates","useTree","updateCurrentRowData","updateCurrentRow","setCurrentRowKey","currentData","useCurrent","setExpandRowKeysAdapter","val","toggleRowExpansionAdapter","expanded","hasExpandColumn","toggleAllSelection"],"sources":["../../../../../../../packages/components/table/src/store/watcher.ts"],"sourcesContent":["import { computed, getCurrentInstance, ref, toRefs, unref, watch } from 'vue'\nimport { ensureArray, hasOwn, isArray, isString } from '@element-plus/utils'\nimport {\n  getColumnById,\n  getColumnByKey,\n  getKeysMap,\n  getRowIdentity,\n  orderBy,\n  toggleRowStatus,\n} from '../util'\nimport useExpand from './expand'\nimport useCurrent from './current'\nimport useTree from './tree'\n\nimport type { Ref } from 'vue'\nimport type { TableColumnCtx } from '../table-column/defaults'\nimport type {\n  DefaultRow,\n  Table,\n  TableRefs,\n  TableSortOrder,\n} from '../table/defaults'\nimport type { StoreFilter } from '.'\n\nconst sortData = <T extends DefaultRow>(\n  data: T[],\n  states: {\n    sortingColumn: TableColumnCtx<T> | null\n    sortProp: string | null\n    sortOrder: string | number | null\n  }\n) => {\n  const sortingColumn = states.sortingColumn\n  if (!sortingColumn || isString(sortingColumn.sortable)) {\n    return data\n  }\n  return orderBy(\n    data,\n    states.sortProp,\n    states.sortOrder,\n    sortingColumn.sortMethod,\n    sortingColumn.sortBy\n  )\n}\n\nconst doFlattenColumns = <T extends DefaultRow>(\n  columns: TableColumnCtx<T>[]\n) => {\n  const result: TableColumnCtx<T>[] = []\n  columns.forEach((column) => {\n    if (column.children && column.children.length > 0) {\n      // eslint-disable-next-line prefer-spread\n      result.push.apply(result, doFlattenColumns(column.children))\n    } else {\n      result.push(column)\n    }\n  })\n  return result\n}\n\nfunction useWatcher<T extends DefaultRow>() {\n  const instance = getCurrentInstance() as Table<T>\n  const { size: tableSize } = toRefs(instance.proxy?.$props as any)\n  const rowKey: Ref<string | null> = ref(null)\n  const data: Ref<T[]> = ref([])\n  const _data: Ref<T[]> = ref([])\n  const isComplex = ref(false)\n  const _columns: Ref<TableColumnCtx<T>[]> = ref([])\n  const originColumns: Ref<TableColumnCtx<T>[]> = ref([])\n  const columns: Ref<TableColumnCtx<T>[]> = ref([])\n  const fixedColumns: Ref<TableColumnCtx<T>[]> = ref([])\n  const rightFixedColumns: Ref<TableColumnCtx<T>[]> = ref([])\n  const leafColumns: Ref<TableColumnCtx<T>[]> = ref([])\n  const fixedLeafColumns: Ref<TableColumnCtx<T>[]> = ref([])\n  const rightFixedLeafColumns: Ref<TableColumnCtx<T>[]> = ref([])\n  const updateOrderFns: (() => void)[] = []\n  const leafColumnsLength = ref(0)\n  const fixedLeafColumnsLength = ref(0)\n  const rightFixedLeafColumnsLength = ref(0)\n  const isAllSelected = ref(false)\n  const selection: Ref<T[]> = ref([])\n  const reserveSelection = ref(false)\n  const selectOnIndeterminate = ref(false)\n  const selectable: Ref<((row: T, index: number) => boolean) | null> = ref(null)\n  const filters: Ref<StoreFilter> = ref({})\n  const filteredData: Ref<T[] | null> = ref(null)\n  const sortingColumn: Ref<TableColumnCtx<T> | null> = ref(null)\n  const sortProp: Ref<string | null> = ref(null)\n  const sortOrder: Ref<string | number | null> = ref(null)\n  const hoverRow: Ref<T | null> = ref(null)\n\n  const selectedMap = computed(() => {\n    return rowKey.value ? getKeysMap(selection.value, rowKey.value) : undefined\n  })\n\n  watch(\n    data,\n    () => {\n      if (instance.state) {\n        scheduleLayout(false)\n        const needUpdateFixed = instance.props.tableLayout === 'auto'\n        if (needUpdateFixed) {\n          instance.refs.tableHeaderRef?.updateFixedColumnStyle()\n        }\n      }\n    },\n    {\n      deep: true,\n    }\n  )\n\n  // 检查 rowKey 是否存在\n  const assertRowKey = () => {\n    if (!rowKey.value) throw new Error('[ElTable] prop row-key is required')\n  }\n\n  // 更新 fixed\n  const updateChildFixed = (column: TableColumnCtx<T>) => {\n    column.children?.forEach((childColumn) => {\n      childColumn.fixed = column.fixed\n      updateChildFixed(childColumn)\n    })\n  }\n\n  // 更新列\n  const updateColumns = () => {\n    _columns.value.forEach((column) => {\n      updateChildFixed(column)\n    })\n    fixedColumns.value = _columns.value.filter((column) =>\n      [true, 'left'].includes(column.fixed)\n    )\n\n    const selectColumn = _columns.value.find(\n      (column) => column.type === 'selection'\n    )\n\n    let selectColFixLeft: boolean\n    if (\n      selectColumn &&\n      selectColumn.fixed !== 'right' &&\n      !fixedColumns.value.includes(selectColumn)\n    ) {\n      const selectColumnIndex = _columns.value.indexOf(selectColumn)\n      if (selectColumnIndex === 0 && fixedColumns.value.length) {\n        fixedColumns.value.unshift(selectColumn)\n        selectColFixLeft = true\n      }\n    }\n\n    rightFixedColumns.value = _columns.value.filter(\n      (column) => column.fixed === 'right'\n    )\n\n    const notFixedColumns = _columns.value.filter(\n      (column) =>\n        (selectColFixLeft ? column.type !== 'selection' : true) && !column.fixed\n    )\n\n    originColumns.value = Array.from(fixedColumns.value)\n      .concat(notFixedColumns)\n      .concat(rightFixedColumns.value)\n    const leafColumns = doFlattenColumns(notFixedColumns)\n    const fixedLeafColumns = doFlattenColumns(fixedColumns.value)\n    const rightFixedLeafColumns = doFlattenColumns(rightFixedColumns.value)\n\n    leafColumnsLength.value = leafColumns.length\n    fixedLeafColumnsLength.value = fixedLeafColumns.length\n    rightFixedLeafColumnsLength.value = rightFixedLeafColumns.length\n\n    columns.value = Array.from(fixedLeafColumns)\n      .concat(leafColumns)\n      .concat(rightFixedLeafColumns)\n    isComplex.value =\n      fixedColumns.value.length > 0 || rightFixedColumns.value.length > 0\n  }\n\n  // 更新 DOM\n  const scheduleLayout = (needUpdateColumns?: boolean, immediate = false) => {\n    if (needUpdateColumns) {\n      updateColumns()\n    }\n    if (immediate) {\n      instance.state.doLayout()\n    } else {\n      instance.state.debouncedUpdateLayout()\n    }\n  }\n\n  // 选择\n  const isSelected = (row: T) => {\n    if (selectedMap.value) {\n      return !!selectedMap.value[getRowIdentity(row, rowKey.value)]\n    } else {\n      return selection.value.includes(row)\n    }\n  }\n\n  const clearSelection = () => {\n    isAllSelected.value = false\n    const oldSelection = selection.value\n    selection.value = []\n    if (oldSelection.length) {\n      instance.emit('selection-change', [])\n    }\n  }\n\n  const cleanSelection = () => {\n    let deleted\n    if (rowKey.value) {\n      deleted = []\n      const childrenKey = instance?.store?.states?.childrenColumnName.value\n      const dataMap = getKeysMap(data.value, rowKey.value, true, childrenKey)\n      for (const key in selectedMap.value) {\n        if (hasOwn(selectedMap.value, key) && !dataMap[key]) {\n          deleted.push(selectedMap.value[key].row)\n        }\n      }\n    } else {\n      deleted = selection.value.filter((item) => !data.value.includes(item))\n    }\n    if (deleted.length) {\n      const newSelection = selection.value.filter(\n        (item) => !deleted.includes(item)\n      )\n      selection.value = newSelection\n      instance.emit('selection-change', newSelection.slice())\n    }\n  }\n\n  const getSelectionRows = () => {\n    return (selection.value || []).slice()\n  }\n\n  const toggleRowSelection = (\n    row: T,\n    selected?: boolean,\n    emitChange = true,\n    ignoreSelectable = false\n  ) => {\n    const treeProps = {\n      children: instance?.store?.states?.childrenColumnName.value,\n      checkStrictly: instance?.store?.states?.checkStrictly.value,\n    }\n    const changed = toggleRowStatus(\n      selection.value,\n      row,\n      selected,\n      treeProps,\n      ignoreSelectable ? undefined : selectable.value,\n      data.value.indexOf(row),\n      rowKey.value\n    )\n    if (changed) {\n      const newSelection = (selection.value || []).slice()\n      // 调用 API 修改选中值，不触发 select 事件\n      if (emitChange) {\n        instance.emit('select', newSelection, row)\n      }\n      instance.emit('selection-change', newSelection)\n    }\n  }\n\n  const _toggleAllSelection = () => {\n    // when only some rows are selected (but not all), select or deselect all of them\n    // depending on the value of selectOnIndeterminate\n    const value = selectOnIndeterminate.value\n      ? !isAllSelected.value\n      : !(isAllSelected.value || selection.value.length)\n    isAllSelected.value = value\n\n    let selectionChanged = false\n    let childrenCount = 0\n    const rowKey = instance?.store?.states?.rowKey.value\n    const { childrenColumnName } = instance.store.states\n    const treeProps = {\n      children: childrenColumnName.value,\n      checkStrictly: false, // Disable checkStrictly when selecting all\n    }\n\n    data.value.forEach((row, index) => {\n      const rowIndex = index + childrenCount\n      if (\n        toggleRowStatus(\n          selection.value,\n          row,\n          value,\n          treeProps,\n          selectable.value,\n          rowIndex,\n          rowKey\n        )\n      ) {\n        selectionChanged = true\n      }\n      childrenCount += getChildrenCount(getRowIdentity(row, rowKey))\n    })\n\n    if (selectionChanged) {\n      instance.emit(\n        'selection-change',\n        selection.value ? selection.value.slice() : []\n      )\n    }\n    instance.emit('select-all', (selection.value || []).slice())\n  }\n\n  const updateAllSelected = () => {\n    // data 为 null 时，解构时的默认值会被忽略\n    if (data.value?.length === 0) {\n      isAllSelected.value = false\n      return\n    }\n\n    const { childrenColumnName } = instance.store.states\n    let rowIndex = 0\n    let selectedCount = 0\n\n    const checkSelectedStatus = (data: T[]) => {\n      for (const row of data) {\n        const isRowSelectable =\n          selectable.value && selectable.value.call(null, row, rowIndex)\n\n        if (!isSelected(row)) {\n          if (!selectable.value || isRowSelectable) {\n            return false\n          }\n        } else {\n          selectedCount++\n        }\n        rowIndex++\n\n        if (\n          row[childrenColumnName.value]?.length &&\n          !checkSelectedStatus(row[childrenColumnName.value])\n        ) {\n          return false\n        }\n      }\n      return true\n    }\n\n    const isAllSelected_ = checkSelectedStatus(data.value || [])\n    isAllSelected.value = selectedCount === 0 ? false : isAllSelected_\n  }\n\n  const getChildrenCount = (rowKey: string) => {\n    if (!instance || !instance.store) return 0\n    const { treeData } = instance.store.states\n    let count = 0\n    const children = treeData.value[rowKey]?.children\n    if (children) {\n      count += children.length\n      children.forEach((childKey) => {\n        count += getChildrenCount(childKey)\n      })\n    }\n    return count\n  }\n\n  // 过滤与排序\n  const updateFilters = (column: TableColumnCtx<T>, values: string[]) => {\n    const filters_: Record<string, string[]> = {}\n    ensureArray(column).forEach((col) => {\n      filters.value[col.id] = values\n      filters_[col.columnKey || col.id] = values\n    })\n    return filters_\n  }\n\n  const updateSort = (\n    column: TableColumnCtx<T> | null,\n    prop: string | null,\n    order: TableSortOrder | null\n  ) => {\n    if (sortingColumn.value && sortingColumn.value !== column) {\n      sortingColumn.value.order = null\n    }\n    sortingColumn.value = column\n    sortProp.value = prop\n    sortOrder.value = order\n  }\n\n  const execFilter = () => {\n    let sourceData = unref(_data)\n    Object.keys(filters.value).forEach((columnId) => {\n      const values = filters.value[columnId]\n      if (!values || values.length === 0) return\n      const column = getColumnById(\n        {\n          columns: columns.value,\n        },\n        columnId\n      )\n      if (column && column.filterMethod) {\n        sourceData = sourceData.filter((row) => {\n          return values.some((value) =>\n            column.filterMethod.call(null, value, row, column)\n          )\n        })\n      }\n    })\n    filteredData.value = sourceData\n  }\n\n  const execSort = () => {\n    data.value = sortData(filteredData.value ?? [], {\n      sortingColumn: sortingColumn.value,\n      sortProp: sortProp.value,\n      sortOrder: sortOrder.value,\n    })\n  }\n\n  // 根据 filters 与 sort 去过滤 data\n  const execQuery = (ignore: { filter: boolean } | undefined = undefined) => {\n    if (!ignore?.filter) {\n      execFilter()\n    }\n    execSort()\n  }\n\n  const clearFilter = (columnKeys?: string[] | string) => {\n    const { tableHeaderRef } = instance.refs as TableRefs\n    if (!tableHeaderRef) return\n    const panels = Object.assign({}, tableHeaderRef.filterPanels)\n\n    const keys = Object.keys(panels)\n    if (!keys.length) return\n\n    if (isString(columnKeys)) {\n      columnKeys = [columnKeys]\n    }\n\n    if (isArray(columnKeys)) {\n      const columns_ = columnKeys.map((key) =>\n        getColumnByKey(\n          {\n            columns: columns.value,\n          },\n          key\n        )\n      )\n      keys.forEach((key) => {\n        const column = columns_.find((col) => col.id === key)\n        if (column) {\n          column.filteredValue = []\n        }\n      })\n      instance.store.commit('filterChange', {\n        column: columns_,\n        values: [],\n        silent: true,\n        multi: true,\n      })\n    } else {\n      keys.forEach((key) => {\n        const column = columns.value.find((col) => col.id === key)\n        if (column) {\n          column.filteredValue = []\n        }\n      })\n\n      filters.value = {}\n      instance.store.commit('filterChange', {\n        column: {},\n        values: [],\n        silent: true,\n      })\n    }\n  }\n\n  const clearSort = () => {\n    if (!sortingColumn.value) return\n\n    updateSort(null, null, null)\n    instance.store.commit('changeSortCondition', {\n      silent: true,\n    })\n  }\n  const {\n    setExpandRowKeys,\n    toggleRowExpansion,\n    updateExpandRows,\n    states: expandStates,\n    isRowExpanded,\n  } = useExpand({\n    data,\n    rowKey,\n  })\n  const {\n    updateTreeExpandKeys,\n    toggleTreeExpansion,\n    updateTreeData,\n    updateKeyChildren,\n    loadOrToggle,\n    states: treeStates,\n  } = useTree({\n    data,\n    rowKey,\n  })\n  const {\n    updateCurrentRowData,\n    updateCurrentRow,\n    setCurrentRowKey,\n    states: currentData,\n  } = useCurrent({\n    data,\n    rowKey,\n  })\n  // 适配层，expand-row-keys 在 Expand 与 TreeTable 中都有使用\n  const setExpandRowKeysAdapter = (val: string[]) => {\n    // 这里会触发额外的计算，但为了兼容性，暂时这么做\n    setExpandRowKeys(val)\n    updateTreeExpandKeys(val)\n  }\n\n  // 展开行与 TreeTable 都要使用\n  const toggleRowExpansionAdapter = (row: T, expanded?: boolean) => {\n    const hasExpandColumn = columns.value.some(({ type }) => type === 'expand')\n    if (hasExpandColumn) {\n      toggleRowExpansion(row, expanded)\n    } else {\n      toggleTreeExpansion(row, expanded)\n    }\n  }\n\n  return {\n    assertRowKey,\n    updateColumns,\n    scheduleLayout,\n    isSelected,\n    clearSelection,\n    cleanSelection,\n    getSelectionRows,\n    toggleRowSelection,\n    _toggleAllSelection,\n    toggleAllSelection: null as (() => void) | null,\n    updateAllSelected,\n    updateFilters,\n    updateCurrentRow,\n    updateSort,\n    execFilter,\n    execSort,\n    execQuery,\n    clearFilter,\n    clearSort,\n    toggleRowExpansion,\n    setExpandRowKeysAdapter,\n    setCurrentRowKey,\n    toggleRowExpansionAdapter,\n    isRowExpanded,\n    updateExpandRows,\n    updateCurrentRowData,\n    loadOrToggle,\n    updateTreeData,\n    updateKeyChildren,\n    states: {\n      tableSize,\n      rowKey,\n      data,\n      _data,\n      isComplex,\n      _columns,\n      originColumns,\n      columns,\n      fixedColumns,\n      rightFixedColumns,\n      leafColumns,\n      fixedLeafColumns,\n      rightFixedLeafColumns,\n      updateOrderFns,\n      leafColumnsLength,\n      fixedLeafColumnsLength,\n      rightFixedLeafColumnsLength,\n      isAllSelected,\n      selection,\n      reserveSelection,\n      selectOnIndeterminate,\n      selectable,\n      filters,\n      filteredData,\n      sortingColumn,\n      sortProp,\n      sortOrder,\n      hoverRow,\n      ...expandStates,\n      ...treeStates,\n      ...currentData,\n    },\n  }\n}\n\nexport default useWatcher\n"],"mappings":";;;;;;;;;;;;;;AAwBA,MAAMA,QAAA,GAAWA,CACfC,IAAA,EACAC,MAKG;EACH,MAAMC,aAAA,GAAgBD,MAAO,CAAAC,aAAA;EAC7B,IAAI,CAACA,aAAA,IAAiBC,QAAS,CAAAD,aAAA,CAAcE,QAAQ,CAAG;IAC/C,OAAAJ,IAAA;EAAA;EAEF,OAAAK,OAAA,CACLL,IAAA,EACAC,MAAO,CAAAK,QAAA,EACPL,MAAO,CAAAM,SAAA,EACPL,aAAc,CAAAM,UAAA,EACdN,aAAc,CAAAO,MAAA,CAChB;AACF;AAEA,MAAMC,gBAAA,GACJC,OACG;EACH,MAAMC,MAAA,GAA8B,EAAC;EAC7BD,OAAA,CAAAE,OAAA,CAASC,MAAW;IAC1B,IAAIA,MAAO,CAAAC,QAAA,IAAYD,MAAO,CAAAC,QAAA,CAASC,MAAA,GAAS,CAAG;MAEjDJ,MAAA,CAAOK,IAAA,CAAKC,KAAM,CAAAN,MAAA,EAAQF,gBAAiB,CAAAI,MAAA,CAAOC,QAAQ,CAAC;IAAA,CACtD;MACLH,MAAA,CAAOK,IAAA,CAAKH,MAAM;IAAA;EACpB,CACD;EACM,OAAAF,MAAA;AACT;AAEA,SAASO,UAAmCA,CAAA;EA5D5C,IAAAC,EAAA;EA6DE,MAAMC,QAAA,GAAWC,kBAAmB;EAC9B;IAAEC,IAAA,EAAMC;EAAU,IAAIC,MAAA,EAAOL,EAAS,GAAAC,QAAA,CAAAK,KAAA,KAAT,gBAAAN,EAAA,CAAgBO,MAAa;EAC1D,MAAAC,MAAA,GAA6BC,GAAA,CAAI,IAAI;EACrC,MAAA7B,IAAA,GAAiB6B,GAAI,GAAE;EACvB,MAAAC,KAAA,GAAkBD,GAAI,GAAE;EACxB,MAAAE,SAAA,GAAYF,GAAA,CAAI,KAAK;EACrB,MAAAG,QAAA,GAAqCH,GAAI,GAAE;EAC3C,MAAAI,aAAA,GAA0CJ,GAAI,GAAE;EAChD,MAAAlB,OAAA,GAAoCkB,GAAI,GAAE;EAC1C,MAAAK,YAAA,GAAyCL,GAAI,GAAE;EAC/C,MAAAM,iBAAA,GAA8CN,GAAI,GAAE;EACpD,MAAAO,WAAA,GAAwCP,GAAI,GAAE;EAC9C,MAAAQ,gBAAA,GAA6CR,GAAI,GAAE;EACnD,MAAAS,qBAAA,GAAkDT,GAAI,GAAE;EAC9D,MAAMU,cAAA,GAAiC,EAAC;EAClC,MAAAC,iBAAA,GAAoBX,GAAA,CAAI,CAAC;EACzB,MAAAY,sBAAA,GAAyBZ,GAAA,CAAI,CAAC;EAC9B,MAAAa,2BAAA,GAA8Bb,GAAA,CAAI,CAAC;EACnC,MAAAc,aAAA,GAAgBd,GAAA,CAAI,KAAK;EACzB,MAAAe,SAAA,GAAsBf,GAAI,GAAE;EAC5B,MAAAgB,gBAAA,GAAmBhB,GAAA,CAAI,KAAK;EAC5B,MAAAiB,qBAAA,GAAwBjB,GAAA,CAAI,KAAK;EACjC,MAAAkB,UAAA,GAA+DlB,GAAA,CAAI,IAAI;EACvE,MAAAmB,OAAA,GAA4BnB,GAAI,GAAE;EAClC,MAAAoB,YAAA,GAAgCpB,GAAA,CAAI,IAAI;EACxC,MAAA3B,aAAA,GAA+C2B,GAAA,CAAI,IAAI;EACvD,MAAAvB,QAAA,GAA+BuB,GAAA,CAAI,IAAI;EACvC,MAAAtB,SAAA,GAAyCsB,GAAA,CAAI,IAAI;EACjD,MAAAqB,QAAA,GAA0BrB,GAAA,CAAI,IAAI;EAElC,MAAAsB,WAAA,GAAcC,QAAA,CAAS,MAAM;IACjC,OAAOxB,MAAA,CAAOyB,KAAQ,GAAAC,UAAA,CAAWV,SAAA,CAAUS,KAAO,EAAAzB,MAAA,CAAOyB,KAAK,CAAI;EAAA,CACnE;EAEDE,KAAA,CACEvD,IAAA,EACA,MAAM;IAjGV,IAAAwD,GAAA;IAkGM,IAAInC,QAAA,CAASoC,KAAO;MAClBC,cAAA,CAAe,KAAK;MACd,MAAAC,eAAA,GAAkBtC,QAAS,CAAAuC,KAAA,CAAMC,WAAgB;MACvD,IAAIF,eAAiB;QACnB,CAAAH,GAAA,GAAAnC,QAAA,CAASyC,IAAK,CAAAC,cAAA,KAAd,gBAAAP,GAA8B,CAAAQ,sBAAA;MAAA;IAChC;EACF,CACF,EACA;IACEC,IAAM;EAAA,CACR,CACF;EAGA,MAAMC,YAAA,GAAeA,CAAA,KAAM;IACzB,IAAI,CAACtC,MAAO,CAAAyB,KAAA,EAAa,UAAIc,KAAA,CAAM,oCAAoC;EAAA,CACzE;EAGM,MAAAC,gBAAA,GAAoBtD,MAA8B;IArH1D,IAAA0C,GAAA;IAsHI,CAAAA,GAAA,GAAA1C,MAAO,CAAAC,QAAA,KAAP,gBAAAyC,GAAiB,CAAA3C,OAAA,CAASwD,WAAgB;MACxCA,WAAA,CAAYC,KAAA,GAAQxD,MAAO,CAAAwD,KAAA;MAC3BF,gBAAA,CAAiBC,WAAW;IAAA,CAC9B;EAAA,CACF;EAGA,MAAME,aAAA,GAAgBA,CAAA,KAAM;IACjBvC,QAAA,CAAAqB,KAAA,CAAMxC,OAAQ,CAACC,MAAW;MACjCsD,gBAAA,CAAiBtD,MAAM;IAAA,CACxB;IACYoB,YAAA,CAAAmB,KAAA,GAAQrB,QAAA,CAASqB,KAAM,CAAAmB,MAAA,CAAQ1D,MAAA,IAC1C,CAAC,MAAM,MAAM,CAAE,CAAA2D,QAAA,CAAS3D,MAAA,CAAOwD,KAAK,EACtC;IAEM,MAAAI,YAAA,GAAe1C,QAAA,CAASqB,KAAM,CAAAsB,IAAA,CACjC7D,MAAW,IAAAA,MAAA,CAAO8D,IAAS,iBAC9B;IAEI,IAAAC,gBAAA;IAEF,IAAAH,YAAA,IACAA,YAAA,CAAaJ,KAAU,gBACvB,CAACpC,YAAa,CAAAmB,KAAA,CAAMoB,QAAS,CAAAC,YAAY,CACzC;MACA,MAAMI,iBAAoB,GAAA9C,QAAA,CAASqB,KAAM,CAAA0B,OAAA,CAAQL,YAAY;MAC7D,IAAII,iBAAsB,UAAK5C,YAAa,CAAAmB,KAAA,CAAMrC,MAAQ;QAC3CkB,YAAA,CAAAmB,KAAA,CAAM2B,OAAA,CAAQN,YAAY;QACpBG,gBAAA;MAAA;IACrB;IAGgB1C,iBAAA,CAAAkB,KAAA,GAAQrB,QAAA,CAASqB,KAAM,CAAAmB,MAAA,CACtC1D,MAAW,IAAAA,MAAA,CAAOwD,KAAU,aAC/B;IAEM,MAAAW,eAAA,GAAkBjD,QAAA,CAASqB,KAAM,CAAAmB,MAAA,CACpC1D,MAAA,KACE+D,gBAAmB,GAAA/D,MAAA,CAAO8D,IAAA,KAAS,WAAc,YAAS,CAAC9D,MAAO,CAAAwD,KAAA,CACvE;IAEcrC,aAAA,CAAAoB,KAAA,GAAQ6B,KAAM,CAAAC,IAAA,CAAKjD,YAAa,CAAAmB,KAAK,CAChD,CAAA+B,MAAA,CAAOH,eAAe,EACtBG,MAAO,CAAAjD,iBAAA,CAAkBkB,KAAK;IAC3B,MAAAgC,YAAA,GAAc3E,gBAAA,CAAiBuE,eAAe;IAC9C,MAAAK,iBAAA,GAAmB5E,gBAAiB,CAAAwB,YAAA,CAAamB,KAAK;IACtD,MAAAkC,sBAAA,GAAwB7E,gBAAiB,CAAAyB,iBAAA,CAAkBkB,KAAK;IAEtEb,iBAAA,CAAkBa,KAAA,GAAQgC,YAAY,CAAArE,MAAA;IACtCyB,sBAAA,CAAuBY,KAAA,GAAQiC,iBAAiB,CAAAtE,MAAA;IAChD0B,2BAAA,CAA4BW,KAAA,GAAQkC,sBAAsB,CAAAvE,MAAA;IAElDL,OAAA,CAAA0C,KAAA,GAAQ6B,KAAA,CAAMC,IAAK,CAAAG,iBAAgB,EACxCF,MAAO,CAAAC,YAAW,CAClB,CAAAD,MAAA,CAAOG,sBAAqB;IAC/BxD,SAAA,CAAUsB,KAAA,GACRnB,YAAa,CAAAmB,KAAA,CAAMrC,MAAA,GAAS,CAAK,IAAAmB,iBAAA,CAAkBkB,KAAA,CAAMrC,MAAS;EAAA,CACtE;EAGA,MAAM0C,cAAiB,GAAAA,CAAC8B,iBAA6B,EAAAC,SAAA,GAAY,KAAU;IACzE,IAAID,iBAAmB;MACPjB,aAAA;IAAA;IAEhB,IAAIkB,SAAW;MACbpE,QAAA,CAASoC,KAAA,CAAMiC,QAAS;IAAA,CACnB;MACLrE,QAAA,CAASoC,KAAA,CAAMkC,qBAAsB;IAAA;EACvC,CACF;EAGM,MAAAC,UAAA,GAAcC,GAAW;IAC7B,IAAI1C,WAAA,CAAYE,KAAO;MACrB,OAAO,CAAC,CAACF,WAAA,CAAYE,KAAA,CAAMyC,cAAe,CAAAD,GAAA,EAAKjE,MAAA,CAAOyB,KAAK;IAAA,CACtD;MACE,OAAAT,SAAA,CAAUS,KAAM,CAAAoB,QAAA,CAASoB,GAAG;IAAA;EACrC,CACF;EAEA,MAAME,cAAA,GAAiBA,CAAA,KAAM;IAC3BpD,aAAA,CAAcU,KAAQ;IACtB,MAAM2C,YAAA,GAAepD,SAAU,CAAAS,KAAA;IAC/BT,SAAA,CAAUS,KAAA,GAAQ,EAAC;IACnB,IAAI2C,YAAA,CAAahF,MAAQ;MACdK,QAAA,CAAA4E,IAAA,CAAK,kBAAoB,IAAE;IAAA;EACtC,CACF;EAEA,MAAMC,cAAA,GAAiBA,CAAA,KAAM;IA/M/B,IAAA1C,GAAA,EAAA2C,EAAA;IAgNQ,IAAAC,OAAA;IACJ,IAAIxE,MAAA,CAAOyB,KAAO;MAChB+C,OAAA,GAAU,EAAC;MACL,MAAAC,WAAA,IAAcF,EAAA,IAAA3C,GAAA,GAAAnC,QAAA,oBAAAA,QAAA,CAAUiF,KAAA,KAAV,gBAAA9C,GAAA,CAAiBvD,MAAjB,qBAAAkG,EAAA,CAAyBI,kBAAmB,CAAAlD,KAAA;MAChE,MAAMmD,OAAA,GAAUlD,UAAW,CAAAtD,IAAA,CAAKqD,KAAA,EAAOzB,MAAO,CAAAyB,KAAA,EAAO,MAAMgD,WAAW;MAC3D,WAAAI,GAAA,IAAOtD,WAAA,CAAYE,KAAO;QACnC,IAAIqD,MAAA,CAAOvD,WAAY,CAAAE,KAAA,EAAOoD,GAAG,CAAK,KAACD,OAAA,CAAQC,GAAM;UACnDL,OAAA,CAAQnF,IAAK,CAAAkC,WAAA,CAAYE,KAAM,CAAAoD,GAAA,EAAKZ,GAAG;QAAA;MACzC;IACF,CACK;MACKO,OAAA,GAAAxD,SAAA,CAAUS,KAAM,CAAAmB,MAAA,CAAQmC,IAAA,IAAS,CAAC3G,IAAK,CAAAqD,KAAA,CAAMoB,QAAS,CAAAkC,IAAI,CAAC;IAAA;IAEvE,IAAIP,OAAA,CAAQpF,MAAQ;MACZ,MAAA4F,YAAA,GAAehE,SAAA,CAAUS,KAAM,CAAAmB,MAAA,CAClCmC,IAAA,IAAS,CAACP,OAAA,CAAQ3B,QAAA,CAASkC,IAAI,EAClC;MACA/D,SAAA,CAAUS,KAAQ,GAAAuD,YAAA;MAClBvF,QAAA,CAAS4E,IAAK,qBAAoBW,YAAa,CAAAC,KAAA,EAAO;IAAA;EACxD,CACF;EAEA,MAAMC,gBAAA,GAAmBA,CAAA,KAAM;IAC7B,QAAQlE,SAAU,CAAAS,KAAA,IAAS,EAAC,EAAGwD,KAAM;EAAA,CACvC;EAEA,MAAME,kBAAA,GAAqBA,CACzBlB,GAAA,EACAmB,QAAA,EACAC,UAAa,SACbC,gBAAA,GAAmB,KAChB;IA/OP,IAAA1D,GAAA,EAAA2C,EAAA,EAAAgB,EAAA,EAAAC,EAAA;IAgPI,MAAMC,SAAY;MAChBtG,QAAA,GAAUoF,EAAA,IAAA3C,GAAA,GAAAnC,QAAA,oBAAAA,QAAA,CAAUiF,KAAA,KAAV,gBAAA9C,GAAA,CAAiBvD,MAAjB,qBAAAkG,EAAA,CAAyBI,kBAAmB,CAAAlD,KAAA;MACtDiE,aAAA,GAAeF,EAAU,IAAAD,EAAA,GAAA9F,QAAA,oBAAAA,QAAA,CAAAiF,KAAA,KAAV,IAAiB,YAAAa,EAAA,CAAAlH,MAAA,KAAjB,gBAAAmH,EAAA,CAAyBE,aAAc,CAAAjE;IAAA,CACxD;IACA,MAAMkE,OAAU,GAAAC,eAAA,CACd5E,SAAU,CAAAS,KAAA,EACVwC,GAAA,EACAmB,QAAA,EACAK,SAAA,EACAH,gBAAA,GAAmB,SAAYnE,UAAW,CAAAM,KAAA,EAC1CrD,IAAA,CAAKqD,KAAM,CAAA0B,OAAA,CAAQc,GAAG,GACtBjE,MAAO,CAAAyB,KAAA,CACT;IACA,IAAIkE,OAAS;MACX,MAAMX,YAAgB,IAAAhE,SAAA,CAAUS,KAAS,QAAIwD,KAAM;MAEnD,IAAII,UAAY;QACL5F,QAAA,CAAA4E,IAAA,CAAK,QAAU,EAAAW,YAAA,EAAcf,GAAG;MAAA;MAElCxE,QAAA,CAAA4E,IAAA,CAAK,oBAAoBW,YAAY;IAAA;EAChD,CACF;EAEA,MAAMa,mBAAA,GAAsBA,CAAA,KAAM;IAvQpC,IAAAjE,GAAA,EAAA2C,EAAA;IA0QU,MAAA9C,KAAA,GAAQP,qBAAsB,CAAAO,KAAA,GAChC,CAACV,aAAA,CAAcU,KAAA,GACf,EAAEV,aAAA,CAAcU,KAAS,IAAAT,SAAA,CAAUS,KAAM,CAAArC,MAAA;IAC7C2B,aAAA,CAAcU,KAAQ,GAAAA,KAAA;IAEtB,IAAIqE,gBAAmB;IACvB,IAAIC,aAAgB;IACd,MAAAC,OAAA,IAASzB,EAAA,IAAA3C,GAAA,GAAAnC,QAAA,oBAAAA,QAAA,CAAUiF,KAAA,KAAV,gBAAA9C,GAAA,CAAiBvD,MAAjB,qBAAAkG,EAAA,CAAyBvE,MAAO,CAAAyB,KAAA;IAC/C,MAAM;MAAEkD;IAAA,CAAuB,GAAAlF,QAAA,CAASiF,KAAM,CAAArG,MAAA;IAC9C,MAAMoH,SAAY;MAChBtG,QAAA,EAAUwF,kBAAmB,CAAAlD,KAAA;MAC7BiE,aAAe;IAAA,CACjB;IAEAtH,IAAA,CAAKqD,KAAM,CAAAxC,OAAA,CAAQ,CAACgF,GAAA,EAAKgC,KAAU;MACjC,MAAMC,QAAA,GAAWD,KAAQ,GAAAF,aAAA;MAEvB,IAAAH,eAAA,CACE5E,SAAU,CAAAS,KAAA,EACVwC,GAAA,EACAxC,KAAA,EACAgE,SAAA,EACAtE,UAAW,CAAAM,KAAA,EACXyE,QAAA,EACAF,OAAA,CAEF;QACmBF,gBAAA;MAAA;MAErBC,aAAA,IAAiBI,gBAAiB,CAAAjC,cAAA,CAAeD,GAAK,EAAA+B,OAAM,CAAC;IAAA,CAC9D;IAED,IAAIF,gBAAkB;MACXrG,QAAA,CAAA4E,IAAA,CACP,oBACArD,SAAA,CAAUS,KAAQ,GAAAT,SAAA,CAAUS,KAAM,CAAAwD,KAAA,KAAU,EAAC,CAC/C;IAAA;IAEFxF,QAAA,CAAS4E,IAAA,CAAK,YAAe,GAAArD,SAAA,CAAUS,KAAA,IAAS,EAAC,EAAGwD,KAAA,EAAO;EAAA,CAC7D;EAEA,MAAMmB,iBAAA,GAAoBA,CAAA,KAAM;IAnTlC,IAAAxE,GAAA;IAqTI,MAAIA,GAAA,GAAAxD,IAAK,CAAAqD,KAAA,KAAL,gBAAAG,GAAA,CAAYxC,MAAA,MAAW,CAAG;MAC5B2B,aAAA,CAAcU,KAAQ;MACtB;IAAA;IAGF,MAAM;MAAEkD;IAAA,CAAuB,GAAAlF,QAAA,CAASiF,KAAM,CAAArG,MAAA;IAC9C,IAAI6H,QAAW;IACf,IAAIG,aAAgB;IAEd,MAAAC,mBAAA,GAAuBC,KAAc;MA9T/C,IAAAC,GAAA;MA+TM,WAAWvC,GAAA,IAAOsC,KAAM;QAChB,MAAAE,eAAA,GACJtF,UAAA,CAAWM,KAAS,IAAAN,UAAA,CAAWM,KAAA,CAAMiF,IAAK,OAAMzC,GAAA,EAAKiC,QAAQ;QAE3D,KAAClC,UAAW,CAAAC,GAAG,CAAG;UAChB,KAAC9C,UAAW,CAAAM,KAAA,IAASgF,eAAiB;YACjC;UAAA;QACT,CACK;UACLJ,aAAA;QAAA;QAEFH,QAAA;QAEA,MACEM,GAAA,GAAAvC,GAAA,CAAIU,kBAAmB,CAAAlD,KAAA,MAAvB,gBAAA+E,GAAA,CAA+BpH,MAC/B,MAACkH,mBAAoB,CAAArC,GAAA,CAAIU,kBAAmB,CAAAlD,KAAA,CAAM,CAClD;UACO;QAAA;MACT;MAEK;IAAA,CACT;IAEA,MAAMkF,cAAiB,GAAAL,mBAAA,CAAoBlI,IAAK,CAAAqD,KAAA,IAAS,EAAE;IAC7CV,aAAA,CAAAU,KAAA,GAAQ4E,aAAkB,SAAI,KAAQ,GAAAM,cAAA;EAAA,CACtD;EAEM,MAAAR,gBAAA,GAAoBH,OAAmB;IA1V/C,IAAApE,GAAA;IA2VQ,KAACnC,QAAY,KAACA,QAAS,CAAAiF,KAAA,EAAc;IACzC,MAAM;MAAEkC;IAAA,CAAa,GAAAnH,QAAA,CAASiF,KAAM,CAAArG,MAAA;IACpC,IAAIwI,KAAQ;IACZ,MAAM1H,QAAA,IAAWyC,GAAA,GAAAgF,QAAA,CAASnF,KAAM,CAAAuE,OAAA,MAAf,gBAAApE,GAAwB,CAAAzC,QAAA;IACzC,IAAIA,QAAU;MACZ0H,KAAA,IAAS1H,QAAS,CAAAC,MAAA;MACTD,QAAA,CAAAF,OAAA,CAAS6H,QAAa;QAC7BD,KAAA,IAASV,gBAAA,CAAiBW,QAAQ;MAAA,CACnC;IAAA;IAEI,OAAAD,KAAA;EAAA,CACT;EAGM,MAAAE,aAAA,GAAgBA,CAAC7H,MAAA,EAA2B8H,MAAqB;IACrE,MAAMC,QAAA,GAAqC,EAAC;IAC5CC,SAAA,CAAYhI,MAAM,EAAED,OAAQ,CAACkI,GAAQ;MAC3B/F,OAAA,CAAAK,KAAA,CAAM0F,GAAA,CAAIC,EAAM,IAAAJ,MAAA;MACfC,QAAA,CAAAE,GAAA,CAAIE,SAAa,IAAAF,GAAA,CAAIC,EAAM,IAAAJ,MAAA;IAAA,CACrC;IACM,OAAAC,QAAA;EAAA,CACT;EAEA,MAAMK,UAAa,GAAAA,CACjBpI,MACA,EAAAqI,IAAA,EACAC,KACG;IACH,IAAIlJ,aAAc,CAAAmD,KAAA,IAASnD,aAAc,CAAAmD,KAAA,KAAUvC,MAAQ;MACzDZ,aAAA,CAAcmD,KAAA,CAAM+F,KAAQ;IAAA;IAE9BlJ,aAAA,CAAcmD,KAAQ,GAAAvC,MAAA;IACtBR,QAAA,CAAS+C,KAAQ,GAAA8F,IAAA;IACjB5I,SAAA,CAAU8C,KAAQ,GAAA+F,KAAA;EAAA,CACpB;EAEA,MAAMC,UAAA,GAAaA,CAAA,KAAM;IACnB,IAAAC,UAAA,GAAaC,KAAA,CAAMzH,KAAK;IAC5B0H,MAAA,CAAOC,IAAA,CAAKzG,OAAQ,CAAAK,KAAK,CAAE,CAAAxC,OAAA,CAAS6I,QAAa;MACzC,MAAAd,MAAA,GAAS5F,OAAA,CAAQK,KAAM,CAAAqG,QAAA;MACzB,KAACd,MAAU,IAAAA,MAAA,CAAO5H,MAAW,QAAG;MACpC,MAAMF,MAAS,GAAA6I,aAAA,CACb;QACEhJ,OAAA,EAASA,OAAQ,CAAA0C;MAAA,CACnB,EACAqG,QAAA,CACF;MACI,IAAA5I,MAAA,IAAUA,MAAA,CAAO8I,YAAc;QACpBN,UAAA,GAAAA,UAAA,CAAW9E,MAAO,CAACqB,GAAQ;UACtC,OAAO+C,MAAO,CAAAiB,IAAA,CAAMxG,KAAA,IAClBvC,MAAO,CAAA8I,YAAA,CAAatB,IAAA,CAAK,IAAM,EAAAjF,KAAA,EAAOwC,GAAA,EAAK/E,MAAM,EACnD;QAAA,CACD;MAAA;IACH,CACD;IACDmC,YAAA,CAAaI,KAAQ,GAAAiG,UAAA;EAAA,CACvB;EAEA,MAAMQ,QAAA,GAAWA,CAAA,KAAM;IArZzB,IAAAtG,GAAA;IAsZSxD,IAAA,CAAAqD,KAAA,GAAQtD,QAAA,EAASyD,GAAA,GAAAP,YAAA,CAAaI,KAAA,KAAb,OAAAG,GAAA,GAAsB,EAAI;MAC9CtD,aAAA,EAAeA,aAAc,CAAAmD,KAAA;MAC7B/C,QAAA,EAAUA,QAAS,CAAA+C,KAAA;MACnB9C,SAAA,EAAWA,SAAU,CAAA8C;IAAA,CACtB;EAAA,CACH;EAGM,MAAA0G,SAAA,GAAYA,CAACC,MAAA,GAA0C,KAAc;IACrE,MAACA,MAAA,oBAAAA,MAAA,CAAQxF,MAAQ;MACR6E,UAAA;IAAA;IAEJS,QAAA;EAAA,CACX;EAEM,MAAAG,WAAA,GAAeC,UAAmC;IAChD;MAAEnG;IAAe,IAAI1C,QAAS,CAAAyC,IAAA;IACpC,IAAI,CAACC,cAAA,EAAgB;IACrB,MAAMoG,MAAA,GAASX,MAAO,CAAAY,MAAA,CAAO,EAAC,EAAGrG,cAAA,CAAesG,YAAY;IAEtD,MAAAZ,IAAA,GAAOD,MAAO,CAAAC,IAAA,CAAKU,MAAM;IAC/B,IAAI,CAACV,IAAK,CAAAzI,MAAA,EAAQ;IAEd,IAAAb,QAAA,CAAS+J,UAAU,CAAG;MACxBA,UAAA,GAAa,CAACA,UAAU;IAAA;IAGtB,IAAAI,OAAA,CAAQJ,UAAU,CAAG;MACvB,MAAMK,QAAA,GAAWL,UAAW,CAAAM,GAAA,CAAK/D,GAC/B,IAAAgE,cAAA,CACE;QACE9J,OAAA,EAASA,OAAQ,CAAA0C;MAAA,CACnB,EACAoD,GAAA,CACF,CACF;MACKgD,IAAA,CAAA5I,OAAA,CAAS4F,GAAQ;QACpB,MAAM3F,MAAA,GAASyJ,QAAS,CAAA5F,IAAA,CAAMoE,GAAQ,IAAAA,GAAA,CAAIC,EAAA,KAAOvC,GAAG;QACpD,IAAI3F,MAAQ;UACVA,MAAA,CAAO4J,aAAA,GAAgB,EAAC;QAAA;MAC1B,CACD;MACQrJ,QAAA,CAAAiF,KAAA,CAAMqE,MAAA,CAAO,cAAgB;QACpC7J,MAAQ,EAAAyJ,QAAA;QACR3B,MAAA,EAAQ,EAAC;QACTgC,MAAQ;QACRC,KAAO;MAAA,CACR;IAAA,CACI;MACApB,IAAA,CAAA5I,OAAA,CAAS4F,GAAQ;QACd,MAAA3F,MAAA,GAASH,OAAA,CAAQ0C,KAAM,CAAAsB,IAAA,CAAMoE,GAAQ,IAAAA,GAAA,CAAIC,EAAA,KAAOvC,GAAG;QACzD,IAAI3F,MAAQ;UACVA,MAAA,CAAO4J,aAAA,GAAgB,EAAC;QAAA;MAC1B,CACD;MAED1H,OAAA,CAAQK,KAAA,GAAQ,EAAC;MACRhC,QAAA,CAAAiF,KAAA,CAAMqE,MAAA,CAAO,cAAgB;QACpC7J,MAAA,EAAQ,EAAC;QACT8H,MAAA,EAAQ,EAAC;QACTgC,MAAQ;MAAA,CACT;IAAA;EACH,CACF;EAEA,MAAME,SAAA,GAAYA,CAAA,KAAM;IACtB,IAAI,CAAC5K,aAAc,CAAAmD,KAAA,EAAO;IAEf6F,UAAA,OAAM,MAAM,IAAI;IAClB7H,QAAA,CAAAiF,KAAA,CAAMqE,MAAA,CAAO,qBAAuB;MAC3CC,MAAQ;IAAA,CACT;EAAA,CACH;EACM;IACJG,gBAAA;IACAC,kBAAA;IACAC,gBAAA;IACAhL,MAAQ,EAAAiL,YAAA;IACRC;EAAA,IACEC,SAAU;IACZpL,IAAA;IACA4B;EAAA,CACD;EACK;IACJyJ,oBAAA;IACAC,mBAAA;IACAC,cAAA;IACAC,iBAAA;IACAC,YAAA;IACAxL,MAAQ,EAAAyL;EAAA,IACNC,OAAQ;IACV3L,IAAA;IACA4B;EAAA,CACD;EACK;IACJgK,oBAAA;IACAC,gBAAA;IACAC,gBAAA;IACA7L,MAAQ,EAAA8L;EAAA,IACNC,UAAW;IACbhM,IAAA;IACA4B;EAAA,CACD;EAEK,MAAAqK,uBAAA,GAA2BC,GAAkB;IAEjDnB,gBAAA,CAAiBmB,GAAG;IACpBb,oBAAA,CAAqBa,GAAG;EAAA,CAC1B;EAGM,MAAAC,yBAAA,GAA4BA,CAACtG,GAAA,EAAQuG,QAAuB;IAC1D,MAAAC,eAAA,GAAkB1L,OAAA,CAAQ0C,KAAM,CAAAwG,IAAA,CAAK,CAAC;MAAEjF;IAAA,CAAW,KAAAA,IAAA,KAAS,QAAQ;IAC1E,IAAIyH,eAAiB;MACnBrB,kBAAA,CAAmBnF,GAAA,EAAKuG,QAAQ;IAAA,CAC3B;MACLd,mBAAA,CAAoBzF,GAAA,EAAKuG,QAAQ;IAAA;EACnC,CACF;EAEO;IACLlI,YAAA;IACAK,aAAA;IACAb,cAAA;IACAkC,UAAA;IACAG,cAAA;IACAG,cAAA;IACAY,gBAAA;IACAC,kBAAA;IACAU,mBAAA;IACA6E,kBAAoB;IACpBtE,iBAAA;IACAW,aAAA;IACAkD,gBAAA;IACA3C,UAAA;IACAG,UAAA;IACAS,QAAA;IACAC,SAAA;IACAE,WAAA;IACAa,SAAA;IACAE,kBAAA;IACAiB,uBAAA;IACAH,gBAAA;IACAK,yBAAA;IACAhB,aAAA;IACAF,gBAAA;IACAW,oBAAA;IACAH,YAAA;IACAF,cAAA;IACAC,iBAAA;IACAvL,MAAQ;MACNuB,SAAA;MACAI,MAAA;MACA5B,IAAA;MACA8B,KAAA;MACAC,SAAA;MACAC,QAAA;MACAC,aAAA;MACAtB,OAAA;MACAuB,YAAA;MACAC,iBAAA;MACAC,WAAA;MACAC,gBAAA;MACAC,qBAAA;MACAC,cAAA;MACAC,iBAAA;MACAC,sBAAA;MACAC,2BAAA;MACAC,aAAA;MACAC,SAAA;MACAC,gBAAA;MACAC,qBAAA;MACAC,UAAA;MACAC,OAAA;MACAC,YAAA;MACA/C,aAAA;MACAI,QAAA;MACAC,SAAA;MACA2C,QAAA;MACA,GAAGgI,YAAA;MACH,GAAGQ,UAAA;MACH,GAAGK;IAAA;EACL,CACF;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}