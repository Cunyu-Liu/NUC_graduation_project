{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport { isVNode, Fragment, Text, Comment, createCommentVNode, openBlock, createBlock } from 'vue';\nimport { isArray, hasOwn, camelize } from '@vue/shared';\nimport { debugWarn } from '../error.mjs';\nconst SCOPE = \"utils/vue/vnode\";\nvar PatchFlags = /* @__PURE__ */(PatchFlags2 => {\n  PatchFlags2[PatchFlags2[\"TEXT\"] = 1] = \"TEXT\";\n  PatchFlags2[PatchFlags2[\"CLASS\"] = 2] = \"CLASS\";\n  PatchFlags2[PatchFlags2[\"STYLE\"] = 4] = \"STYLE\";\n  PatchFlags2[PatchFlags2[\"PROPS\"] = 8] = \"PROPS\";\n  PatchFlags2[PatchFlags2[\"FULL_PROPS\"] = 16] = \"FULL_PROPS\";\n  PatchFlags2[PatchFlags2[\"HYDRATE_EVENTS\"] = 32] = \"HYDRATE_EVENTS\";\n  PatchFlags2[PatchFlags2[\"STABLE_FRAGMENT\"] = 64] = \"STABLE_FRAGMENT\";\n  PatchFlags2[PatchFlags2[\"KEYED_FRAGMENT\"] = 128] = \"KEYED_FRAGMENT\";\n  PatchFlags2[PatchFlags2[\"UNKEYED_FRAGMENT\"] = 256] = \"UNKEYED_FRAGMENT\";\n  PatchFlags2[PatchFlags2[\"NEED_PATCH\"] = 512] = \"NEED_PATCH\";\n  PatchFlags2[PatchFlags2[\"DYNAMIC_SLOTS\"] = 1024] = \"DYNAMIC_SLOTS\";\n  PatchFlags2[PatchFlags2[\"HOISTED\"] = -1] = \"HOISTED\";\n  PatchFlags2[PatchFlags2[\"BAIL\"] = -2] = \"BAIL\";\n  return PatchFlags2;\n})(PatchFlags || {});\nfunction isFragment(node) {\n  return isVNode(node) && node.type === Fragment;\n}\nfunction isText(node) {\n  return isVNode(node) && node.type === Text;\n}\nfunction isComment(node) {\n  return isVNode(node) && node.type === Comment;\n}\nconst TEMPLATE = \"template\";\nfunction isTemplate(node) {\n  return isVNode(node) && node.type === TEMPLATE;\n}\nfunction isValidElementNode(node) {\n  return isVNode(node) && !isFragment(node) && !isComment(node);\n}\nfunction getChildren(node, depth) {\n  if (isComment(node)) return;\n  if (isFragment(node) || isTemplate(node)) {\n    return depth > 0 ? getFirstValidNode(node.children, depth - 1) : void 0;\n  }\n  return node;\n}\nconst getFirstValidNode = (nodes, maxDepth = 3) => {\n  if (isArray(nodes)) {\n    return getChildren(nodes[0], maxDepth);\n  } else {\n    return getChildren(nodes, maxDepth);\n  }\n};\nfunction renderIf(condition, ...args) {\n  return condition ? renderBlock(...args) : createCommentVNode(\"v-if\", true);\n}\nfunction renderBlock(...args) {\n  return openBlock(), createBlock(...args);\n}\nconst getNormalizedProps = node => {\n  if (!isVNode(node)) {\n    debugWarn(SCOPE, \"[getNormalizedProps] must be a VNode\");\n    return {};\n  }\n  const raw = node.props || {};\n  const type = (isVNode(node.type) ? node.type.props : void 0) || {};\n  const props = {};\n  Object.keys(type).forEach(key => {\n    if (hasOwn(type[key], \"default\")) {\n      props[key] = type[key].default;\n    }\n  });\n  Object.keys(raw).forEach(key => {\n    props[camelize(key)] = raw[key];\n  });\n  return props;\n};\nconst flattedChildren = children => {\n  const vNodes = isArray(children) ? children : [children];\n  const result = [];\n  vNodes.forEach(child => {\n    var _a;\n    if (isArray(child)) {\n      result.push(...flattedChildren(child));\n    } else if (isVNode(child) && ((_a = child.component) == null ? void 0 : _a.subTree)) {\n      result.push(child, ...flattedChildren(child.component.subTree));\n    } else if (isVNode(child) && isArray(child.children)) {\n      result.push(...flattedChildren(child.children));\n    } else if (isVNode(child) && child.shapeFlag === 2) {\n      result.push(...flattedChildren(child.type()));\n    } else {\n      result.push(child);\n    }\n  });\n  return result;\n};\nexport { PatchFlags, flattedChildren, getFirstValidNode, getNormalizedProps, isComment, isFragment, isTemplate, isText, isValidElementNode, renderBlock, renderIf };","map":{"version":3,"names":["SCOPE","PatchFlags","PatchFlags2","isFragment","node","isVNode","type","Fragment","isText","Text","isComment","Comment","TEMPLATE","isTemplate","isValidElementNode","getChildren","depth","getFirstValidNode","children","nodes","maxDepth","isArray","renderIf","condition","args","renderBlock","createCommentVNode","openBlock","createBlock","getNormalizedProps","debugWarn","raw","props","Object","keys","forEach","key","hasOwn","default","camelize","flattedChildren","vNodes","result","child","_a","push","component","subTree","shapeFlag"],"sources":["../../../../../packages/utils/vue/vnode.ts"],"sourcesContent":["import {\n  Comment,\n  Fragment,\n  Text,\n  createBlock,\n  createCommentVNode,\n  isVNode,\n  openBlock,\n} from 'vue'\nimport { camelize } from '../strings'\nimport { isArray } from '../types'\nimport { hasOwn } from '../objects'\nimport { debugWarn } from '../error'\n\nimport type { VNode, VNodeChild, VNodeNormalizedChildren } from 'vue'\n\nconst SCOPE = 'utils/vue/vnode'\n\nexport enum PatchFlags {\n  TEXT = 1,\n  CLASS = 2,\n  STYLE = 4,\n  PROPS = 8,\n  FULL_PROPS = 16,\n  HYDRATE_EVENTS = 32,\n  STABLE_FRAGMENT = 64,\n  KEYED_FRAGMENT = 128,\n  UNKEYED_FRAGMENT = 256,\n  NEED_PATCH = 512,\n  DYNAMIC_SLOTS = 1024,\n  HOISTED = -1,\n  BAIL = -2,\n}\n\nexport type VNodeChildAtom = Exclude<VNodeChild, Array<any>>\nexport type RawSlots = Exclude<\n  VNodeNormalizedChildren,\n  Array<any> | null | string\n>\n\nexport function isFragment(node: VNode): boolean\nexport function isFragment(node: unknown): node is VNode\nexport function isFragment(node: unknown): node is VNode {\n  return isVNode(node) && node.type === Fragment\n}\n\nexport function isText(node: VNode): boolean\nexport function isText(node: unknown): node is VNode\nexport function isText(node: unknown): node is VNode {\n  return isVNode(node) && node.type === Text\n}\n\nexport function isComment(node: VNode): boolean\nexport function isComment(node: unknown): node is VNode\nexport function isComment(node: unknown): node is VNode {\n  return isVNode(node) && node.type === Comment\n}\n\nconst TEMPLATE = 'template'\nexport function isTemplate(node: VNode): boolean\nexport function isTemplate(node: unknown): node is VNode\nexport function isTemplate(node: unknown): node is VNode {\n  return isVNode(node) && node.type === TEMPLATE\n}\n\n/**\n * determine if the element is a valid element type rather than fragments and comment e.g. <template> v-if\n * @param node {VNode} node to be tested\n */\nexport function isValidElementNode(node: VNode): boolean\nexport function isValidElementNode(node: unknown): node is VNode\nexport function isValidElementNode(node: unknown): node is VNode {\n  return isVNode(node) && !isFragment(node) && !isComment(node)\n}\n\n/**\n * get a valid child node (not fragment nor comment)\n * @param node {VNode} node to be searched\n * @param depth {number} depth to be searched\n */\nfunction getChildren(\n  node: VNodeNormalizedChildren | VNodeChild,\n  depth: number\n): VNodeNormalizedChildren | VNodeChild {\n  if (isComment(node)) return\n  if (isFragment(node) || isTemplate(node)) {\n    return depth > 0 ? getFirstValidNode(node.children, depth - 1) : undefined\n  }\n  return node\n}\n\nexport const getFirstValidNode = (\n  nodes: VNodeNormalizedChildren,\n  maxDepth = 3\n) => {\n  if (isArray(nodes)) {\n    return getChildren(nodes[0], maxDepth)\n  } else {\n    return getChildren(nodes, maxDepth)\n  }\n}\n\nexport function renderIf(\n  condition: boolean,\n  ...args: Parameters<typeof createBlock>\n) {\n  return condition ? renderBlock(...args) : createCommentVNode('v-if', true)\n}\n\nexport function renderBlock(...args: Parameters<typeof createBlock>) {\n  return (openBlock(), createBlock(...args))\n}\n\nexport const getNormalizedProps = (node: VNode) => {\n  if (!isVNode(node)) {\n    debugWarn(SCOPE, '[getNormalizedProps] must be a VNode')\n    return {}\n  }\n\n  const raw = node.props || {}\n  const type = (isVNode(node.type) ? node.type.props : undefined) || {}\n  const props: Record<string, any> = {}\n\n  Object.keys(type).forEach((key) => {\n    if (hasOwn(type[key], 'default')) {\n      props[key] = type[key].default\n    }\n  })\n\n  Object.keys(raw).forEach((key) => {\n    props[camelize(key)] = raw[key]\n  })\n\n  return props\n}\n\nexport type FlattenVNodes = Array<VNodeChildAtom | RawSlots>\n\nexport const flattedChildren = (\n  children: FlattenVNodes | VNode | VNodeNormalizedChildren\n): FlattenVNodes => {\n  const vNodes = isArray(children) ? children : [children]\n  const result: FlattenVNodes = []\n\n  vNodes.forEach((child) => {\n    if (isArray(child)) {\n      result.push(...flattedChildren(child))\n    } else if (isVNode(child) && child.component?.subTree) {\n      result.push(child, ...flattedChildren(child.component.subTree))\n    } else if (isVNode(child) && isArray(child.children)) {\n      result.push(...flattedChildren(child.children))\n    } else if (isVNode(child) && child.shapeFlag === 2) {\n      // @ts-ignore\n      result.push(...flattedChildren(child.type()))\n    } else {\n      result.push(child)\n    }\n  })\n  return result\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}