{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.iterator.reduce.js\";\nimport \"core-js/modules/es.iterator.some.js\";\nimport { createVNode, render, isVNode, Comment, Fragment } from 'vue';\nimport { merge, flatMap, castArray, get, isNull } from 'lodash-unified';\nimport { ElTooltip } from '../../tooltip/index.mjs';\nimport { isArray, isString, isFunction, hasOwn, isObject } from '@vue/shared';\nimport { throwError } from '../../../utils/error.mjs';\nimport { isUndefined, isNumber, isBoolean } from '../../../utils/types.mjs';\nimport { getProp } from '../../../utils/objects.mjs';\nconst getCell = function (event) {\n  var _a;\n  return (_a = event.target) == null ? void 0 : _a.closest(\"td\");\n};\nconst orderBy = function (array, sortKey, reverse, sortMethod, sortBy) {\n  if (!sortKey && !sortMethod && (!sortBy || isArray(sortBy) && !sortBy.length)) {\n    return array;\n  }\n  if (isString(reverse)) {\n    reverse = reverse === \"descending\" ? -1 : 1;\n  } else {\n    reverse = reverse && reverse < 0 ? -1 : 1;\n  }\n  const getKey = sortMethod ? null : function (value, index) {\n    if (sortBy) {\n      return flatMap(castArray(sortBy), by => {\n        if (isString(by)) {\n          return get(value, by);\n        } else {\n          return by(value, index, array);\n        }\n      });\n    }\n    if (sortKey !== \"$key\") {\n      if (isObject(value) && \"$value\" in value) value = value.$value;\n    }\n    return [isObject(value) ? sortKey ? get(value, sortKey) : null : value];\n  };\n  const compare = function (a, b) {\n    var _a, _b, _c, _d, _e, _f;\n    if (sortMethod) {\n      return sortMethod(a.value, b.value);\n    }\n    for (let i = 0, len = (_b = (_a = a.key) == null ? void 0 : _a.length) != null ? _b : 0; i < len; i++) {\n      if (((_c = a.key) == null ? void 0 : _c[i]) < ((_d = b.key) == null ? void 0 : _d[i])) {\n        return -1;\n      }\n      if (((_e = a.key) == null ? void 0 : _e[i]) > ((_f = b.key) == null ? void 0 : _f[i])) {\n        return 1;\n      }\n    }\n    return 0;\n  };\n  return array.map((value, index) => {\n    return {\n      value,\n      index,\n      key: getKey ? getKey(value, index) : null\n    };\n  }).sort((a, b) => {\n    let order = compare(a, b);\n    if (!order) {\n      order = a.index - b.index;\n    }\n    return order * +reverse;\n  }).map(item => item.value);\n};\nconst getColumnById = function (table, columnId) {\n  let column = null;\n  table.columns.forEach(item => {\n    if (item.id === columnId) {\n      column = item;\n    }\n  });\n  return column;\n};\nconst getColumnByKey = function (table, columnKey) {\n  let column = null;\n  for (let i = 0; i < table.columns.length; i++) {\n    const item = table.columns[i];\n    if (item.columnKey === columnKey) {\n      column = item;\n      break;\n    }\n  }\n  if (!column) throwError(\"ElTable\", `No column matching with column-key: ${columnKey}`);\n  return column;\n};\nconst getColumnByCell = function (table, cell, namespace) {\n  const matches = (cell.className || \"\").match(new RegExp(`${namespace}-table_[^\\\\s]+`, \"gm\"));\n  if (matches) {\n    return getColumnById(table, matches[0]);\n  }\n  return null;\n};\nconst getRowIdentity = (row, rowKey) => {\n  if (!row) throw new Error(\"Row is required when get row identity\");\n  if (isString(rowKey)) {\n    if (!rowKey.includes(\".\")) {\n      return `${row[rowKey]}`;\n    }\n    const key = rowKey.split(\".\");\n    let current = row;\n    for (const element of key) {\n      current = current[element];\n    }\n    return `${current}`;\n  } else if (isFunction(rowKey)) {\n    return rowKey.call(null, row);\n  }\n  return \"\";\n};\nconst getKeysMap = function (array, rowKey, flatten = false, childrenKey = \"children\") {\n  const data = array || [];\n  const arrayMap = {};\n  data.forEach((row, index) => {\n    arrayMap[getRowIdentity(row, rowKey)] = {\n      row,\n      index\n    };\n    if (flatten) {\n      const children = row[childrenKey];\n      if (isArray(children)) {\n        Object.assign(arrayMap, getKeysMap(children, rowKey, true, childrenKey));\n      }\n    }\n  });\n  return arrayMap;\n};\nfunction mergeOptions(defaults, config) {\n  const options = {};\n  let key;\n  for (key in defaults) {\n    options[key] = defaults[key];\n  }\n  for (key in config) {\n    if (hasOwn(config, key)) {\n      const value = config[key];\n      if (!isUndefined(value)) {\n        options[key] = value;\n      }\n    }\n  }\n  return options;\n}\nfunction parseWidth(width) {\n  if (width === \"\") return width;\n  if (!isUndefined(width)) {\n    width = Number.parseInt(width, 10);\n    if (Number.isNaN(width)) {\n      width = \"\";\n    }\n  }\n  return width;\n}\nfunction parseMinWidth(minWidth) {\n  if (minWidth === \"\") return minWidth;\n  if (!isUndefined(minWidth)) {\n    minWidth = parseWidth(minWidth);\n    if (Number.isNaN(minWidth)) {\n      minWidth = 80;\n    }\n  }\n  return minWidth;\n}\nfunction parseHeight(height) {\n  if (isNumber(height)) {\n    return height;\n  }\n  if (isString(height)) {\n    if (/^\\d+(?:px)?$/.test(height)) {\n      return Number.parseInt(height, 10);\n    } else {\n      return height;\n    }\n  }\n  return null;\n}\nfunction compose(...funcs) {\n  if (funcs.length === 0) {\n    return arg => arg;\n  }\n  if (funcs.length === 1) {\n    return funcs[0];\n  }\n  return funcs.reduce((a, b) => (...args) => a(b(...args)));\n}\nfunction toggleRowStatus(statusArr, row, newVal, tableTreeProps, selectable, rowIndex, rowKey) {\n  let _rowIndex = rowIndex != null ? rowIndex : 0;\n  let changed = false;\n  const getIndex = () => {\n    if (!rowKey) {\n      return statusArr.indexOf(row);\n    }\n    const id = getRowIdentity(row, rowKey);\n    return statusArr.findIndex(item => getRowIdentity(item, rowKey) === id);\n  };\n  const index = getIndex();\n  const included = index !== -1;\n  const isRowSelectable = selectable == null ? void 0 : selectable.call(null, row, _rowIndex);\n  const toggleStatus = type => {\n    if (type === \"add\") {\n      statusArr.push(row);\n    } else {\n      statusArr.splice(index, 1);\n    }\n    changed = true;\n  };\n  const getChildrenCount = row2 => {\n    let count = 0;\n    const children = (tableTreeProps == null ? void 0 : tableTreeProps.children) && row2[tableTreeProps.children];\n    if (children && isArray(children)) {\n      count += children.length;\n      children.forEach(item => {\n        count += getChildrenCount(item);\n      });\n    }\n    return count;\n  };\n  if (!selectable || isRowSelectable) {\n    if (isBoolean(newVal)) {\n      if (newVal && !included) {\n        toggleStatus(\"add\");\n      } else if (!newVal && included) {\n        toggleStatus(\"remove\");\n      }\n    } else {\n      included ? toggleStatus(\"remove\") : toggleStatus(\"add\");\n    }\n  }\n  if (!(tableTreeProps == null ? void 0 : tableTreeProps.checkStrictly) && (tableTreeProps == null ? void 0 : tableTreeProps.children) && isArray(row[tableTreeProps.children])) {\n    row[tableTreeProps.children].forEach(item => {\n      const childChanged = toggleRowStatus(statusArr, item, newVal != null ? newVal : !included, tableTreeProps, selectable, _rowIndex + 1, rowKey);\n      _rowIndex += getChildrenCount(item) + 1;\n      if (childChanged) {\n        changed = childChanged;\n      }\n    });\n  }\n  return changed;\n}\nfunction walkTreeNode(root, cb, childrenKey = \"children\", lazyKey = \"hasChildren\", lazy = false) {\n  const isNil = array => !(isArray(array) && array.length);\n  function _walker(parent, children, level) {\n    cb(parent, children, level);\n    children.forEach(item => {\n      if (item[lazyKey] && lazy) {\n        cb(item, null, level + 1);\n        return;\n      }\n      const children2 = item[childrenKey];\n      if (!isNil(children2)) {\n        _walker(item, children2, level + 1);\n      }\n    });\n  }\n  root.forEach(item => {\n    if (item[lazyKey] && lazy) {\n      cb(item, null, 0);\n      return;\n    }\n    const children = item[childrenKey];\n    if (!isNil(children)) {\n      _walker(item, children, 0);\n    }\n  });\n}\nconst getTableOverflowTooltipProps = (props, innerText, row, column) => {\n  const popperOptions = {\n    strategy: \"fixed\",\n    ...props.popperOptions\n  };\n  const tooltipFormatterContent = isFunction(column == null ? void 0 : column.tooltipFormatter) ? column.tooltipFormatter({\n    row,\n    column,\n    cellValue: getProp(row, column.property).value\n  }) : void 0;\n  if (isVNode(tooltipFormatterContent)) {\n    return {\n      slotContent: tooltipFormatterContent,\n      content: null,\n      ...props,\n      popperOptions\n    };\n  }\n  return {\n    slotContent: null,\n    content: tooltipFormatterContent != null ? tooltipFormatterContent : innerText,\n    ...props,\n    popperOptions\n  };\n};\nlet removePopper = null;\nfunction createTablePopper(props, popperContent, row, column, trigger, table) {\n  var _a;\n  const tableOverflowTooltipProps = getTableOverflowTooltipProps(props, popperContent, row, column);\n  const mergedProps = {\n    ...tableOverflowTooltipProps,\n    slotContent: void 0\n  };\n  if ((removePopper == null ? void 0 : removePopper.trigger) === trigger) {\n    const comp = (_a = removePopper.vm) == null ? void 0 : _a.component;\n    merge(comp == null ? void 0 : comp.props, mergedProps);\n    if (comp && tableOverflowTooltipProps.slotContent) {\n      comp.slots.content = () => [tableOverflowTooltipProps.slotContent];\n    }\n    return;\n  }\n  removePopper == null ? void 0 : removePopper();\n  const parentNode = table == null ? void 0 : table.refs.tableWrapper;\n  const ns = parentNode == null ? void 0 : parentNode.dataset.prefix;\n  const vm = createVNode(ElTooltip, {\n    virtualTriggering: true,\n    virtualRef: trigger,\n    appendTo: parentNode,\n    placement: \"top\",\n    transition: \"none\",\n    offset: 0,\n    hideAfter: 0,\n    ...mergedProps\n  }, tableOverflowTooltipProps.slotContent ? {\n    content: () => tableOverflowTooltipProps.slotContent\n  } : void 0);\n  vm.appContext = {\n    ...table.appContext,\n    ...table\n  };\n  const container = document.createElement(\"div\");\n  render(vm, container);\n  vm.component.exposed.onOpen();\n  const scrollContainer = parentNode == null ? void 0 : parentNode.querySelector(`.${ns}-scrollbar__wrap`);\n  removePopper = () => {\n    var _a2, _b;\n    if ((_b = (_a2 = vm.component) == null ? void 0 : _a2.exposed) == null ? void 0 : _b.onClose) {\n      vm.component.exposed.onClose();\n    }\n    render(null, container);\n    const currentRemovePopper = removePopper;\n    scrollContainer == null ? void 0 : scrollContainer.removeEventListener(\"scroll\", currentRemovePopper);\n    currentRemovePopper.trigger = void 0;\n    currentRemovePopper.vm = void 0;\n    removePopper = null;\n  };\n  removePopper.trigger = trigger != null ? trigger : void 0;\n  removePopper.vm = vm;\n  scrollContainer == null ? void 0 : scrollContainer.addEventListener(\"scroll\", removePopper);\n}\nfunction getCurrentColumns(column) {\n  if (column.children) {\n    return flatMap(column.children, getCurrentColumns);\n  } else {\n    return [column];\n  }\n}\nfunction getColSpan(colSpan, column) {\n  return colSpan + column.colSpan;\n}\nconst isFixedColumn = (index, fixed, store, realColumns) => {\n  let start = 0;\n  let after = index;\n  const columns = store.states.columns.value;\n  if (realColumns) {\n    const curColumns = getCurrentColumns(realColumns[index]);\n    const preColumns = columns.slice(0, columns.indexOf(curColumns[0]));\n    start = preColumns.reduce(getColSpan, 0);\n    after = start + curColumns.reduce(getColSpan, 0) - 1;\n  } else {\n    start = index;\n  }\n  let fixedLayout;\n  switch (fixed) {\n    case \"left\":\n      if (after < store.states.fixedLeafColumnsLength.value) {\n        fixedLayout = \"left\";\n      }\n      break;\n    case \"right\":\n      if (start >= columns.length - store.states.rightFixedLeafColumnsLength.value) {\n        fixedLayout = \"right\";\n      }\n      break;\n    default:\n      if (after < store.states.fixedLeafColumnsLength.value) {\n        fixedLayout = \"left\";\n      } else if (start >= columns.length - store.states.rightFixedLeafColumnsLength.value) {\n        fixedLayout = \"right\";\n      }\n  }\n  return fixedLayout ? {\n    direction: fixedLayout,\n    start,\n    after\n  } : {};\n};\nconst getFixedColumnsClass = (namespace, index, fixed, store, realColumns, offset = 0) => {\n  const classes = [];\n  const {\n    direction,\n    start,\n    after\n  } = isFixedColumn(index, fixed, store, realColumns);\n  if (direction) {\n    const isLeft = direction === \"left\";\n    classes.push(`${namespace}-fixed-column--${direction}`);\n    if (isLeft && after + offset === store.states.fixedLeafColumnsLength.value - 1) {\n      classes.push(\"is-last-column\");\n    } else if (!isLeft && start - offset === store.states.columns.value.length - store.states.rightFixedLeafColumnsLength.value) {\n      classes.push(\"is-first-column\");\n    }\n  }\n  return classes;\n};\nfunction getOffset(offset, column) {\n  return offset + (isNull(column.realWidth) || Number.isNaN(column.realWidth) ? Number(column.width) : column.realWidth);\n}\nconst getFixedColumnOffset = (index, fixed, store, realColumns) => {\n  const {\n    direction,\n    start = 0,\n    after = 0\n  } = isFixedColumn(index, fixed, store, realColumns);\n  if (!direction) {\n    return;\n  }\n  const styles = {};\n  const isLeft = direction === \"left\";\n  const columns = store.states.columns.value;\n  if (isLeft) {\n    styles.left = columns.slice(0, start).reduce(getOffset, 0);\n  } else {\n    styles.right = columns.slice(after + 1).reverse().reduce(getOffset, 0);\n  }\n  return styles;\n};\nconst ensurePosition = (style, key) => {\n  if (!style) return;\n  if (!Number.isNaN(style[key])) {\n    style[key] = `${style[key]}px`;\n  }\n};\nfunction ensureValidVNode(vnodes) {\n  return vnodes.some(child => {\n    if (!isVNode(child)) return true;\n    if (child.type === Comment) return false;\n    if (child.type === Fragment && !ensureValidVNode(child.children)) {\n      return false;\n    }\n    return true;\n  }) ? vnodes : null;\n}\nexport { compose, createTablePopper, ensurePosition, ensureValidVNode, getCell, getColumnByCell, getColumnById, getColumnByKey, getFixedColumnOffset, getFixedColumnsClass, getKeysMap, getRowIdentity, isFixedColumn, mergeOptions, orderBy, parseHeight, parseMinWidth, parseWidth, removePopper, toggleRowStatus, walkTreeNode };","map":{"version":3,"names":["getCell","event","_a","target","closest","orderBy","array","sortKey","reverse","sortMethod","sortBy","isArray","length","isString","getKey","value","index","flatMap","castArray","by","get","isObject","$value","compare","a","b","_b","_c","_d","_e","_f","i","len","key","map","sort","order","item","getColumnById","table","columnId","column","columns","forEach","id","getColumnByKey","columnKey","throwError","getColumnByCell","cell","namespace","matches","className","match","RegExp","getRowIdentity","row","rowKey","Error","includes","split","current","element","isFunction","call","getKeysMap","flatten","childrenKey","data","arrayMap","children","Object","assign","mergeOptions","defaults","config","options","hasOwn","isUndefined","parseWidth","width","Number","parseInt","isNaN","parseMinWidth","minWidth","parseHeight","height","isNumber","test","compose","funcs","arg","reduce","args","toggleRowStatus","statusArr","newVal","tableTreeProps","selectable","rowIndex","_rowIndex","changed","getIndex","indexOf","findIndex","included","isRowSelectable","toggleStatus","type","push","splice","getChildrenCount","row2","count","isBoolean","checkStrictly","childChanged","walkTreeNode","root","cb","lazyKey","lazy","isNil","_walker","parent","level","children2","getTableOverflowTooltipProps","props","innerText","popperOptions","strategy","tooltipFormatterContent","tooltipFormatter","cellValue","getProp","property","isVNode","slotContent","content","removePopper","createTablePopper","popperContent","trigger","tableOverflowTooltipProps","mergedProps","comp","vm","component","merge","slots","parentNode","refs","tableWrapper","ns","dataset","prefix","createVNode","ElTooltip","virtualTriggering","virtualRef","appendTo","placement","transition","offset","hideAfter","appContext","container","document","createElement","render","exposed","onOpen","scrollContainer","querySelector","_a2","onClose","currentRemovePopper","removeEventListener","addEventListener","getCurrentColumns","getColSpan","colSpan","isFixedColumn","fixed","store","realColumns","start","after","states","curColumns","preColumns","slice","fixedLayout","fixedLeafColumnsLength","rightFixedLeafColumnsLength","direction","getFixedColumnsClass","classes","isLeft","getOffset","isNull","realWidth","getFixedColumnOffset","styles","left","right","ensurePosition","style","ensureValidVNode","vnodes","some","child","Comment","Fragment"],"sources":["../../../../../../packages/components/table/src/util.ts"],"sourcesContent":["import { Comment, Fragment, createVNode, isVNode, render } from 'vue'\nimport { flatMap, get, isNull, merge } from 'lodash-unified'\nimport {\n  ensureArray,\n  getProp,\n  hasOwn,\n  isArray,\n  isBoolean,\n  isFunction,\n  isNumber,\n  isObject,\n  isString,\n  isUndefined,\n  throwError,\n} from '@element-plus/utils'\nimport ElTooltip, {\n  type ElTooltipProps,\n} from '@element-plus/components/tooltip'\n\nimport type { DefaultRow, Table, TreeProps } from './table/defaults'\nimport type { TableColumnCtx } from './table-column/defaults'\nimport type { CSSProperties, VNode, VNodeArrayChildren } from 'vue'\n\nexport type TableOverflowTooltipOptions = Partial<\n  Pick<\n    ElTooltipProps,\n    | 'appendTo'\n    | 'effect'\n    | 'enterable'\n    | 'hideAfter'\n    | 'offset'\n    | 'placement'\n    | 'popperClass'\n    | 'popperOptions'\n    | 'showAfter'\n    | 'showArrow'\n    | 'transition'\n  >\n>\n\nexport type TableOverflowTooltipFormatter<T extends DefaultRow> = (data: {\n  row: T\n  column: TableColumnCtx<T>\n  cellValue: any\n}) => VNode | string\n\ntype RemovePopperFn = (() => void) & {\n  trigger?: HTMLElement\n  vm?: VNode\n}\n\ntype CompareValue<T> = {\n  value: T\n  index: number\n  key: any[] | null\n}\n\nexport const getCell = function (event: Event) {\n  return (event.target as HTMLElement)?.closest('td')\n}\n\nexport const orderBy = function <T extends DefaultRow>(\n  array: T[],\n  sortKey: string | null,\n  reverse: string | number | null,\n  sortMethod: TableColumnCtx<T>['sortMethod'] | null,\n  sortBy: string | string[] | ((a: T, index: number, array?: T[]) => string)\n) {\n  if (\n    !sortKey &&\n    !sortMethod &&\n    (!sortBy || (isArray(sortBy) && !sortBy.length))\n  ) {\n    return array\n  }\n  if (isString(reverse)) {\n    reverse = reverse === 'descending' ? -1 : 1\n  } else {\n    reverse = reverse && reverse < 0 ? -1 : 1\n  }\n  const getKey = sortMethod\n    ? null\n    : function (value: T, index: number) {\n        if (sortBy) {\n          return flatMap(ensureArray(sortBy), (by) => {\n            if (isString(by)) {\n              return get(value, by)\n            } else {\n              return by(value, index, array)\n            }\n          })\n        }\n        if (sortKey !== '$key') {\n          if (isObject(value) && '$value' in value) value = value.$value\n        }\n        return [\n          isObject(value) ? (sortKey ? get(value, sortKey) : null) : value,\n        ]\n      }\n  const compare = function (a: CompareValue<T>, b: CompareValue<T>) {\n    if (sortMethod) {\n      return sortMethod(a.value, b.value)\n    }\n    for (let i = 0, len = a.key?.length ?? 0; i < len; i++) {\n      if (a.key?.[i] < b.key?.[i]) {\n        return -1\n      }\n      if (a.key?.[i] > b.key?.[i]) {\n        return 1\n      }\n    }\n    return 0\n  }\n  return array\n    .map<CompareValue<T>>((value: T, index) => {\n      return {\n        value,\n        index,\n        key: getKey ? getKey(value, index) : null,\n      }\n    })\n    .sort((a, b) => {\n      let order = compare(a, b)\n      if (!order) {\n        // make stable https://en.wikipedia.org/wiki/Sorting_algorithm#Stability\n        order = a.index - b.index\n      }\n      return order * +reverse\n    })\n    .map((item) => item.value)\n}\n\nexport const getColumnById = function <T extends DefaultRow>(\n  table: {\n    columns: TableColumnCtx<T>[]\n  },\n  columnId: string\n): null | TableColumnCtx<T> {\n  let column = null\n  table.columns.forEach((item) => {\n    if (item.id === columnId) {\n      column = item\n    }\n  })\n  return column\n}\n\nexport const getColumnByKey = function <T extends DefaultRow>(\n  table: {\n    columns: TableColumnCtx<T>[]\n  },\n  columnKey: string\n): TableColumnCtx<T> {\n  let column = null\n  for (let i = 0; i < table.columns.length; i++) {\n    const item = table.columns[i]\n    if (item.columnKey === columnKey) {\n      column = item\n      break\n    }\n  }\n  if (!column)\n    throwError('ElTable', `No column matching with column-key: ${columnKey}`)\n  return column\n}\n\nexport const getColumnByCell = function <T extends DefaultRow>(\n  table: {\n    columns: TableColumnCtx<T>[]\n  },\n  cell: HTMLElement,\n  namespace: string\n): null | TableColumnCtx<T> {\n  const matches = (cell.className || '').match(\n    new RegExp(`${namespace}-table_[^\\\\s]+`, 'gm')\n  )\n  if (matches) {\n    return getColumnById(table, matches[0])\n  }\n  return null\n}\n\nexport const getRowIdentity = <T extends DefaultRow>(\n  row: T,\n  rowKey: string | ((row: T) => string) | null\n): string => {\n  if (!row) throw new Error('Row is required when get row identity')\n  if (isString(rowKey)) {\n    if (!rowKey.includes('.')) {\n      return `${row[rowKey]}`\n    }\n    const key = rowKey.split('.')\n    let current: any = row\n    for (const element of key) {\n      current = current[element]\n    }\n    //TODO: \"current\" is now any, we just satisfies typecheck here\n    // but this function can actually return a number\n    return `${current}`\n  } else if (isFunction(rowKey)) {\n    return rowKey.call(null, row)\n  }\n  return ''\n}\n\nexport const getKeysMap = function <T extends DefaultRow>(\n  array: T[],\n  rowKey: string | null,\n  flatten = false,\n  childrenKey = 'children'\n): Record<PropertyKey, { row: T; index: number }> {\n  const data = array || []\n  const arrayMap: Record<string, { row: T; index: number }> = {}\n\n  data.forEach((row, index) => {\n    arrayMap[getRowIdentity(row, rowKey)] = { row, index }\n\n    if (flatten) {\n      const children = row[childrenKey]\n      if (isArray(children)) {\n        Object.assign(arrayMap, getKeysMap(children, rowKey, true, childrenKey))\n      }\n    }\n  })\n\n  return arrayMap\n}\n\nexport function mergeOptions<T extends DefaultRow, K extends DefaultRow>(\n  defaults: T,\n  config: K\n): T & K {\n  const options = {} as T & K\n  let key: keyof T & keyof K\n  for (key in defaults) {\n    options[key] = defaults[key]\n  }\n  for (key in config) {\n    if (hasOwn(config, key)) {\n      const value = config[key]\n      if (!isUndefined(value)) {\n        options[key as keyof K] = value\n      }\n    }\n  }\n  return options\n}\n\nexport function parseWidth(width?: number | string): number | string {\n  if (width === '') return width\n  if (!isUndefined(width)) {\n    width = Number.parseInt(width as string, 10)\n    if (Number.isNaN(width)) {\n      width = ''\n    }\n  }\n  return width!\n}\n\nexport function parseMinWidth(minWidth: number | string): number | string {\n  if (minWidth === '') return minWidth\n  if (!isUndefined(minWidth)) {\n    minWidth = parseWidth(minWidth)\n    if (Number.isNaN(minWidth)) {\n      minWidth = 80\n    }\n  }\n  return minWidth\n}\n\nexport function parseHeight(height: number | string | null) {\n  if (isNumber(height)) {\n    return height\n  }\n  if (isString(height)) {\n    if (/^\\d+(?:px)?$/.test(height)) {\n      return Number.parseInt(height, 10)\n    } else {\n      return height\n    }\n  }\n  return null\n}\n\n// https://github.com/reduxjs/redux/blob/master/src/compose.ts\nexport function compose(...funcs: ((...args: any[]) => void)[]) {\n  if (funcs.length === 0) {\n    return <T>(arg: T) => arg\n  }\n  if (funcs.length === 1) {\n    return funcs[0]\n  }\n  return funcs.reduce(\n    (a, b) =>\n      (...args: any[]) =>\n        a(b(...args))\n  )\n}\n\nexport function toggleRowStatus<T extends DefaultRow>(\n  statusArr: T[],\n  row: T,\n  newVal?: boolean,\n  tableTreeProps?: TreeProps,\n  selectable?: ((row: T, index: number) => boolean) | null,\n  rowIndex?: number,\n  rowKey?: string | null\n): boolean {\n  let _rowIndex = rowIndex ?? 0\n  let changed = false\n\n  const getIndex = () => {\n    if (!rowKey) {\n      return statusArr.indexOf(row)\n    }\n\n    const id = getRowIdentity(row, rowKey)\n\n    return statusArr.findIndex((item) => getRowIdentity(item, rowKey) === id)\n  }\n\n  const index = getIndex()\n\n  const included = index !== -1\n  const isRowSelectable = selectable?.call(null, row, _rowIndex)\n\n  const toggleStatus = (type: 'add' | 'remove') => {\n    if (type === 'add') {\n      statusArr.push(row)\n    } else {\n      statusArr.splice(index, 1)\n    }\n    changed = true\n  }\n  const getChildrenCount = <T extends DefaultRow>(row: T) => {\n    let count = 0\n    const children = tableTreeProps?.children && row[tableTreeProps.children]\n    if (children && isArray(children)) {\n      count += children.length\n      children.forEach((item) => {\n        count += getChildrenCount(item)\n      })\n    }\n    return count\n  }\n\n  if (!selectable || isRowSelectable) {\n    if (isBoolean(newVal)) {\n      if (newVal && !included) {\n        toggleStatus('add')\n      } else if (!newVal && included) {\n        toggleStatus('remove')\n      }\n    } else {\n      included ? toggleStatus('remove') : toggleStatus('add')\n    }\n  }\n\n  if (\n    !tableTreeProps?.checkStrictly &&\n    tableTreeProps?.children &&\n    isArray(row[tableTreeProps.children])\n  ) {\n    row[tableTreeProps.children].forEach((item: T) => {\n      const childChanged = toggleRowStatus(\n        statusArr,\n        item,\n        newVal ?? !included,\n        tableTreeProps,\n        selectable,\n        _rowIndex + 1,\n        rowKey\n      )\n      _rowIndex += getChildrenCount(item) + 1\n      if (childChanged) {\n        changed = childChanged\n      }\n    })\n  }\n  return changed\n}\n\nexport function walkTreeNode<T extends DefaultRow>(\n  root: T[],\n  cb: (parent: any, children: T | T[] | null, level: number) => void,\n  childrenKey = 'children',\n  lazyKey = 'hasChildren',\n  lazy = false\n) {\n  const isNil = (array: any): array is null => !(isArray(array) && array.length)\n\n  function _walker(parent: any, children: T | T[], level: number) {\n    cb(parent, children, level)\n    children.forEach((item: any) => {\n      if (item[lazyKey] && lazy) {\n        cb(item, null, level + 1)\n        return\n      }\n      const children = item[childrenKey]\n      if (!isNil(children)) {\n        _walker(item, children, level + 1)\n      }\n    })\n  }\n\n  root.forEach((item: any) => {\n    if (item[lazyKey] && lazy) {\n      cb(item, null, 0)\n      return\n    }\n    const children = item[childrenKey]\n    if (!isNil(children)) {\n      _walker(item, children, 0)\n    }\n  })\n}\n\nconst getTableOverflowTooltipProps = <T extends DefaultRow>(\n  props: TableOverflowTooltipOptions,\n  innerText: string,\n  row: T,\n  column: TableColumnCtx<T> | null\n) => {\n  // merge popperOptions\n  const popperOptions = {\n    strategy: 'fixed',\n    ...props.popperOptions,\n  }\n\n  const tooltipFormatterContent = isFunction(column?.tooltipFormatter)\n    ? column.tooltipFormatter({\n        row,\n        column,\n        cellValue: getProp(row, column.property).value,\n      })\n    : undefined\n\n  if (isVNode(tooltipFormatterContent)) {\n    return {\n      slotContent: tooltipFormatterContent,\n      content: null,\n      ...props,\n      popperOptions,\n    }\n  }\n\n  return {\n    slotContent: null,\n    content: tooltipFormatterContent ?? innerText,\n    ...props,\n    popperOptions,\n  }\n}\n\nexport let removePopper: RemovePopperFn | null = null\n\nexport function createTablePopper<T extends DefaultRow>(\n  props: TableOverflowTooltipOptions,\n  popperContent: string,\n  row: T,\n  column: TableColumnCtx<T> | null,\n  trigger: HTMLElement | null,\n  table: Table<DefaultRow>\n) {\n  const tableOverflowTooltipProps = getTableOverflowTooltipProps(\n    props,\n    popperContent,\n    row,\n    column\n  )\n  const mergedProps = {\n    ...tableOverflowTooltipProps,\n    slotContent: undefined,\n  }\n  if (removePopper?.trigger === trigger) {\n    const comp = removePopper.vm?.component\n    merge(comp?.props, mergedProps)\n    if (comp && tableOverflowTooltipProps.slotContent) {\n      comp.slots.content = () => [tableOverflowTooltipProps.slotContent]\n    }\n    return\n  }\n  removePopper?.()\n  const parentNode = table?.refs.tableWrapper\n  const ns = parentNode?.dataset.prefix\n  const vm = createVNode(\n    ElTooltip,\n    {\n      virtualTriggering: true,\n      virtualRef: trigger,\n      appendTo: parentNode,\n      placement: 'top',\n      transition: 'none', // Default does not require transition\n      offset: 0,\n      hideAfter: 0,\n      ...mergedProps,\n    },\n    tableOverflowTooltipProps.slotContent\n      ? {\n          content: () => tableOverflowTooltipProps.slotContent,\n        }\n      : undefined\n  )\n  vm.appContext = { ...table.appContext, ...table }\n  const container = document.createElement('div')\n  render(vm, container)\n  vm.component!.exposed!.onOpen()\n  const scrollContainer = parentNode?.querySelector(`.${ns}-scrollbar__wrap`)\n  removePopper = () => {\n    if (vm.component?.exposed?.onClose) {\n      vm.component.exposed.onClose()\n    }\n    render(null, container)\n    const currentRemovePopper = removePopper as RemovePopperFn\n    scrollContainer?.removeEventListener('scroll', currentRemovePopper)\n    currentRemovePopper.trigger = undefined\n    currentRemovePopper.vm = undefined\n    removePopper = null\n  }\n  removePopper.trigger = trigger ?? undefined\n  removePopper.vm = vm\n  scrollContainer?.addEventListener('scroll', removePopper)\n}\n\nfunction getCurrentColumns<T extends DefaultRow>(\n  column: TableColumnCtx<T>\n): TableColumnCtx<T>[] {\n  if (column.children) {\n    return flatMap(column.children, getCurrentColumns)\n  } else {\n    return [column]\n  }\n}\n\nfunction getColSpan<T extends DefaultRow>(\n  colSpan: number,\n  column: TableColumnCtx<T>\n) {\n  return colSpan + column.colSpan\n}\n\nexport const isFixedColumn = <T extends DefaultRow>(\n  index: number,\n  fixed: string | boolean | undefined,\n  store: any,\n  realColumns?: TableColumnCtx<T>[]\n) => {\n  let start = 0\n  let after = index\n  const columns = store.states.columns.value\n  if (realColumns) {\n    // fixed column supported in grouped header\n    const curColumns = getCurrentColumns(realColumns[index])\n    const preColumns = columns.slice(0, columns.indexOf(curColumns[0]))\n\n    start = preColumns.reduce(getColSpan, 0)\n    after = start + curColumns.reduce(getColSpan, 0) - 1\n  } else {\n    start = index\n  }\n  let fixedLayout\n  switch (fixed) {\n    case 'left':\n      if (after < store.states.fixedLeafColumnsLength.value) {\n        fixedLayout = 'left'\n      }\n      break\n    case 'right':\n      if (\n        start >=\n        columns.length - store.states.rightFixedLeafColumnsLength.value\n      ) {\n        fixedLayout = 'right'\n      }\n      break\n    default:\n      if (after < store.states.fixedLeafColumnsLength.value) {\n        fixedLayout = 'left'\n      } else if (\n        start >=\n        columns.length - store.states.rightFixedLeafColumnsLength.value\n      ) {\n        fixedLayout = 'right'\n      }\n  }\n  return fixedLayout\n    ? {\n        direction: fixedLayout,\n        start,\n        after,\n      }\n    : {}\n}\n\nexport const getFixedColumnsClass = <T extends DefaultRow>(\n  namespace: string,\n  index: number,\n  fixed: string | boolean | undefined,\n  store: any,\n  realColumns?: TableColumnCtx<T>[],\n  offset = 0\n) => {\n  const classes: string[] = []\n  const { direction, start, after } = isFixedColumn(\n    index,\n    fixed,\n    store,\n    realColumns\n  )\n  if (direction) {\n    const isLeft = direction === 'left'\n    classes.push(`${namespace}-fixed-column--${direction}`)\n    if (\n      isLeft &&\n      after + offset === store.states.fixedLeafColumnsLength.value - 1\n    ) {\n      classes.push('is-last-column')\n    } else if (\n      !isLeft &&\n      start - offset ===\n        store.states.columns.value.length -\n          store.states.rightFixedLeafColumnsLength.value\n    ) {\n      classes.push('is-first-column')\n    }\n  }\n  return classes\n}\n\nfunction getOffset<T extends DefaultRow>(\n  offset: number,\n  column: TableColumnCtx<T>\n) {\n  return (\n    offset +\n    (isNull(column.realWidth) || Number.isNaN(column.realWidth)\n      ? Number(column.width)\n      : column.realWidth)\n  )\n}\n\nexport const getFixedColumnOffset = <T extends DefaultRow>(\n  index: number,\n  fixed: string | boolean | undefined,\n  store: any,\n  realColumns?: TableColumnCtx<T>[]\n) => {\n  const {\n    direction,\n    start = 0,\n    after = 0,\n  } = isFixedColumn(index, fixed, store, realColumns)\n  if (!direction) {\n    return\n  }\n  const styles: CSSProperties = {}\n  const isLeft = direction === 'left'\n  const columns = store.states.columns.value\n  if (isLeft) {\n    styles.left = columns.slice(0, start).reduce(getOffset, 0)\n  } else {\n    styles.right = columns\n      .slice(after + 1)\n      .reverse()\n      .reduce(getOffset, 0)\n  }\n  return styles\n}\n\nexport const ensurePosition = <T extends CSSProperties>(\n  style: T | undefined,\n  key: keyof T\n) => {\n  if (!style) return\n  if (!Number.isNaN(style[key])) {\n    style[key] = `${style[key]}px` as any\n  }\n}\n\nexport function ensureValidVNode(\n  vnodes: VNodeArrayChildren\n): VNodeArrayChildren | null {\n  return vnodes.some((child) => {\n    if (!isVNode(child)) return true\n    if (child.type === Comment) return false\n    if (\n      child.type === Fragment &&\n      !ensureValidVNode(child.children as VNodeArrayChildren)\n    ) {\n      return false\n    }\n    return true\n  })\n    ? vnodes\n    : null\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}