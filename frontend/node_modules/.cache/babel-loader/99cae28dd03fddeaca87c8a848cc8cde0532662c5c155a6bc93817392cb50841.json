{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport { isVNode, createVNode, render } from 'vue';\nimport NotificationConstructor from './notification2.mjs';\nimport { notificationTypes } from './notification.mjs';\nimport { isClient } from '@vueuse/core';\nimport { isString, isFunction } from '@vue/shared';\nimport { isElement, isUndefined } from '../../../utils/types.mjs';\nimport { debugWarn } from '../../../utils/error.mjs';\nconst notifications = {\n  \"top-left\": [],\n  \"top-right\": [],\n  \"bottom-left\": [],\n  \"bottom-right\": []\n};\nconst GAP_SIZE = 16;\nlet seed = 1;\nconst notify = function (options = {}, context) {\n  if (!isClient) return {\n    close: () => void 0\n  };\n  if (isString(options) || isVNode(options)) {\n    options = {\n      message: options\n    };\n  }\n  const position = options.position || \"top-right\";\n  let verticalOffset = options.offset || 0;\n  notifications[position].forEach(({\n    vm: vm2\n  }) => {\n    var _a;\n    verticalOffset += (((_a = vm2.el) == null ? void 0 : _a.offsetHeight) || 0) + GAP_SIZE;\n  });\n  verticalOffset += GAP_SIZE;\n  const id = `notification_${seed++}`;\n  const userOnClose = options.onClose;\n  const props = {\n    ...options,\n    offset: verticalOffset,\n    id,\n    onClose: () => {\n      close(id, position, userOnClose);\n    }\n  };\n  let appendTo = document.body;\n  if (isElement(options.appendTo)) {\n    appendTo = options.appendTo;\n  } else if (isString(options.appendTo)) {\n    appendTo = document.querySelector(options.appendTo);\n  }\n  if (!isElement(appendTo)) {\n    debugWarn(\"ElNotification\", \"the appendTo option is not an HTMLElement. Falling back to document.body.\");\n    appendTo = document.body;\n  }\n  const container = document.createElement(\"div\");\n  const vm = createVNode(NotificationConstructor, props, isFunction(props.message) ? props.message : isVNode(props.message) ? () => props.message : null);\n  vm.appContext = isUndefined(context) ? notify._context : context;\n  vm.props.onDestroy = () => {\n    render(null, container);\n  };\n  render(vm, container);\n  notifications[position].push({\n    vm\n  });\n  appendTo.appendChild(container.firstElementChild);\n  return {\n    close: () => {\n      vm.component.exposed.visible.value = false;\n    }\n  };\n};\nnotificationTypes.forEach(type => {\n  notify[type] = (options = {}, appContext) => {\n    if (isString(options) || isVNode(options)) {\n      options = {\n        message: options\n      };\n    }\n    return notify({\n      ...options,\n      type\n    }, appContext);\n  };\n});\nfunction close(id, position, userOnClose) {\n  const orientedNotifications = notifications[position];\n  const idx = orientedNotifications.findIndex(({\n    vm: vm2\n  }) => {\n    var _a;\n    return ((_a = vm2.component) == null ? void 0 : _a.props.id) === id;\n  });\n  if (idx === -1) return;\n  const {\n    vm\n  } = orientedNotifications[idx];\n  if (!vm) return;\n  userOnClose == null ? void 0 : userOnClose(vm);\n  const removedHeight = vm.el.offsetHeight;\n  const verticalPos = position.split(\"-\")[0];\n  orientedNotifications.splice(idx, 1);\n  const len = orientedNotifications.length;\n  if (len < 1) return;\n  for (let i = idx; i < len; i++) {\n    const {\n      el,\n      component\n    } = orientedNotifications[i].vm;\n    const pos = Number.parseInt(el.style[verticalPos], 10) - removedHeight - GAP_SIZE;\n    component.props.offset = pos;\n  }\n}\nfunction closeAll() {\n  for (const orientedNotifications of Object.values(notifications)) {\n    orientedNotifications.forEach(({\n      vm\n    }) => {\n      vm.component.exposed.visible.value = false;\n    });\n  }\n}\nfunction updateOffsets(position = \"top-right\") {\n  var _a, _b, _c, _d;\n  let verticalOffset = ((_c = (_b = (_a = notifications[position][0]) == null ? void 0 : _a.vm.component) == null ? void 0 : _b.props) == null ? void 0 : _c.offset) || 0;\n  for (const {\n    vm\n  } of notifications[position]) {\n    vm.component.props.offset = verticalOffset;\n    verticalOffset += (((_d = vm.el) == null ? void 0 : _d.offsetHeight) || 0) + GAP_SIZE;\n  }\n}\nnotify.closeAll = closeAll;\nnotify.updateOffsets = updateOffsets;\nnotify._context = null;\nexport { close, closeAll, notify as default, updateOffsets };","map":{"version":3,"names":["notifications","GAP_SIZE","seed","notify","options","context","isClient","close","isString","isVNode","message","position","verticalOffset","offset","forEach","vm","vm2","_a","el","offsetHeight","id","userOnClose","onClose","props","appendTo","document","body","isElement","querySelector","debugWarn","container","createElement","createVNode","NotificationConstructor","isFunction","appContext","isUndefined","_context","onDestroy","render","push","appendChild","firstElementChild","component","exposed","visible","value","notificationTypes","type","orientedNotifications","idx","findIndex","removedHeight","verticalPos","split","splice","len","length","i","pos","Number","parseInt","style","closeAll","Object","values","updateOffsets","_b","_c","_d"],"sources":["../../../../../../packages/components/notification/src/notify.ts"],"sourcesContent":["import { createVNode, isVNode, render } from 'vue'\nimport {\n  debugWarn,\n  isClient,\n  isElement,\n  isFunction,\n  isString,\n  isUndefined,\n} from '@element-plus/utils'\nimport NotificationConstructor from './notification.vue'\nimport { notificationTypes } from './notification'\n\nimport type { Ref, VNode } from 'vue'\nimport type {\n  NotificationOptions,\n  NotificationProps,\n  NotificationQueue,\n  Notify,\n  NotifyFn,\n} from './notification'\n\n// This should be a queue but considering there were `non-autoclosable` notifications.\nconst notifications: Record<\n  NotificationOptions['position'],\n  NotificationQueue\n> = {\n  'top-left': [],\n  'top-right': [],\n  'bottom-left': [],\n  'bottom-right': [],\n}\n\n// the gap size between each notification\nconst GAP_SIZE = 16\nlet seed = 1\n\nconst notify: NotifyFn & Partial<Notify> = function (options = {}, context) {\n  if (!isClient) return { close: () => undefined }\n\n  if (isString(options) || isVNode(options)) {\n    options = { message: options }\n  }\n\n  const position = options.position || 'top-right'\n\n  let verticalOffset = options.offset || 0\n  notifications[position].forEach(({ vm }) => {\n    verticalOffset += (vm.el?.offsetHeight || 0) + GAP_SIZE\n  })\n  verticalOffset += GAP_SIZE\n\n  const id = `notification_${seed++}`\n  const userOnClose = options.onClose\n  const props: Partial<NotificationProps> = {\n    ...options,\n    offset: verticalOffset,\n    id,\n    onClose: () => {\n      close(id, position, userOnClose)\n    },\n  }\n\n  let appendTo: HTMLElement | null = document.body\n  if (isElement(options.appendTo)) {\n    appendTo = options.appendTo\n  } else if (isString(options.appendTo)) {\n    appendTo = document.querySelector(options.appendTo)\n  }\n\n  // should fallback to default value with a warning\n  if (!isElement(appendTo)) {\n    debugWarn(\n      'ElNotification',\n      'the appendTo option is not an HTMLElement. Falling back to document.body.'\n    )\n    appendTo = document.body\n  }\n\n  const container = document.createElement('div')\n\n  const vm = createVNode(\n    NotificationConstructor,\n    props,\n    isFunction(props.message)\n      ? props.message\n      : isVNode(props.message)\n        ? () => props.message\n        : null\n  )\n  vm.appContext = isUndefined(context) ? notify._context : context\n\n  // clean notification element preventing mem leak\n  vm.props!.onDestroy = () => {\n    render(null, container)\n  }\n\n  // instances will remove this item when close function gets called. So we do not need to worry about it.\n  render(vm, container)\n  notifications[position].push({ vm })\n  appendTo.appendChild(container.firstElementChild!)\n\n  return {\n    // instead of calling the onClose function directly, setting this value so that we can have the full lifecycle\n    // for out component, so that all closing steps will not be skipped.\n    close: () => {\n      ;(vm.component!.exposed as { visible: Ref<boolean> }).visible.value =\n        false\n    },\n  }\n}\nnotificationTypes.forEach((type) => {\n  notify[type] = (options = {}, appContext) => {\n    if (isString(options) || isVNode(options)) {\n      options = {\n        message: options,\n      }\n    }\n    return notify({ ...options, type }, appContext)\n  }\n})\n\n/**\n * This function gets called when user click `x` button or press `esc` or the time reached its limitation.\n * Emitted by transition@before-leave event so that we can fetch the current notification.offsetHeight, if this was called\n * by @after-leave the DOM element will be removed from the page thus we can no longer fetch the offsetHeight.\n * @param {String} id notification id to be closed\n * @param {Position} position the positioning strategy\n * @param {Function} userOnClose the callback called when close passed by user\n */\nexport function close(\n  id: string,\n  position: NotificationOptions['position'],\n  userOnClose?: (vm: VNode) => void\n): void {\n  // maybe we can store the index when inserting the vm to notification list.\n  const orientedNotifications = notifications[position]\n  const idx = orientedNotifications.findIndex(\n    ({ vm }) => vm.component?.props.id === id\n  )\n  if (idx === -1) return\n  const { vm } = orientedNotifications[idx]\n  if (!vm) return\n  // calling user's on close function before notification gets removed from DOM.\n  userOnClose?.(vm)\n\n  // note that this is called @before-leave, that's why we were able to fetch this property.\n  const removedHeight = vm.el!.offsetHeight\n  const verticalPos = position.split('-')[0]\n  orientedNotifications.splice(idx, 1)\n  const len = orientedNotifications.length\n  if (len < 1) return\n  // starting from the removing item.\n  for (let i = idx; i < len; i++) {\n    // new position equals the current offsetTop minus removed height plus 16px(the gap size between each item)\n    const { el, component } = orientedNotifications[i].vm\n    const pos =\n      Number.parseInt(el!.style[verticalPos], 10) - removedHeight - GAP_SIZE\n    component!.props.offset = pos\n  }\n}\n\nexport function closeAll(): void {\n  // loop through all directions, close them at once.\n  for (const orientedNotifications of Object.values(notifications)) {\n    orientedNotifications.forEach(({ vm }) => {\n      // same as the previous close method, we'd like to make sure lifecycle gets handle properly.\n      ;(vm.component!.exposed as { visible: Ref<boolean> }).visible.value =\n        false\n    })\n  }\n}\n\nexport function updateOffsets(\n  position: NotificationOptions['position'] = 'top-right'\n) {\n  let verticalOffset =\n    notifications[position][0]?.vm.component?.props?.offset || 0\n\n  for (const { vm } of notifications[position]) {\n    vm.component!.props.offset = verticalOffset\n    verticalOffset += (vm.el?.offsetHeight || 0) + GAP_SIZE\n  }\n}\n\nnotify.closeAll = closeAll\nnotify.updateOffsets = updateOffsets\nnotify._context = null\n\nexport default notify as Notify\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}