{"ast":null,"code":"import \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport { onMounted, onUpdated } from 'vue';\nimport { useEventListener } from '@vueuse/core';\nimport { useNamespace } from '../../../../hooks/use-namespace/index.mjs';\nimport { getEventCode } from '../../../../utils/dom/event.mjs';\nimport { EVENT_CODE } from '../../../../constants/aria.mjs';\nfunction useKeydown({\n  el$\n}, store) {\n  const ns = useNamespace(\"tree\");\n  onMounted(() => {\n    initTabIndex();\n  });\n  onUpdated(() => {\n    var _a;\n    (_a = el$.value) == null ? void 0 : _a.querySelectorAll(\"input[type=checkbox]\").forEach(checkbox => {\n      checkbox.setAttribute(\"tabindex\", \"-1\");\n    });\n  });\n  function canNodeFocus(treeItems, nextIndex) {\n    var _a, _b;\n    const currentNode = store.value.getNode(treeItems[nextIndex].dataset.key);\n    return currentNode.canFocus && currentNode.visible && (((_a = currentNode.parent) == null ? void 0 : _a.expanded) || ((_b = currentNode.parent) == null ? void 0 : _b.level) === 0);\n  }\n  const handleKeydown = ev => {\n    const currentItem = ev.target;\n    if (!currentItem.className.includes(ns.b(\"node\"))) return;\n    const code = getEventCode(ev);\n    const treeItems = Array.from(el$.value.querySelectorAll(`.${ns.is(\"focusable\")}[role=treeitem]`));\n    const currentIndex = treeItems.indexOf(currentItem);\n    let nextIndex;\n    if ([EVENT_CODE.up, EVENT_CODE.down].includes(code)) {\n      ev.preventDefault();\n      if (code === EVENT_CODE.up) {\n        nextIndex = currentIndex === -1 ? 0 : currentIndex !== 0 ? currentIndex - 1 : treeItems.length - 1;\n        const startIndex = nextIndex;\n        while (true) {\n          if (canNodeFocus(treeItems, nextIndex)) {\n            break;\n          }\n          nextIndex--;\n          if (nextIndex === startIndex) {\n            nextIndex = -1;\n            break;\n          }\n          if (nextIndex < 0) {\n            nextIndex = treeItems.length - 1;\n          }\n        }\n      } else {\n        nextIndex = currentIndex === -1 ? 0 : currentIndex < treeItems.length - 1 ? currentIndex + 1 : 0;\n        const startIndex = nextIndex;\n        while (true) {\n          if (canNodeFocus(treeItems, nextIndex)) {\n            break;\n          }\n          nextIndex++;\n          if (nextIndex === startIndex) {\n            nextIndex = -1;\n            break;\n          }\n          if (nextIndex >= treeItems.length) {\n            nextIndex = 0;\n          }\n        }\n      }\n      nextIndex !== -1 && treeItems[nextIndex].focus();\n    }\n    if ([EVENT_CODE.left, EVENT_CODE.right].includes(code)) {\n      ev.preventDefault();\n      currentItem.click();\n    }\n    const hasInput = currentItem.querySelector('[type=\"checkbox\"]');\n    if ([EVENT_CODE.enter, EVENT_CODE.numpadEnter, EVENT_CODE.space].includes(code) && hasInput) {\n      ev.preventDefault();\n      hasInput.click();\n    }\n  };\n  useEventListener(el$, \"keydown\", handleKeydown);\n  const initTabIndex = () => {\n    var _a;\n    if (!el$.value) return;\n    const treeItems = Array.from(el$.value.querySelectorAll(`.${ns.is(\"focusable\")}[role=treeitem]`));\n    const checkboxItems = Array.from(el$.value.querySelectorAll(\"input[type=checkbox]\"));\n    checkboxItems.forEach(checkbox => {\n      checkbox.setAttribute(\"tabindex\", \"-1\");\n    });\n    const checkedItem = el$.value.querySelectorAll(`.${ns.is(\"checked\")}[role=treeitem]`);\n    if (checkedItem.length) {\n      checkedItem[0].setAttribute(\"tabindex\", \"0\");\n      return;\n    }\n    (_a = treeItems[0]) == null ? void 0 : _a.setAttribute(\"tabindex\", \"0\");\n  };\n}\nexport { useKeydown };","map":{"version":3,"names":["useKeydown","el$","store","ns","useNamespace","onMounted","initTabIndex","onUpdated","_a","value","querySelectorAll","forEach","checkbox","setAttribute","canNodeFocus","treeItems","nextIndex","_b","currentNode","getNode","dataset","key","canFocus","visible","parent","expanded","level","handleKeydown","ev","currentItem","target","className","includes","b","code","getEventCode","Array","from","is","currentIndex","indexOf","EVENT_CODE","up","down","preventDefault","length","startIndex","focus","left","right","click","hasInput","querySelector","enter","numpadEnter","space","useEventListener","checkboxItems","checkedItem"],"sources":["../../../../../../../packages/components/tree/src/model/useKeydown.ts"],"sourcesContent":["import { onMounted, onUpdated } from 'vue'\nimport { useEventListener } from '@vueuse/core'\nimport { EVENT_CODE } from '@element-plus/constants'\nimport { useNamespace } from '@element-plus/hooks'\nimport { getEventCode } from '@element-plus/utils'\n\nimport type TreeStore from './tree-store'\nimport type { Ref } from 'vue'\nimport type { Nullable } from '@element-plus/utils'\n\ninterface UseKeydownOption {\n  el$: Ref<HTMLElement | null>\n}\nexport function useKeydown({ el$ }: UseKeydownOption, store: Ref<TreeStore>) {\n  const ns = useNamespace('tree')\n\n  onMounted(() => {\n    initTabIndex()\n  })\n\n  onUpdated(() => {\n    el$.value?.querySelectorAll('input[type=checkbox]').forEach((checkbox) => {\n      checkbox.setAttribute('tabindex', '-1')\n    })\n  })\n\n  function canNodeFocus(treeItems: HTMLElement[], nextIndex: number): boolean {\n    const currentNode = store.value.getNode(treeItems[nextIndex].dataset.key!)\n    return (\n      currentNode.canFocus &&\n      currentNode.visible &&\n      (currentNode.parent?.expanded || currentNode.parent?.level === 0)\n    )\n  }\n\n  const handleKeydown = (ev: KeyboardEvent): void => {\n    const currentItem = ev.target as HTMLDivElement\n    if (!currentItem.className.includes(ns.b('node'))) return\n    const code = getEventCode(ev)\n    const treeItems: HTMLElement[] = Array.from(\n      el$.value!.querySelectorAll(`.${ns.is('focusable')}[role=treeitem]`)\n    )\n    const currentIndex = treeItems.indexOf(currentItem)\n    let nextIndex\n    if ([EVENT_CODE.up, EVENT_CODE.down].includes(code)) {\n      ev.preventDefault()\n      if (code === EVENT_CODE.up) {\n        nextIndex =\n          currentIndex === -1\n            ? 0\n            : currentIndex !== 0\n              ? currentIndex - 1\n              : treeItems.length - 1\n        const startIndex = nextIndex\n        while (true) {\n          if (canNodeFocus(treeItems, nextIndex)) {\n            break\n          }\n\n          nextIndex--\n          if (nextIndex === startIndex) {\n            nextIndex = -1\n            break\n          }\n          if (nextIndex < 0) {\n            nextIndex = treeItems.length - 1\n          }\n        }\n      } else {\n        nextIndex =\n          currentIndex === -1\n            ? 0\n            : currentIndex < treeItems.length - 1\n              ? currentIndex + 1\n              : 0\n        const startIndex = nextIndex\n        while (true) {\n          if (canNodeFocus(treeItems, nextIndex)) {\n            break\n          }\n\n          nextIndex++\n          if (nextIndex === startIndex) {\n            nextIndex = -1\n            break\n          }\n          if (nextIndex >= treeItems.length) {\n            nextIndex = 0\n          }\n        }\n      }\n      nextIndex !== -1 && treeItems[nextIndex].focus()\n    }\n    if ([EVENT_CODE.left, EVENT_CODE.right].includes(code)) {\n      ev.preventDefault()\n      currentItem.click()\n    }\n    const hasInput = currentItem.querySelector(\n      '[type=\"checkbox\"]'\n    ) as Nullable<HTMLInputElement>\n    if (\n      [EVENT_CODE.enter, EVENT_CODE.numpadEnter, EVENT_CODE.space].includes(\n        code\n      ) &&\n      hasInput\n    ) {\n      ev.preventDefault()\n      hasInput.click()\n    }\n  }\n\n  useEventListener(el$, 'keydown', handleKeydown)\n\n  const initTabIndex = (): void => {\n    if (!el$.value) return\n    const treeItems = Array.from(\n      el$.value.querySelectorAll(`.${ns.is('focusable')}[role=treeitem]`)\n    )\n    const checkboxItems = Array.from(\n      el$.value.querySelectorAll('input[type=checkbox]')\n    )\n    checkboxItems.forEach((checkbox) => {\n      checkbox.setAttribute('tabindex', '-1')\n    })\n    const checkedItem = el$.value.querySelectorAll(\n      `.${ns.is('checked')}[role=treeitem]`\n    )\n    if (checkedItem.length) {\n      checkedItem[0].setAttribute('tabindex', '0')\n      return\n    }\n    treeItems[0]?.setAttribute('tabindex', '0')\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}