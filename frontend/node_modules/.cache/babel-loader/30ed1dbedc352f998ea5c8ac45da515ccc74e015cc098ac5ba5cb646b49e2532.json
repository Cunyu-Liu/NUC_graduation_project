{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.reduce.js\";\nimport { ref, isRef, nextTick } from 'vue';\nimport { isNull } from 'lodash-unified';\nimport { parseHeight } from './util.mjs';\nimport { hasOwn, isString } from '@vue/shared';\nimport { isClient } from '@vueuse/core';\nimport { isNumber } from '../../../utils/types.mjs';\nclass TableLayout {\n  constructor(options) {\n    this.observers = [];\n    this.table = null;\n    this.store = null;\n    this.columns = [];\n    this.fit = true;\n    this.showHeader = true;\n    this.height = ref(null);\n    this.scrollX = ref(false);\n    this.scrollY = ref(false);\n    this.bodyWidth = ref(null);\n    this.fixedWidth = ref(null);\n    this.rightFixedWidth = ref(null);\n    this.gutterWidth = 0;\n    for (const name in options) {\n      if (hasOwn(options, name)) {\n        if (isRef(this[name])) {\n          this[name].value = options[name];\n        } else {\n          this[name] = options[name];\n        }\n      }\n    }\n    if (!this.table) {\n      throw new Error(\"Table is required for Table Layout\");\n    }\n    if (!this.store) {\n      throw new Error(\"Store is required for Table Layout\");\n    }\n  }\n  updateScrollY() {\n    const height = this.height.value;\n    if (isNull(height)) return false;\n    const scrollBarRef = this.table.refs.scrollBarRef;\n    if (this.table.vnode.el && (scrollBarRef == null ? void 0 : scrollBarRef.wrapRef)) {\n      let scrollY = true;\n      const prevScrollY = this.scrollY.value;\n      scrollY = scrollBarRef.wrapRef.scrollHeight > scrollBarRef.wrapRef.clientHeight;\n      this.scrollY.value = scrollY;\n      return prevScrollY !== scrollY;\n    }\n    return false;\n  }\n  setHeight(value, prop = \"height\") {\n    if (!isClient) return;\n    const el = this.table.vnode.el;\n    value = parseHeight(value);\n    this.height.value = Number(value);\n    if (!el && (value || value === 0)) {\n      nextTick(() => this.setHeight(value, prop));\n      return;\n    }\n    if (el && isNumber(value)) {\n      el.style[prop] = `${value}px`;\n      this.updateElsHeight();\n    } else if (el && isString(value)) {\n      el.style[prop] = value;\n      this.updateElsHeight();\n    }\n  }\n  setMaxHeight(value) {\n    this.setHeight(value, \"max-height\");\n  }\n  getFlattenColumns() {\n    const flattenColumns = [];\n    const columns = this.table.store.states.columns.value;\n    columns.forEach(column => {\n      if (column.isColumnGroup) {\n        flattenColumns.push.apply(flattenColumns, column.columns);\n      } else {\n        flattenColumns.push(column);\n      }\n    });\n    return flattenColumns;\n  }\n  updateElsHeight() {\n    this.updateScrollY();\n    this.notifyObservers(\"scrollable\");\n  }\n  headerDisplayNone(elm) {\n    if (!elm) return true;\n    let headerChild = elm;\n    while (headerChild.tagName !== \"DIV\") {\n      if (getComputedStyle(headerChild).display === \"none\") {\n        return true;\n      }\n      headerChild = headerChild.parentElement;\n    }\n    return false;\n  }\n  updateColumnsWidth() {\n    var _a;\n    if (!isClient) return;\n    const fit = this.fit;\n    const bodyWidth = (_a = this.table.vnode.el) == null ? void 0 : _a.clientWidth;\n    let bodyMinWidth = 0;\n    const flattenColumns = this.getFlattenColumns();\n    const flexColumns = flattenColumns.filter(column => !isNumber(column.width));\n    flattenColumns.forEach(column => {\n      if (isNumber(column.width) && column.realWidth) column.realWidth = null;\n    });\n    if (flexColumns.length > 0 && fit) {\n      flattenColumns.forEach(column => {\n        bodyMinWidth += Number(column.width || column.minWidth || 80);\n      });\n      if (bodyMinWidth <= bodyWidth) {\n        this.scrollX.value = false;\n        const totalFlexWidth = bodyWidth - bodyMinWidth;\n        if (flexColumns.length === 1) {\n          flexColumns[0].realWidth = Number(flexColumns[0].minWidth || 80) + totalFlexWidth;\n        } else {\n          const allColumnsWidth = flexColumns.reduce((prev, column) => prev + Number(column.minWidth || 80), 0);\n          const flexWidthPerPixel = totalFlexWidth / allColumnsWidth;\n          let noneFirstWidth = 0;\n          flexColumns.forEach((column, index) => {\n            if (index === 0) return;\n            const flexWidth = Math.floor(Number(column.minWidth || 80) * flexWidthPerPixel);\n            noneFirstWidth += flexWidth;\n            column.realWidth = Number(column.minWidth || 80) + flexWidth;\n          });\n          flexColumns[0].realWidth = Number(flexColumns[0].minWidth || 80) + totalFlexWidth - noneFirstWidth;\n        }\n      } else {\n        this.scrollX.value = true;\n        flexColumns.forEach(column => {\n          column.realWidth = Number(column.minWidth);\n        });\n      }\n      this.bodyWidth.value = Math.max(bodyMinWidth, bodyWidth);\n      this.table.state.resizeState.value.width = this.bodyWidth.value;\n    } else {\n      flattenColumns.forEach(column => {\n        if (!column.width && !column.minWidth) {\n          column.realWidth = 80;\n        } else {\n          column.realWidth = Number(column.width || column.minWidth);\n        }\n        bodyMinWidth += column.realWidth;\n      });\n      this.scrollX.value = bodyMinWidth > bodyWidth;\n      this.bodyWidth.value = bodyMinWidth;\n    }\n    const fixedColumns = this.store.states.fixedColumns.value;\n    if (fixedColumns.length > 0) {\n      let fixedWidth = 0;\n      fixedColumns.forEach(column => {\n        fixedWidth += Number(column.realWidth || column.width);\n      });\n      this.fixedWidth.value = fixedWidth;\n    }\n    const rightFixedColumns = this.store.states.rightFixedColumns.value;\n    if (rightFixedColumns.length > 0) {\n      let rightFixedWidth = 0;\n      rightFixedColumns.forEach(column => {\n        rightFixedWidth += Number(column.realWidth || column.width);\n      });\n      this.rightFixedWidth.value = rightFixedWidth;\n    }\n    this.notifyObservers(\"columns\");\n  }\n  addObserver(observer) {\n    this.observers.push(observer);\n  }\n  removeObserver(observer) {\n    const index = this.observers.indexOf(observer);\n    if (index !== -1) {\n      this.observers.splice(index, 1);\n    }\n  }\n  notifyObservers(event) {\n    const observers = this.observers;\n    observers.forEach(observer => {\n      var _a, _b;\n      switch (event) {\n        case \"columns\":\n          (_a = observer.state) == null ? void 0 : _a.onColumnsChange(this);\n          break;\n        case \"scrollable\":\n          (_b = observer.state) == null ? void 0 : _b.onScrollableChange(this);\n          break;\n        default:\n          throw new Error(`Table Layout don't have event ${event}.`);\n      }\n    });\n  }\n}\nexport { TableLayout as default };","map":{"version":3,"names":["TableLayout","constructor","options","observers","table","store","columns","fit","showHeader","height","ref","scrollX","scrollY","bodyWidth","fixedWidth","rightFixedWidth","gutterWidth","name","hasOwn","isRef","value","Error","updateScrollY","isNull","scrollBarRef","refs","vnode","el","wrapRef","prevScrollY","scrollHeight","clientHeight","setHeight","prop","isClient","parseHeight","Number","nextTick","isNumber","style","updateElsHeight","isString","setMaxHeight","getFlattenColumns","flattenColumns","states","forEach","column","isColumnGroup","push","apply","notifyObservers","headerDisplayNone","elm","headerChild","tagName","getComputedStyle","display","parentElement","updateColumnsWidth","_a","clientWidth","bodyMinWidth","flexColumns","filter","width","realWidth","length","minWidth","totalFlexWidth","allColumnsWidth","reduce","prev","flexWidthPerPixel","noneFirstWidth","index","flexWidth","Math","floor","max","state","resizeState","fixedColumns","rightFixedColumns","addObserver","observer","removeObserver","indexOf","splice","event","_b","onColumnsChange","onScrollableChange"],"sources":["../../../../../../packages/components/table/src/table-layout.ts"],"sourcesContent":["import { isRef, nextTick, ref } from 'vue'\nimport { isNull } from 'lodash-unified'\nimport { hasOwn, isClient, isNumber, isString } from '@element-plus/utils'\nimport { parseHeight } from './util'\n\nimport type { Ref } from 'vue'\nimport type { TableColumnCtx } from './table-column/defaults'\nimport type { TableHeader } from './table-header'\nimport type { DefaultRow, Table } from './table/defaults'\nimport type { Store } from './store'\n\nclass TableLayout<T extends DefaultRow> {\n  observers: TableHeader[]\n  table: Table<T>\n  store: Store<T>\n  columns: TableColumnCtx<T>[]\n  fit: boolean\n  showHeader: boolean\n\n  height: Ref<null | number>\n  scrollX: Ref<boolean>\n  scrollY: Ref<boolean>\n  bodyWidth: Ref<null | number>\n  fixedWidth: Ref<null | number>\n  rightFixedWidth: Ref<null | number>\n  tableHeight!: Ref<null | number>\n  headerHeight!: Ref<null | number> // Table Header Height\n  appendHeight!: Ref<null | number> // Append Slot Height\n  footerHeight!: Ref<null | number> // Table Footer Height\n  gutterWidth: number\n  constructor(options: Record<string, any>) {\n    this.observers = []\n    this.table = null as unknown as Table<T>\n    this.store = null as unknown as Store<T>\n    this.columns = []\n    this.fit = true\n    this.showHeader = true\n    this.height = ref(null)\n    this.scrollX = ref(false)\n    this.scrollY = ref(false)\n    this.bodyWidth = ref(null)\n    this.fixedWidth = ref(null)\n    this.rightFixedWidth = ref(null)\n    this.gutterWidth = 0\n    for (const name in options) {\n      if (hasOwn(options, name)) {\n        if (isRef(this[name])) {\n          ;(this[name] as Ref).value = options[name]\n        } else {\n          this[name as keyof typeof this] = options[name]\n        }\n      }\n    }\n    if (!this.table) {\n      throw new Error('Table is required for Table Layout')\n    }\n    if (!this.store) {\n      throw new Error('Store is required for Table Layout')\n    }\n  }\n\n  updateScrollY() {\n    const height = this.height.value\n    /**\n     * When the height is not initialized, it is null.\n     * After the table is initialized, when the height is not configured, the height is 0.\n     */\n    if (isNull(height)) return false\n    const scrollBarRef = this.table.refs.scrollBarRef\n    if (this.table.vnode.el && scrollBarRef?.wrapRef) {\n      let scrollY = true\n      const prevScrollY = this.scrollY.value\n      scrollY =\n        scrollBarRef.wrapRef.scrollHeight > scrollBarRef.wrapRef.clientHeight\n      this.scrollY.value = scrollY\n      return prevScrollY !== scrollY\n    }\n    return false\n  }\n\n  setHeight(value: string | number | null, prop = 'height') {\n    if (!isClient) return\n    const el = this.table.vnode.el\n    value = parseHeight(value)\n    this.height.value = Number(value)\n\n    if (!el && (value || value === 0)) {\n      nextTick(() => this.setHeight(value, prop))\n      return\n    }\n\n    if (el && isNumber(value)) {\n      el.style[prop] = `${value}px`\n      this.updateElsHeight()\n    } else if (el && isString(value)) {\n      el.style[prop] = value\n      this.updateElsHeight()\n    }\n  }\n\n  setMaxHeight(value: string | number | null) {\n    this.setHeight(value, 'max-height')\n  }\n\n  getFlattenColumns(): TableColumnCtx<T>[] {\n    const flattenColumns: TableColumnCtx<T>[] = []\n    const columns = this.table.store.states.columns.value\n    columns.forEach((column) => {\n      if (column.isColumnGroup) {\n        // eslint-disable-next-line prefer-spread\n        flattenColumns.push.apply(flattenColumns, column.columns)\n      } else {\n        flattenColumns.push(column)\n      }\n    })\n\n    return flattenColumns\n  }\n\n  updateElsHeight() {\n    this.updateScrollY()\n    this.notifyObservers('scrollable')\n  }\n\n  headerDisplayNone(elm: HTMLElement) {\n    if (!elm) return true\n    let headerChild = elm\n    while (headerChild.tagName !== 'DIV') {\n      if (getComputedStyle(headerChild).display === 'none') {\n        return true\n      }\n      headerChild = headerChild.parentElement!\n    }\n    return false\n  }\n\n  updateColumnsWidth() {\n    if (!isClient) return\n    const fit = this.fit\n    const bodyWidth = this.table.vnode.el?.clientWidth\n    let bodyMinWidth = 0\n\n    const flattenColumns = this.getFlattenColumns()\n    const flexColumns = flattenColumns.filter(\n      (column) => !isNumber(column.width)\n    )\n    flattenColumns.forEach((column) => {\n      // Clean those columns whose width changed from flex to unflex\n      if (isNumber(column.width) && column.realWidth) column.realWidth = null\n    })\n    if (flexColumns.length > 0 && fit) {\n      flattenColumns.forEach((column) => {\n        bodyMinWidth += Number(column.width || column.minWidth || 80)\n      })\n      if (bodyMinWidth <= bodyWidth) {\n        // DON'T HAVE SCROLL BAR\n        this.scrollX.value = false\n\n        const totalFlexWidth = bodyWidth - bodyMinWidth\n\n        if (flexColumns.length === 1) {\n          flexColumns[0].realWidth =\n            Number(flexColumns[0].minWidth || 80) + totalFlexWidth\n        } else {\n          const allColumnsWidth = flexColumns.reduce(\n            (prev, column) => prev + Number(column.minWidth || 80),\n            0\n          )\n          const flexWidthPerPixel = totalFlexWidth / allColumnsWidth\n          let noneFirstWidth = 0\n\n          flexColumns.forEach((column, index) => {\n            if (index === 0) return\n            const flexWidth = Math.floor(\n              Number(column.minWidth || 80) * flexWidthPerPixel\n            )\n            noneFirstWidth += flexWidth\n            column.realWidth = Number(column.minWidth || 80) + flexWidth\n          })\n\n          flexColumns[0].realWidth =\n            Number(flexColumns[0].minWidth || 80) +\n            totalFlexWidth -\n            noneFirstWidth\n        }\n      } else {\n        // HAVE HORIZONTAL SCROLL BAR\n        this.scrollX.value = true\n        flexColumns.forEach((column) => {\n          column.realWidth = Number(column.minWidth)\n        })\n      }\n\n      this.bodyWidth.value = Math.max(bodyMinWidth, bodyWidth)\n      this.table.state.resizeState.value.width = this.bodyWidth.value\n    } else {\n      flattenColumns.forEach((column) => {\n        if (!column.width && !column.minWidth) {\n          column.realWidth = 80\n        } else {\n          column.realWidth = Number(column.width || column.minWidth)\n        }\n        bodyMinWidth += column.realWidth\n      })\n      this.scrollX.value = bodyMinWidth > bodyWidth\n\n      this.bodyWidth.value = bodyMinWidth\n    }\n\n    const fixedColumns = this.store.states.fixedColumns.value\n\n    if (fixedColumns.length > 0) {\n      let fixedWidth = 0\n      fixedColumns.forEach((column) => {\n        fixedWidth += Number(column.realWidth || column.width)\n      })\n\n      this.fixedWidth.value = fixedWidth\n    }\n\n    const rightFixedColumns = this.store.states.rightFixedColumns.value\n    if (rightFixedColumns.length > 0) {\n      let rightFixedWidth = 0\n      rightFixedColumns.forEach((column) => {\n        rightFixedWidth += Number(column.realWidth || column.width)\n      })\n\n      this.rightFixedWidth.value = rightFixedWidth\n    }\n    this.notifyObservers('columns')\n  }\n\n  addObserver(observer: TableHeader) {\n    this.observers.push(observer)\n  }\n\n  removeObserver(observer: TableHeader) {\n    const index = this.observers.indexOf(observer)\n    if (index !== -1) {\n      this.observers.splice(index, 1)\n    }\n  }\n\n  notifyObservers(event: string) {\n    const observers = this.observers\n    observers.forEach((observer) => {\n      switch (event) {\n        case 'columns':\n          observer.state?.onColumnsChange(this as TableLayout<DefaultRow>)\n          break\n        case 'scrollable':\n          observer.state?.onScrollableChange(this as TableLayout<DefaultRow>)\n          break\n        default:\n          throw new Error(`Table Layout don't have event ${event}.`)\n      }\n    })\n  }\n}\n\nexport default TableLayout\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}