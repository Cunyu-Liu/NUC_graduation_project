{"ast":null,"code":"import \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport { isArray } from '@vue/shared';\nconst TEXT_ALIGN_RATIO_MAP = {\n  left: [0, 0.5],\n  start: [0, 0.5],\n  center: [0.5, 0],\n  right: [1, -0.5],\n  end: [1, -0.5]\n};\nfunction prepareCanvas(width, height, ratio = 1) {\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\");\n  const realWidth = width * ratio;\n  const realHeight = height * ratio;\n  canvas.setAttribute(\"width\", `${realWidth}px`);\n  canvas.setAttribute(\"height\", `${realHeight}px`);\n  ctx.save();\n  return [ctx, canvas, realWidth, realHeight];\n}\nfunction useClips() {\n  function getClips(content, rotate, ratio, width, height, font, gapX, gapY, space) {\n    const [ctx, canvas, contentWidth, contentHeight] = prepareCanvas(width, height, ratio);\n    let baselineOffset = 0;\n    if (content instanceof HTMLImageElement) {\n      ctx.drawImage(content, 0, 0, contentWidth, contentHeight);\n    } else {\n      const {\n        color,\n        fontSize,\n        fontStyle,\n        fontWeight,\n        fontFamily,\n        textAlign,\n        textBaseline\n      } = font;\n      const mergedFontSize = Number(fontSize) * ratio;\n      ctx.font = `${fontStyle} normal ${fontWeight} ${mergedFontSize}px/${height}px ${fontFamily}`;\n      ctx.fillStyle = color;\n      ctx.textAlign = textAlign;\n      ctx.textBaseline = textBaseline;\n      const contents = isArray(content) ? content : [content];\n      if (textBaseline !== \"top\" && contents[0]) {\n        const argumentMetrics = ctx.measureText(contents[0]);\n        ctx.textBaseline = \"top\";\n        const topMetrics = ctx.measureText(contents[0]);\n        baselineOffset = argumentMetrics.actualBoundingBoxAscent - topMetrics.actualBoundingBoxAscent;\n      }\n      contents == null ? void 0 : contents.forEach((item, index) => {\n        const [alignRatio, spaceRatio] = TEXT_ALIGN_RATIO_MAP[textAlign];\n        ctx.fillText(item != null ? item : \"\", contentWidth * alignRatio + space * spaceRatio, index * (mergedFontSize + font.fontGap * ratio));\n      });\n    }\n    const angle = Math.PI / 180 * Number(rotate);\n    const maxSize = Math.max(width, height);\n    const [rCtx, rCanvas, realMaxSize] = prepareCanvas(maxSize, maxSize, ratio);\n    rCtx.translate(realMaxSize / 2, realMaxSize / 2);\n    rCtx.rotate(angle);\n    if (contentWidth > 0 && contentHeight > 0) {\n      rCtx.drawImage(canvas, -contentWidth / 2, -contentHeight / 2);\n    }\n    function getRotatePos(x, y) {\n      const targetX = x * Math.cos(angle) - y * Math.sin(angle);\n      const targetY = x * Math.sin(angle) + y * Math.cos(angle);\n      return [targetX, targetY];\n    }\n    let left = 0;\n    let right = 0;\n    let top = 0;\n    let bottom = 0;\n    const halfWidth = contentWidth / 2;\n    const halfHeight = contentHeight / 2;\n    const points = [[0 - halfWidth, 0 - halfHeight], [0 + halfWidth, 0 - halfHeight], [0 + halfWidth, 0 + halfHeight], [0 - halfWidth, 0 + halfHeight]];\n    points.forEach(([x, y]) => {\n      const [targetX, targetY] = getRotatePos(x, y);\n      left = Math.min(left, targetX);\n      right = Math.max(right, targetX);\n      top = Math.min(top, targetY);\n      bottom = Math.max(bottom, targetY);\n    });\n    const cutLeft = left + realMaxSize / 2;\n    const cutTop = top + realMaxSize / 2;\n    const cutWidth = right - left;\n    const cutHeight = bottom - top;\n    const realGapX = gapX * ratio;\n    const realGapY = gapY * ratio;\n    const filledWidth = (cutWidth + realGapX) * 2;\n    const filledHeight = cutHeight + realGapY;\n    const [fCtx, fCanvas] = prepareCanvas(filledWidth, filledHeight);\n    function drawImg(targetX = 0, targetY = 0) {\n      fCtx.drawImage(rCanvas, cutLeft, cutTop, cutWidth, cutHeight, targetX, targetY + baselineOffset, cutWidth, cutHeight);\n    }\n    drawImg();\n    drawImg(cutWidth + realGapX, -cutHeight / 2 - realGapY / 2);\n    drawImg(cutWidth + realGapX, +cutHeight / 2 + realGapY / 2);\n    return [fCanvas.toDataURL(), filledWidth / ratio, filledHeight / ratio];\n  }\n  return getClips;\n}\nexport { useClips as default };","map":{"version":3,"names":["TEXT_ALIGN_RATIO_MAP","left","start","center","right","end","prepareCanvas","width","height","ratio","canvas","document","createElement","ctx","getContext","realWidth","realHeight","setAttribute","save","useClips","getClips","content","rotate","font","gapX","gapY","space","contentWidth","contentHeight","baselineOffset","HTMLImageElement","drawImage","color","fontSize","fontStyle","fontWeight","fontFamily","textAlign","textBaseline","mergedFontSize","Number","fillStyle","contents","isArray","argumentMetrics","measureText","topMetrics","actualBoundingBoxAscent","forEach","item","index","alignRatio","spaceRatio","fillText","fontGap","angle","Math","PI","maxSize","max","rCtx","rCanvas","realMaxSize","translate","getRotatePos","x","y","targetX","cos","sin","targetY","top","bottom","halfWidth","halfHeight","points","min","cutLeft","cutTop","cutWidth","cutHeight","realGapX","realGapY","filledWidth","filledHeight","fCtx","fCanvas","drawImg","toDataURL"],"sources":["../../../../../../packages/components/watermark/src/useClips.ts"],"sourcesContent":["import { isArray } from '@element-plus/utils'\n\nimport type { WatermarkProps } from './watermark'\n\n// [alignRatio, spaceRatio]\nconst TEXT_ALIGN_RATIO_MAP = {\n  left: [0, 0.5],\n  start: [0, 0.5],\n  center: [0.5, 0],\n  right: [1, -0.5],\n  end: [1, -0.5],\n} as const\n\nfunction prepareCanvas(\n  width: number,\n  height: number,\n  ratio = 1\n): [\n  ctx: CanvasRenderingContext2D,\n  canvas: HTMLCanvasElement,\n  realWidth: number,\n  realHeight: number,\n] {\n  const canvas = document.createElement('canvas')\n  const ctx = canvas.getContext('2d')!\n  const realWidth = width * ratio\n  const realHeight = height * ratio\n  canvas.setAttribute('width', `${realWidth}px`)\n  canvas.setAttribute('height', `${realHeight}px`)\n  ctx.save()\n\n  return [ctx, canvas, realWidth, realHeight]\n}\n\n/**\n * Get the clips of text content.\n * This is a lazy hook function since SSR no need this\n */\nexport default function useClips() {\n  // Get single clips\n  function getClips(\n    content: NonNullable<WatermarkProps['content']> | HTMLImageElement,\n    rotate: number,\n    ratio: number,\n    width: number,\n    height: number,\n    font: Required<NonNullable<WatermarkProps['font']>>,\n    gapX: number,\n    gapY: number,\n    space: number\n  ): [dataURL: string, finalWidth: number, finalHeight: number] {\n    // ================= Text / Image =================\n    const [ctx, canvas, contentWidth, contentHeight] = prepareCanvas(\n      width,\n      height,\n      ratio\n    )\n    let baselineOffset = 0\n    if (content instanceof HTMLImageElement) {\n      // Image\n      ctx.drawImage(content, 0, 0, contentWidth, contentHeight)\n    } else {\n      // Text\n      const {\n        color,\n        fontSize,\n        fontStyle,\n        fontWeight,\n        fontFamily,\n        textAlign,\n        textBaseline,\n      } = font\n      const mergedFontSize = Number(fontSize) * ratio\n\n      ctx.font = `${fontStyle} normal ${fontWeight} ${mergedFontSize}px/${height}px ${fontFamily}`\n      ctx.fillStyle = color\n      ctx.textAlign = textAlign\n      ctx.textBaseline = textBaseline\n      const contents = isArray(content) ? content : [content]\n      if (textBaseline !== 'top' && contents[0]) {\n        const argumentMetrics = ctx.measureText(contents[0])\n        ctx.textBaseline = 'top'\n        const topMetrics = ctx.measureText(contents[0])\n        baselineOffset =\n          argumentMetrics.actualBoundingBoxAscent -\n          topMetrics.actualBoundingBoxAscent\n      }\n      contents?.forEach((item, index) => {\n        const [alignRatio, spaceRatio] = TEXT_ALIGN_RATIO_MAP[textAlign]\n        ctx.fillText(\n          item ?? '',\n          contentWidth * alignRatio + space * spaceRatio,\n          index * (mergedFontSize + font.fontGap * ratio)\n        )\n      })\n    }\n\n    // ==================== Rotate ====================\n    const angle = (Math.PI / 180) * Number(rotate)\n    const maxSize = Math.max(width, height)\n    const [rCtx, rCanvas, realMaxSize] = prepareCanvas(maxSize, maxSize, ratio)\n\n    // Copy from `ctx` and rotate\n    rCtx.translate(realMaxSize / 2, realMaxSize / 2)\n    rCtx.rotate(angle)\n    if (contentWidth > 0 && contentHeight > 0) {\n      rCtx.drawImage(canvas, -contentWidth / 2, -contentHeight / 2)\n    }\n\n    // Get boundary of rotated text\n    function getRotatePos(x: number, y: number) {\n      const targetX = x * Math.cos(angle) - y * Math.sin(angle)\n      const targetY = x * Math.sin(angle) + y * Math.cos(angle)\n      return [targetX, targetY]\n    }\n\n    let left = 0\n    let right = 0\n    let top = 0\n    let bottom = 0\n\n    const halfWidth = contentWidth / 2\n    const halfHeight = contentHeight / 2\n    const points = [\n      [0 - halfWidth, 0 - halfHeight],\n      [0 + halfWidth, 0 - halfHeight],\n      [0 + halfWidth, 0 + halfHeight],\n      [0 - halfWidth, 0 + halfHeight],\n    ]\n    points.forEach(([x, y]) => {\n      const [targetX, targetY] = getRotatePos(x, y)\n      left = Math.min(left, targetX)\n      right = Math.max(right, targetX)\n      top = Math.min(top, targetY)\n      bottom = Math.max(bottom, targetY)\n    })\n\n    const cutLeft = left + realMaxSize / 2\n    const cutTop = top + realMaxSize / 2\n    const cutWidth = right - left\n    const cutHeight = bottom - top\n\n    // ================ Fill Alternate ================\n    const realGapX = gapX * ratio\n    const realGapY = gapY * ratio\n    const filledWidth = (cutWidth + realGapX) * 2\n    const filledHeight = cutHeight + realGapY\n\n    const [fCtx, fCanvas] = prepareCanvas(filledWidth, filledHeight)\n\n    function drawImg(targetX = 0, targetY = 0) {\n      fCtx.drawImage(\n        rCanvas,\n        cutLeft,\n        cutTop,\n        cutWidth,\n        cutHeight,\n        targetX,\n        targetY + baselineOffset,\n        cutWidth,\n        cutHeight\n      )\n    }\n    drawImg()\n    drawImg(cutWidth + realGapX, -cutHeight / 2 - realGapY / 2)\n    drawImg(cutWidth + realGapX, +cutHeight / 2 + realGapY / 2)\n\n    return [fCanvas.toDataURL(), filledWidth / ratio, filledHeight / ratio]\n  }\n\n  return getClips\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}