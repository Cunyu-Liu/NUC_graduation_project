{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.iterator.some.js\";\nimport { nextTick } from 'vue';\nimport { isNil } from 'lodash-unified';\nimport Node from './node.mjs';\nimport { getNodeKey } from './util.mjs';\nimport { hasOwn, NOOP, isObject } from '@vue/shared';\nimport { isPropAbsent } from '../../../../utils/types.mjs';\nclass TreeStore {\n  constructor(options) {\n    this.lazy = false;\n    this.checkStrictly = false;\n    this.autoExpandParent = false;\n    this.defaultExpandAll = false;\n    this.checkDescendants = false;\n    this.currentNode = null;\n    this.currentNodeKey = null;\n    for (const option in options) {\n      if (hasOwn(options, option)) {\n        this[option] = options[option];\n      }\n    }\n    this.nodesMap = {};\n  }\n  initialize() {\n    this.root = new Node({\n      data: this.data,\n      store: this\n    });\n    this.root.initialize();\n    if (this.lazy && this.load) {\n      const loadFn = this.load;\n      loadFn(this.root, data => {\n        this.root.doCreateChildren(data);\n        this._initDefaultCheckedNodes();\n      }, NOOP);\n    } else {\n      this._initDefaultCheckedNodes();\n    }\n  }\n  filter(value) {\n    const filterNodeMethod = this.filterNodeMethod;\n    const lazy = this.lazy;\n    const traverse = async function (node) {\n      const childNodes = node.root ? node.root.childNodes : node.childNodes;\n      for (const [index, child] of childNodes.entries()) {\n        child.visible = !!(filterNodeMethod == null ? void 0 : filterNodeMethod.call(child, value, child.data, child));\n        if (index % 80 === 0 && index > 0) {\n          await nextTick();\n        }\n        await traverse(child);\n      }\n      if (!node.visible && childNodes.length) {\n        let allHidden = true;\n        allHidden = !childNodes.some(child => child.visible);\n        if (node.root) {\n          node.root.visible = allHidden === false;\n        } else {\n          node.visible = allHidden === false;\n        }\n      }\n      if (!value) return;\n      if (node.visible && !node.isLeaf) {\n        if (!lazy || node.loaded) {\n          node.expand();\n        }\n      }\n    };\n    traverse(this);\n  }\n  setData(newVal) {\n    const instanceChanged = newVal !== this.root.data;\n    if (instanceChanged) {\n      this.nodesMap = {};\n      this.root.setData(newVal);\n      this._initDefaultCheckedNodes();\n      this.setCurrentNodeKey(this.currentNodeKey);\n    } else {\n      this.root.updateChildren();\n    }\n  }\n  getNode(data) {\n    if (data instanceof Node) return data;\n    const key = isObject(data) ? getNodeKey(this.key, data) : data;\n    return this.nodesMap[key] || null;\n  }\n  insertBefore(data, refData) {\n    var _a;\n    const refNode = this.getNode(refData);\n    (_a = refNode.parent) == null ? void 0 : _a.insertBefore({\n      data\n    }, refNode);\n  }\n  insertAfter(data, refData) {\n    var _a;\n    const refNode = this.getNode(refData);\n    (_a = refNode.parent) == null ? void 0 : _a.insertAfter({\n      data\n    }, refNode);\n  }\n  remove(data) {\n    const node = this.getNode(data);\n    if (node && node.parent) {\n      if (node === this.currentNode) {\n        this.currentNode = null;\n      }\n      node.parent.removeChild(node);\n    }\n  }\n  append(data, parentData) {\n    const parentNode = !isPropAbsent(parentData) ? this.getNode(parentData) : this.root;\n    if (parentNode) {\n      parentNode.insertChild({\n        data\n      });\n    }\n  }\n  _initDefaultCheckedNodes() {\n    const defaultCheckedKeys = this.defaultCheckedKeys || [];\n    const nodesMap = this.nodesMap;\n    defaultCheckedKeys.forEach(checkedKey => {\n      const node = nodesMap[checkedKey];\n      if (node) {\n        node.setChecked(true, !this.checkStrictly);\n      }\n    });\n  }\n  _initDefaultCheckedNode(node) {\n    const defaultCheckedKeys = this.defaultCheckedKeys || [];\n    if (!isNil(node.key) && defaultCheckedKeys.includes(node.key)) {\n      node.setChecked(true, !this.checkStrictly);\n    }\n  }\n  setDefaultCheckedKey(newVal) {\n    if (newVal !== this.defaultCheckedKeys) {\n      this.defaultCheckedKeys = newVal;\n      this._initDefaultCheckedNodes();\n    }\n  }\n  registerNode(node) {\n    const key = this.key;\n    if (!node || !node.data) return;\n    if (!key) {\n      this.nodesMap[node.id] = node;\n    } else {\n      const nodeKey = node.key;\n      if (!isNil(nodeKey)) this.nodesMap[nodeKey] = node;\n    }\n  }\n  deregisterNode(node) {\n    const key = this.key;\n    if (!key || !node || !node.data) return;\n    node.childNodes.forEach(child => {\n      this.deregisterNode(child);\n    });\n    delete this.nodesMap[node.key];\n  }\n  getCheckedNodes(leafOnly = false, includeHalfChecked = false) {\n    const checkedNodes = [];\n    const traverse = function (node) {\n      const childNodes = node.root ? node.root.childNodes : node.childNodes;\n      childNodes.forEach(child => {\n        if ((child.checked || includeHalfChecked && child.indeterminate) && (!leafOnly || leafOnly && child.isLeaf)) {\n          checkedNodes.push(child.data);\n        }\n        traverse(child);\n      });\n    };\n    traverse(this);\n    return checkedNodes;\n  }\n  getCheckedKeys(leafOnly = false) {\n    return this.getCheckedNodes(leafOnly).map(data => (data || {})[this.key]);\n  }\n  getHalfCheckedNodes() {\n    const nodes = [];\n    const traverse = function (node) {\n      const childNodes = node.root ? node.root.childNodes : node.childNodes;\n      childNodes.forEach(child => {\n        if (child.indeterminate) {\n          nodes.push(child.data);\n        }\n        traverse(child);\n      });\n    };\n    traverse(this);\n    return nodes;\n  }\n  getHalfCheckedKeys() {\n    return this.getHalfCheckedNodes().map(data => (data || {})[this.key]);\n  }\n  _getAllNodes() {\n    const allNodes = [];\n    const nodesMap = this.nodesMap;\n    for (const nodeKey in nodesMap) {\n      if (hasOwn(nodesMap, nodeKey)) {\n        allNodes.push(nodesMap[nodeKey]);\n      }\n    }\n    return allNodes;\n  }\n  updateChildren(key, data) {\n    const node = this.nodesMap[key];\n    if (!node) return;\n    const childNodes = node.childNodes;\n    for (let i = childNodes.length - 1; i >= 0; i--) {\n      const child = childNodes[i];\n      this.remove(child.data);\n    }\n    for (let i = 0, j = data.length; i < j; i++) {\n      const child = data[i];\n      this.append(child, node.data);\n    }\n  }\n  _setCheckedKeys(key, leafOnly = false, checkedKeys) {\n    const allNodes = this._getAllNodes().sort((a, b) => a.level - b.level);\n    const cache = /* @__PURE__ */Object.create(null);\n    const keys = Object.keys(checkedKeys);\n    allNodes.forEach(node => node.setChecked(false, false));\n    const cacheCheckedChild = node => {\n      node.childNodes.forEach(child => {\n        var _a;\n        cache[child.data[key]] = true;\n        if ((_a = child.childNodes) == null ? void 0 : _a.length) {\n          cacheCheckedChild(child);\n        }\n      });\n    };\n    for (let i = 0, j = allNodes.length; i < j; i++) {\n      const node = allNodes[i];\n      const nodeKey = node.data[key].toString();\n      const checked = keys.includes(nodeKey);\n      if (!checked) {\n        if (node.checked && !cache[nodeKey]) {\n          node.setChecked(false, false);\n        }\n        continue;\n      }\n      if (node.childNodes.length) {\n        cacheCheckedChild(node);\n      }\n      if (node.isLeaf || this.checkStrictly) {\n        node.setChecked(true, false);\n        continue;\n      }\n      node.setChecked(true, true);\n      if (leafOnly) {\n        node.setChecked(false, false);\n        const traverse = function (node2) {\n          const childNodes = node2.childNodes;\n          childNodes.forEach(child => {\n            if (!child.isLeaf) {\n              child.setChecked(false, false);\n            }\n            traverse(child);\n          });\n        };\n        traverse(node);\n      }\n    }\n  }\n  setCheckedNodes(array, leafOnly = false) {\n    const key = this.key;\n    const checkedKeys = {};\n    array.forEach(item => {\n      checkedKeys[(item || {})[key]] = true;\n    });\n    this._setCheckedKeys(key, leafOnly, checkedKeys);\n  }\n  setCheckedKeys(keys, leafOnly = false) {\n    this.defaultCheckedKeys = keys;\n    const key = this.key;\n    const checkedKeys = {};\n    keys.forEach(key2 => {\n      checkedKeys[key2] = true;\n    });\n    this._setCheckedKeys(key, leafOnly, checkedKeys);\n  }\n  setDefaultExpandedKeys(keys) {\n    keys = keys || [];\n    this.defaultExpandedKeys = keys;\n    keys.forEach(key => {\n      const node = this.getNode(key);\n      if (node) node.expand(null, this.autoExpandParent);\n    });\n  }\n  setChecked(data, checked, deep) {\n    const node = this.getNode(data);\n    if (node) {\n      node.setChecked(!!checked, deep);\n    }\n  }\n  getCurrentNode() {\n    return this.currentNode;\n  }\n  setCurrentNode(currentNode) {\n    const prevCurrentNode = this.currentNode;\n    if (prevCurrentNode) {\n      prevCurrentNode.isCurrent = false;\n    }\n    this.currentNode = currentNode;\n    this.currentNode.isCurrent = true;\n  }\n  setUserCurrentNode(node, shouldAutoExpandParent = true) {\n    var _a;\n    const key = node[this.key];\n    const currNode = this.nodesMap[key];\n    this.setCurrentNode(currNode);\n    if (shouldAutoExpandParent && this.currentNode && this.currentNode.level > 1) {\n      (_a = this.currentNode.parent) == null ? void 0 : _a.expand(null, true);\n    }\n  }\n  setCurrentNodeKey(key, shouldAutoExpandParent = true) {\n    var _a;\n    this.currentNodeKey = key;\n    if (isPropAbsent(key)) {\n      this.currentNode && (this.currentNode.isCurrent = false);\n      this.currentNode = null;\n      return;\n    }\n    const node = this.getNode(key);\n    if (node) {\n      this.setCurrentNode(node);\n      if (shouldAutoExpandParent && this.currentNode && this.currentNode.level > 1) {\n        (_a = this.currentNode.parent) == null ? void 0 : _a.expand(null, true);\n      }\n    }\n  }\n}\nexport { TreeStore as default };","map":{"version":3,"names":["TreeStore","constructor","options","lazy","checkStrictly","autoExpandParent","defaultExpandAll","checkDescendants","currentNode","currentNodeKey","option","hasOwn","nodesMap","initialize","root","Node","data","store","load","loadFn","doCreateChildren","_initDefaultCheckedNodes","NOOP","filter","value","filterNodeMethod","traverse","node","childNodes","index","child","entries","visible","call","nextTick","length","allHidden","some","isLeaf","loaded","expand","setData","newVal","instanceChanged","setCurrentNodeKey","updateChildren","getNode","key","isObject","getNodeKey","insertBefore","refData","_a","refNode","parent","insertAfter","remove","removeChild","append","parentData","parentNode","isPropAbsent","insertChild","defaultCheckedKeys","forEach","checkedKey","setChecked","_initDefaultCheckedNode","isNil","includes","setDefaultCheckedKey","registerNode","id","nodeKey","deregisterNode","getCheckedNodes","leafOnly","includeHalfChecked","checkedNodes","checked","indeterminate","push","getCheckedKeys","map","getHalfCheckedNodes","nodes","getHalfCheckedKeys","_getAllNodes","allNodes","i","j","_setCheckedKeys","checkedKeys","sort","a","b","level","cache","Object","create","keys","cacheCheckedChild","toString","node2","setCheckedNodes","array","item","setCheckedKeys","key2","setDefaultExpandedKeys","defaultExpandedKeys","deep","getCurrentNode","setCurrentNode","prevCurrentNode","isCurrent","setUserCurrentNode","shouldAutoExpandParent","currNode"],"sources":["../../../../../../../packages/components/tree/src/model/tree-store.ts"],"sourcesContent":["import { nextTick } from 'vue'\nimport { isNil } from 'lodash-unified'\nimport { NOOP, hasOwn, isObject, isPropAbsent } from '@element-plus/utils'\nimport Node from './node'\nimport { getNodeKey } from './util'\n\nimport type {\n  FilterNodeMethodFunction,\n  FilterValue,\n  LoadFunction,\n  TreeData,\n  TreeKey,\n  TreeNodeData,\n  TreeOptionProps,\n  TreeStoreNodesMap,\n  TreeStoreOptions,\n} from '../tree.type'\n\nexport default class TreeStore {\n  currentNode: Node | null\n  currentNodeKey: TreeKey | null\n  nodesMap: TreeStoreNodesMap\n  root!: Node\n  data!: TreeData\n  lazy = false\n  load?: LoadFunction\n  filterNodeMethod?: FilterNodeMethodFunction\n  key!: TreeKey\n  defaultCheckedKeys?: TreeKey[]\n  checkStrictly = false\n  defaultExpandedKeys?: TreeKey[]\n  autoExpandParent = false\n  defaultExpandAll = false\n  checkDescendants = false\n  props!: TreeOptionProps\n\n  constructor(options: TreeStoreOptions) {\n    this.currentNode = null\n    this.currentNodeKey = null\n\n    for (const option in options) {\n      if (hasOwn(options, option)) {\n        this[option] = options[option]\n      }\n    }\n\n    this.nodesMap = {}\n  }\n\n  initialize() {\n    this.root = new Node({\n      data: this.data,\n      store: this,\n    })\n    this.root.initialize()\n\n    if (this.lazy && this.load) {\n      const loadFn = this.load\n      loadFn(\n        this.root,\n        (data) => {\n          this.root.doCreateChildren(data)\n          this._initDefaultCheckedNodes()\n        },\n        NOOP\n      )\n    } else {\n      this._initDefaultCheckedNodes()\n    }\n  }\n\n  filter(value: FilterValue): void {\n    const filterNodeMethod = this.filterNodeMethod\n    const lazy = this.lazy\n    const traverse = async function (node: TreeStore | Node) {\n      const childNodes = (node as TreeStore).root\n        ? (node as TreeStore).root.childNodes\n        : (node as Node).childNodes\n\n      for (const [index, child] of childNodes.entries()) {\n        child.visible = !!filterNodeMethod?.call(\n          child,\n          value,\n          child.data,\n          child\n        )\n\n        if (index % 80 === 0 && index > 0) {\n          await nextTick()\n        }\n        await traverse(child)\n      }\n\n      if (!(node as Node).visible && childNodes.length) {\n        let allHidden = true\n        allHidden = !childNodes.some((child) => child.visible)\n\n        if ((node as TreeStore).root) {\n          ;(node as TreeStore).root.visible = allHidden === false\n        } else {\n          ;(node as Node).visible = allHidden === false\n        }\n      }\n      if (!value) return\n\n      if ((node as Node).visible && !(node as Node).isLeaf) {\n        if (!lazy || (node as Node).loaded) {\n          ;(node as Node).expand()\n        }\n      }\n    }\n\n    traverse(this)\n  }\n\n  setData(newVal: TreeData): void {\n    const instanceChanged = newVal !== this.root.data\n    if (instanceChanged) {\n      this.nodesMap = {}\n      this.root.setData(newVal)\n      this._initDefaultCheckedNodes()\n      this.setCurrentNodeKey(this.currentNodeKey)\n    } else {\n      this.root.updateChildren()\n    }\n  }\n\n  getNode(data: TreeKey | TreeNodeData | Node): Node {\n    if (data instanceof Node) return data\n    const key = isObject(data) ? getNodeKey(this.key, data) : data\n    return this.nodesMap[key] || null\n  }\n\n  insertBefore(\n    data: TreeNodeData,\n    refData: TreeKey | TreeNodeData | Node\n  ): void {\n    const refNode = this.getNode(refData)\n    refNode.parent?.insertBefore({ data }, refNode)\n  }\n\n  insertAfter(\n    data: TreeNodeData,\n    refData: TreeKey | TreeNodeData | Node\n  ): void {\n    const refNode = this.getNode(refData)\n    refNode.parent?.insertAfter({ data }, refNode)\n  }\n\n  remove(data: TreeNodeData | Node): void {\n    const node = this.getNode(data)\n\n    if (node && node.parent) {\n      if (node === this.currentNode) {\n        this.currentNode = null\n      }\n      node.parent.removeChild(node)\n    }\n  }\n\n  append(data: TreeNodeData, parentData: TreeNodeData | TreeKey | Node): void {\n    const parentNode = !isPropAbsent(parentData)\n      ? this.getNode(parentData)\n      : this.root\n\n    if (parentNode) {\n      parentNode.insertChild({ data })\n    }\n  }\n\n  _initDefaultCheckedNodes(): void {\n    const defaultCheckedKeys = this.defaultCheckedKeys || []\n    const nodesMap = this.nodesMap\n\n    defaultCheckedKeys.forEach((checkedKey) => {\n      const node = nodesMap[checkedKey]\n\n      if (node) {\n        node.setChecked(true, !this.checkStrictly)\n      }\n    })\n  }\n\n  _initDefaultCheckedNode(node: Node): void {\n    const defaultCheckedKeys = this.defaultCheckedKeys || []\n\n    if (!isNil(node.key) && defaultCheckedKeys.includes(node.key)) {\n      node.setChecked(true, !this.checkStrictly)\n    }\n  }\n\n  setDefaultCheckedKey(newVal: TreeKey[]): void {\n    if (newVal !== this.defaultCheckedKeys) {\n      this.defaultCheckedKeys = newVal\n      this._initDefaultCheckedNodes()\n    }\n  }\n\n  registerNode(node: Node): void {\n    const key = this.key\n    if (!node || !node.data) return\n\n    if (!key) {\n      this.nodesMap[node.id] = node\n    } else {\n      const nodeKey = node.key\n      if (!isNil(nodeKey)) this.nodesMap[nodeKey] = node\n    }\n  }\n\n  deregisterNode(node: Node): void {\n    const key = this.key\n    if (!key || !node || !node.data) return\n\n    node.childNodes.forEach((child) => {\n      this.deregisterNode(child)\n    })\n\n    delete this.nodesMap[node.key!]\n  }\n\n  getCheckedNodes(\n    leafOnly = false,\n    includeHalfChecked = false\n  ): TreeNodeData[] {\n    const checkedNodes: TreeNodeData[] = []\n    const traverse = function (node: TreeStore | Node) {\n      const childNodes = (node as TreeStore).root\n        ? (node as TreeStore).root.childNodes\n        : (node as Node).childNodes\n\n      childNodes.forEach((child) => {\n        if (\n          (child.checked || (includeHalfChecked && child.indeterminate)) &&\n          (!leafOnly || (leafOnly && child.isLeaf))\n        ) {\n          checkedNodes.push(child.data)\n        }\n\n        traverse(child)\n      })\n    }\n\n    traverse(this)\n\n    return checkedNodes\n  }\n\n  getCheckedKeys(leafOnly = false): TreeKey[] {\n    return this.getCheckedNodes(leafOnly).map((data) => (data || {})[this.key])\n  }\n\n  getHalfCheckedNodes(): TreeNodeData[] {\n    const nodes: TreeNodeData[] = []\n    const traverse = function (node: TreeStore | Node) {\n      const childNodes = (node as TreeStore).root\n        ? (node as TreeStore).root.childNodes\n        : (node as Node).childNodes\n\n      childNodes.forEach((child) => {\n        if (child.indeterminate) {\n          nodes.push(child.data)\n        }\n\n        traverse(child)\n      })\n    }\n\n    traverse(this)\n\n    return nodes\n  }\n\n  getHalfCheckedKeys(): TreeKey[] {\n    return this.getHalfCheckedNodes().map((data) => (data || {})[this.key])\n  }\n\n  _getAllNodes(): Node[] {\n    const allNodes: Node[] = []\n    const nodesMap = this.nodesMap\n    for (const nodeKey in nodesMap) {\n      if (hasOwn(nodesMap, nodeKey)) {\n        allNodes.push(nodesMap[nodeKey])\n      }\n    }\n\n    return allNodes\n  }\n\n  updateChildren(key: TreeKey, data: TreeData): void {\n    const node = this.nodesMap[key]\n    if (!node) return\n    const childNodes = node.childNodes\n    for (let i = childNodes.length - 1; i >= 0; i--) {\n      const child = childNodes[i]\n      this.remove(child.data)\n    }\n    for (let i = 0, j = data.length; i < j; i++) {\n      const child = data[i]\n      this.append(child, node.data)\n    }\n  }\n\n  _setCheckedKeys(\n    key: TreeKey,\n    leafOnly = false,\n    checkedKeys: { [key: string]: boolean }\n  ) {\n    const allNodes = this._getAllNodes().sort((a, b) => a.level - b.level)\n    const cache: Record<TreeKey, boolean> = Object.create(null)\n    const keys = Object.keys(checkedKeys)\n    allNodes.forEach((node) => node.setChecked(false, false))\n    const cacheCheckedChild = (node: Node) => {\n      node.childNodes.forEach((child) => {\n        cache[child.data[key]] = true\n        if (child.childNodes?.length) {\n          cacheCheckedChild(child)\n        }\n      })\n    }\n    for (let i = 0, j = allNodes.length; i < j; i++) {\n      const node = allNodes[i]\n      const nodeKey: string = node.data[key].toString()\n      const checked = keys.includes(nodeKey)\n      if (!checked) {\n        if (node.checked && !cache[nodeKey]) {\n          node.setChecked(false, false)\n        }\n        continue\n      }\n\n      if (node.childNodes.length) {\n        cacheCheckedChild(node)\n      }\n\n      if (node.isLeaf || this.checkStrictly) {\n        node.setChecked(true, false)\n        continue\n      }\n      node.setChecked(true, true)\n\n      if (leafOnly) {\n        node.setChecked(false, false)\n        const traverse = function (node: Node): void {\n          const childNodes = node.childNodes\n          childNodes.forEach((child) => {\n            if (!child.isLeaf) {\n              child.setChecked(false, false)\n            }\n            traverse(child)\n          })\n        }\n        traverse(node)\n      }\n    }\n  }\n\n  setCheckedNodes(array: Node[], leafOnly = false): void {\n    const key = this.key\n    const checkedKeys: Record<TreeKey, boolean> = {}\n    array.forEach((item) => {\n      checkedKeys[((item || {}) as any)[key]] = true\n    })\n\n    this._setCheckedKeys(key, leafOnly, checkedKeys)\n  }\n\n  setCheckedKeys(keys: TreeKey[], leafOnly = false): void {\n    this.defaultCheckedKeys = keys\n    const key = this.key\n    const checkedKeys: Record<TreeKey, boolean> = {}\n    keys.forEach((key) => {\n      checkedKeys[key] = true\n    })\n\n    this._setCheckedKeys(key, leafOnly, checkedKeys)\n  }\n\n  setDefaultExpandedKeys(keys: TreeKey[]) {\n    keys = keys || []\n    this.defaultExpandedKeys = keys\n    keys.forEach((key) => {\n      const node = this.getNode(key)\n      if (node) node.expand(null, this.autoExpandParent)\n    })\n  }\n\n  setChecked(\n    data: TreeKey | TreeNodeData,\n    checked: boolean,\n    deep: boolean\n  ): void {\n    const node = this.getNode(data)\n\n    if (node) {\n      node.setChecked(!!checked, deep)\n    }\n  }\n\n  getCurrentNode() {\n    return this.currentNode\n  }\n\n  setCurrentNode(currentNode: Node): void {\n    const prevCurrentNode = this.currentNode\n    if (prevCurrentNode) {\n      prevCurrentNode.isCurrent = false\n    }\n    this.currentNode = currentNode\n    this.currentNode.isCurrent = true\n  }\n\n  setUserCurrentNode(node: Node, shouldAutoExpandParent = true): void {\n    const key = (node as any)[this.key]\n    const currNode = this.nodesMap[key]\n    this.setCurrentNode(currNode)\n    if (\n      shouldAutoExpandParent &&\n      this.currentNode &&\n      this.currentNode.level > 1\n    ) {\n      this.currentNode.parent?.expand(null, true)\n    }\n  }\n\n  setCurrentNodeKey(key: TreeKey | null, shouldAutoExpandParent = true): void {\n    this.currentNodeKey = key\n    if (isPropAbsent(key)) {\n      this.currentNode && (this.currentNode.isCurrent = false)\n      this.currentNode = null\n      return\n    }\n    const node = this.getNode(key)\n    if (node) {\n      this.setCurrentNode(node)\n      if (\n        shouldAutoExpandParent &&\n        this.currentNode &&\n        this.currentNode.level > 1\n      ) {\n        this.currentNode.parent?.expand(null, true)\n      }\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}