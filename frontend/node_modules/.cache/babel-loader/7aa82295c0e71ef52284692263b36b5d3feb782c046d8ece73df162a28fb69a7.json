{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport { defineComponent, useSlots, ref, computed, provide, reactive, watch, onBeforeUpdate, onMounted, openBlock, createElementBlock, normalizeClass, unref, Fragment, renderList, createBlock, withCtx, renderSlot, nextTick } from 'vue';\nimport { isEqual, flattenDeep, cloneDeep } from 'lodash-unified';\nimport ElCascaderMenu from './menu.mjs';\nimport Store from './store.mjs';\nimport Node from './node.mjs';\nimport { cascaderPanelProps, cascaderPanelEmits, useCascaderConfig } from './config.mjs';\nimport { sortByOriginalOrder, checkNode, getMenuIndex } from './utils.mjs';\nimport { CASCADER_PANEL_INJECTION_KEY } from './types.mjs';\nimport _export_sfc from '../../../_virtual/plugin-vue_export-helper.mjs';\nimport { unique, castArray } from '../../../utils/arrays.mjs';\nimport { focusNode, getSibling } from '../../../utils/dom/aria.mjs';\nimport { useNamespace } from '../../../hooks/use-namespace/index.mjs';\nimport { UPDATE_MODEL_EVENT, CHANGE_EVENT } from '../../../constants/event.mjs';\nimport { isEmpty } from '../../../utils/types.mjs';\nimport { isClient } from '@vueuse/core';\nimport { scrollIntoView } from '../../../utils/dom/scroll.mjs';\nimport { getEventCode } from '../../../utils/dom/event.mjs';\nimport { EVENT_CODE } from '../../../constants/aria.mjs';\nconst _sfc_main = defineComponent({\n  ...{\n    name: \"ElCascaderPanel\"\n  },\n  __name: \"index\",\n  props: cascaderPanelProps,\n  emits: cascaderPanelEmits,\n  setup(__props, {\n    expose: __expose,\n    emit: __emit\n  }) {\n    const props = __props;\n    const emit = __emit;\n    let manualChecked = false;\n    const ns = useNamespace(\"cascader\");\n    const config = useCascaderConfig(props);\n    const slots = useSlots();\n    let store;\n    const initialLoaded = ref(true);\n    const initialLoadedOnce = ref(false);\n    const menuList = ref([]);\n    const checkedValue = ref();\n    const menus = ref([]);\n    const expandingNode = ref();\n    const checkedNodes = ref([]);\n    const isHoverMenu = computed(() => config.value.expandTrigger === \"hover\");\n    const renderLabelFn = computed(() => props.renderLabel || slots.default);\n    const initStore = () => {\n      const {\n        options\n      } = props;\n      const cfg = config.value;\n      manualChecked = false;\n      store = new Store(options, cfg);\n      menus.value = [store.getNodes()];\n      if (cfg.lazy && isEmpty(props.options)) {\n        initialLoaded.value = false;\n        lazyLoad(void 0, list => {\n          if (list) {\n            store = new Store(list, cfg);\n            menus.value = [store.getNodes()];\n          }\n          initialLoaded.value = true;\n          syncCheckedValue(false, true);\n        });\n      } else {\n        syncCheckedValue(false, true);\n      }\n    };\n    const lazyLoad = (node, cb) => {\n      const cfg = config.value;\n      node = node || new Node({}, cfg, void 0, true);\n      node.loading = true;\n      const resolve = dataList => {\n        const _node = node;\n        const parent = _node.root ? null : _node;\n        _node.loading = false;\n        _node.loaded = true;\n        _node.childrenData = _node.childrenData || [];\n        dataList && (store == null ? void 0 : store.appendNodes(dataList, parent));\n        dataList && (cb == null ? void 0 : cb(dataList));\n        if (node.level === 0) {\n          initialLoadedOnce.value = true;\n        }\n      };\n      const reject = () => {\n        node.loading = false;\n        node.loaded = false;\n        if (node.level === 0) {\n          initialLoaded.value = true;\n        }\n      };\n      cfg.lazyLoad(node, resolve, reject);\n    };\n    const expandNode = (node, silent) => {\n      var _a;\n      const {\n        level\n      } = node;\n      const newMenus = menus.value.slice(0, level);\n      let newExpandingNode;\n      if (node.isLeaf) {\n        newExpandingNode = node.pathNodes[level - 2];\n      } else {\n        newExpandingNode = node;\n        newMenus.push(node.children);\n      }\n      if (((_a = expandingNode.value) == null ? void 0 : _a.uid) !== (newExpandingNode == null ? void 0 : newExpandingNode.uid)) {\n        expandingNode.value = node;\n        menus.value = newMenus;\n        !silent && emit(\"expand-change\", (node == null ? void 0 : node.pathValues) || []);\n      }\n    };\n    const handleCheckChange = (node, checked, emitClose = true) => {\n      const {\n        checkStrictly,\n        multiple\n      } = config.value;\n      const oldNode = checkedNodes.value[0];\n      manualChecked = true;\n      !multiple && (oldNode == null ? void 0 : oldNode.doCheck(false));\n      node.doCheck(checked);\n      calculateCheckedValue();\n      emitClose && !multiple && !checkStrictly && emit(\"close\");\n      !emitClose && !multiple && expandParentNode(node);\n    };\n    const expandParentNode = node => {\n      if (!node) return;\n      node = node.parent;\n      expandParentNode(node);\n      node && expandNode(node);\n    };\n    const getFlattedNodes = leafOnly => store == null ? void 0 : store.getFlattedNodes(leafOnly);\n    const getCheckedNodes = leafOnly => {\n      var _a;\n      return (_a = getFlattedNodes(leafOnly)) == null ? void 0 : _a.filter(({\n        checked\n      }) => checked !== false);\n    };\n    const clearCheckedNodes = () => {\n      checkedNodes.value.forEach(node => node.doCheck(false));\n      calculateCheckedValue();\n      menus.value = menus.value.slice(0, 1);\n      expandingNode.value = void 0;\n      emit(\"expand-change\", []);\n    };\n    const calculateCheckedValue = () => {\n      var _a;\n      const {\n        checkStrictly,\n        multiple\n      } = config.value;\n      const oldNodes = checkedNodes.value;\n      const newNodes = getCheckedNodes(!checkStrictly);\n      const nodes = sortByOriginalOrder(oldNodes, newNodes);\n      const values = nodes.map(node => node.valueByOption);\n      checkedNodes.value = nodes;\n      checkedValue.value = multiple ? values : (_a = values[0]) != null ? _a : null;\n    };\n    const syncCheckedValue = (loaded = false, forced = false) => {\n      const {\n        modelValue\n      } = props;\n      const {\n        lazy,\n        multiple,\n        checkStrictly\n      } = config.value;\n      const leafOnly = !checkStrictly;\n      if (!initialLoaded.value || manualChecked || !forced && isEqual(modelValue, checkedValue.value)) return;\n      if (lazy && !loaded) {\n        const values = unique(flattenDeep(castArray(modelValue)));\n        const nodes = values.map(val => store == null ? void 0 : store.getNodeByValue(val)).filter(node => !!node && !node.loaded && !node.loading);\n        if (nodes.length) {\n          nodes.forEach(node => {\n            lazyLoad(node, () => syncCheckedValue(false, forced));\n          });\n        } else {\n          syncCheckedValue(true, forced);\n        }\n      } else {\n        const values = multiple ? castArray(modelValue) : [modelValue];\n        const nodes = unique(values.map(val => store == null ? void 0 : store.getNodeByValue(val, leafOnly)));\n        syncMenuState(nodes, forced);\n        checkedValue.value = cloneDeep(modelValue != null ? modelValue : void 0);\n      }\n    };\n    const syncMenuState = (newCheckedNodes, reserveExpandingState = true) => {\n      const {\n        checkStrictly\n      } = config.value;\n      const oldNodes = checkedNodes.value;\n      const newNodes = newCheckedNodes.filter(node => !!node && (checkStrictly || node.isLeaf));\n      const oldExpandingNode = store == null ? void 0 : store.getSameNode(expandingNode.value);\n      const newExpandingNode = reserveExpandingState && oldExpandingNode || newNodes[0];\n      if (newExpandingNode) {\n        newExpandingNode.pathNodes.forEach(node => expandNode(node, true));\n      } else {\n        expandingNode.value = void 0;\n      }\n      oldNodes.forEach(node => node.doCheck(false));\n      reactive(newNodes).forEach(node => node.doCheck(true));\n      checkedNodes.value = newNodes;\n      nextTick(scrollToExpandingNode);\n    };\n    const scrollToExpandingNode = () => {\n      if (!isClient) return;\n      menuList.value.forEach(menu => {\n        const menuElement = menu == null ? void 0 : menu.$el;\n        if (menuElement) {\n          const container = menuElement.querySelector(`.${ns.namespace.value}-scrollbar__wrap`);\n          let activeNode = menuElement.querySelector(`.${ns.b(\"node\")}.in-active-path`);\n          if (!activeNode) {\n            const activeElements = menuElement.querySelectorAll(`.${ns.b(\"node\")}.${ns.is(\"active\")}`);\n            activeNode = activeElements[activeElements.length - 1];\n          }\n          scrollIntoView(container, activeNode);\n        }\n      });\n    };\n    const handleKeyDown = e => {\n      const target = e.target;\n      const code = getEventCode(e);\n      switch (code) {\n        case EVENT_CODE.up:\n        case EVENT_CODE.down:\n          {\n            e.preventDefault();\n            const distance = code === EVENT_CODE.up ? -1 : 1;\n            focusNode(getSibling(target, distance, `.${ns.b(\"node\")}[tabindex=\"-1\"]`));\n            break;\n          }\n        case EVENT_CODE.left:\n          {\n            e.preventDefault();\n            const preMenu = menuList.value[getMenuIndex(target) - 1];\n            const expandedNode = preMenu == null ? void 0 : preMenu.$el.querySelector(`.${ns.b(\"node\")}[aria-expanded=\"true\"]`);\n            focusNode(expandedNode);\n            break;\n          }\n        case EVENT_CODE.right:\n          {\n            e.preventDefault();\n            const nextMenu = menuList.value[getMenuIndex(target) + 1];\n            const firstNode = nextMenu == null ? void 0 : nextMenu.$el.querySelector(`.${ns.b(\"node\")}[tabindex=\"-1\"]`);\n            focusNode(firstNode);\n            break;\n          }\n        case EVENT_CODE.enter:\n        case EVENT_CODE.numpadEnter:\n          checkNode(target);\n          break;\n      }\n    };\n    provide(CASCADER_PANEL_INJECTION_KEY, reactive({\n      config,\n      expandingNode,\n      checkedNodes,\n      isHoverMenu,\n      initialLoaded,\n      renderLabelFn,\n      lazyLoad,\n      expandNode,\n      handleCheckChange\n    }));\n    watch(config, (newVal, oldVal) => {\n      if (isEqual(newVal, oldVal)) return;\n      initStore();\n    }, {\n      immediate: true\n    });\n    watch(() => props.options, initStore, {\n      deep: true\n    });\n    watch(() => props.modelValue, () => {\n      manualChecked = false;\n      syncCheckedValue();\n    }, {\n      deep: true\n    });\n    watch(() => checkedValue.value, val => {\n      if (!isEqual(val, props.modelValue)) {\n        emit(UPDATE_MODEL_EVENT, val);\n        emit(CHANGE_EVENT, val);\n      }\n    });\n    const loadLazyRootNodes = () => {\n      if (initialLoadedOnce.value) return;\n      initStore();\n    };\n    onBeforeUpdate(() => menuList.value = []);\n    onMounted(() => !isEmpty(props.modelValue) && syncCheckedValue());\n    __expose({\n      menuList,\n      menus,\n      checkedNodes,\n      handleKeyDown,\n      handleCheckChange,\n      getFlattedNodes,\n      getCheckedNodes,\n      clearCheckedNodes,\n      calculateCheckedValue,\n      scrollToExpandingNode,\n      loadLazyRootNodes\n    });\n    return (_ctx, _cache) => {\n      return openBlock(), createElementBlock(\"div\", {\n        class: normalizeClass([unref(ns).b(\"panel\"), unref(ns).is(\"bordered\", _ctx.border)]),\n        onKeydown: handleKeyDown\n      }, [(openBlock(true), createElementBlock(Fragment, null, renderList(menus.value, (menu, index) => {\n        return openBlock(), createBlock(ElCascaderMenu, {\n          key: index,\n          ref_for: true,\n          ref: item => menuList.value[index] = item,\n          index,\n          nodes: [...menu]\n        }, {\n          empty: withCtx(() => [renderSlot(_ctx.$slots, \"empty\")]),\n          _: 3\n        }, 8, [\"index\", \"nodes\"]);\n      }), 128))], 34);\n    };\n  }\n});\nvar CascaderPanel = /* @__PURE__ */_export_sfc(_sfc_main, [[\"__file\", \"/home/runner/work/element-plus/element-plus/packages/components/cascader-panel/src/index.vue\"]]);\nexport { CascaderPanel as default };","map":{"version":3,"names":["props","__props","emit","__emit","manualChecked","ns","useNamespace","config","useCascaderConfig","slots","useSlots","store","initialLoaded","ref","initialLoadedOnce","menuList","checkedValue","menus","expandingNode","checkedNodes","isHoverMenu","computed","value","expandTrigger","renderLabelFn","renderLabel","default","initStore","options","cfg","Store","getNodes","lazy","isEmpty","lazyLoad","list","syncCheckedValue","node","cb","Node","loading","resolve","dataList","_node","parent","root","loaded","childrenData","appendNodes","level","reject","expandNode","silent","newMenus","slice","newExpandingNode","isLeaf","pathNodes","push","children","_a","uid","pathValues","handleCheckChange","checked","emitClose","checkStrictly","multiple","oldNode","doCheck","calculateCheckedValue","expandParentNode","getFlattedNodes","leafOnly","getCheckedNodes","filter","clearCheckedNodes","forEach","oldNodes","newNodes","nodes","sortByOriginalOrder","values","map","valueByOption","forced","modelValue","isEqual","unique","flattenDeep","castArray","val","getNodeByValue","length","syncMenuState","cloneDeep","newCheckedNodes","reserveExpandingState","oldExpandingNode","getSameNode","reactive","nextTick","scrollToExpandingNode","isClient","menu","menuElement","$el","container","querySelector","namespace","activeNode","b","activeElements","querySelectorAll","is","scrollIntoView","handleKeyDown","e","target","code","getEventCode","EVENT_CODE","up","down","preventDefault","distance","focusNode","getSibling","left","preMenu","getMenuIndex","expandedNode","right","nextMenu","firstNode","enter","numpadEnter","checkNode","provide","CASCADER_PANEL_INJECTION_KEY","watch","newVal","oldVal","immediate","deep","UPDATE_MODEL_EVENT","CHANGE_EVENT","loadLazyRootNodes","onBeforeUpdate","onMounted","__expose","openBlock","createElementBlock","class","normalizeClass","unref","_ctx","border","onKeydown","Fragment","renderList","index","createBlock","ElCascaderMenu","key","ref_for","item","empty","withCtx","renderSlot","$slots","_"],"sources":["../../../../../../packages/components/cascader-panel/src/index.vue"],"sourcesContent":["<template>\n  <div\n    :class=\"[ns.b('panel'), ns.is('bordered', border)]\"\n    @keydown=\"handleKeyDown\"\n  >\n    <el-cascader-menu\n      v-for=\"(menu, index) in menus\"\n      :key=\"index\"\n      :ref=\"(item) => (menuList[index] = item as CascaderMenuInstance)\"\n      :index=\"index\"\n      :nodes=\"[...menu]\"\n    >\n      <template #empty>\n        <slot name=\"empty\" />\n      </template>\n    </el-cascader-menu>\n  </div>\n</template>\n\n<script lang=\"ts\" setup>\nimport {\n  computed,\n  nextTick,\n  onBeforeUpdate,\n  onMounted,\n  provide,\n  reactive,\n  ref,\n  useSlots,\n  watch,\n} from 'vue'\nimport { cloneDeep, flattenDeep, isEqual } from 'lodash-unified'\nimport {\n  castArray,\n  focusNode,\n  getEventCode,\n  getSibling,\n  isClient,\n  isEmpty,\n  scrollIntoView,\n  unique,\n} from '@element-plus/utils'\nimport {\n  CHANGE_EVENT,\n  EVENT_CODE,\n  UPDATE_MODEL_EVENT,\n} from '@element-plus/constants'\nimport { useNamespace } from '@element-plus/hooks'\nimport ElCascaderMenu from './menu.vue'\nimport Store from './store'\nimport Node from './node'\nimport {\n  cascaderPanelEmits,\n  cascaderPanelProps,\n  useCascaderConfig,\n} from './config'\nimport { checkNode, getMenuIndex, sortByOriginalOrder } from './utils'\nimport { CASCADER_PANEL_INJECTION_KEY } from './types'\n\nimport type {\n  CascaderNode,\n  CascaderNodeValue,\n  CascaderOption,\n  CascaderValue,\n  ElCascaderPanelContext,\n} from './types'\nimport type { CascaderMenuInstance } from './instance'\n\ndefineOptions({\n  name: 'ElCascaderPanel',\n})\n\nconst props = defineProps(cascaderPanelProps)\nconst emit = defineEmits(cascaderPanelEmits)\n\n// for interrupt sync check status in lazy mode\nlet manualChecked = false\n\nconst ns = useNamespace('cascader')\nconst config = useCascaderConfig(props)\nconst slots = useSlots()\n\nlet store: Store\nconst initialLoaded = ref(true)\nconst initialLoadedOnce = ref(false)\nconst menuList = ref<CascaderMenuInstance[]>([])\nconst checkedValue = ref<CascaderValue>()\nconst menus = ref<CascaderNode[][]>([])\nconst expandingNode = ref<CascaderNode>()\nconst checkedNodes = ref<CascaderNode[]>([])\n\nconst isHoverMenu = computed(() => config.value.expandTrigger === 'hover')\nconst renderLabelFn = computed(() => props.renderLabel || slots.default)\n\nconst initStore = () => {\n  const { options } = props\n  const cfg = config.value\n\n  manualChecked = false\n  store = new Store(options, cfg)\n  menus.value = [store.getNodes()]\n\n  if (cfg.lazy && isEmpty(props.options)) {\n    initialLoaded.value = false\n    lazyLoad(undefined, (list) => {\n      if (list) {\n        store = new Store(list, cfg)\n        menus.value = [store.getNodes()]\n      }\n      initialLoaded.value = true\n      syncCheckedValue(false, true)\n    })\n  } else {\n    syncCheckedValue(false, true)\n  }\n}\n\nconst lazyLoad: ElCascaderPanelContext['lazyLoad'] = (node, cb) => {\n  const cfg = config.value\n  node! = node || new Node({}, cfg, undefined, true)\n  node.loading = true\n\n  const resolve = (dataList?: CascaderOption[]) => {\n    const _node = node as Node\n    const parent = _node.root ? null : _node\n    _node.loading = false\n    _node.loaded = true\n    _node.childrenData = _node.childrenData || []\n    dataList && store?.appendNodes(dataList, parent as Node)\n    dataList && cb?.(dataList)\n    if (node.level === 0) {\n      initialLoadedOnce.value = true\n    }\n  }\n\n  const reject = () => {\n    node!.loading = false\n    node!.loaded = false\n    if (node!.level === 0) {\n      initialLoaded.value = true\n    }\n  }\n\n  cfg.lazyLoad(node, resolve, reject)\n}\n\nconst expandNode: ElCascaderPanelContext['expandNode'] = (node, silent) => {\n  const { level } = node\n  const newMenus = menus.value.slice(0, level)\n  let newExpandingNode: CascaderNode\n\n  if (node.isLeaf) {\n    newExpandingNode = node.pathNodes[level - 2]\n  } else {\n    newExpandingNode = node\n    newMenus.push(node.children)\n  }\n\n  if (expandingNode.value?.uid !== newExpandingNode?.uid) {\n    expandingNode.value = node\n    menus.value = newMenus\n    !silent && emit('expand-change', node?.pathValues || [])\n  }\n}\n\nconst handleCheckChange: ElCascaderPanelContext['handleCheckChange'] = (\n  node,\n  checked,\n  emitClose = true\n) => {\n  const { checkStrictly, multiple } = config.value\n  const oldNode = checkedNodes.value[0]\n  manualChecked = true\n\n  !multiple && oldNode?.doCheck(false)\n  node.doCheck(checked)\n  calculateCheckedValue()\n  emitClose && !multiple && !checkStrictly && emit('close')\n  !emitClose && !multiple && expandParentNode(node)\n}\n\nconst expandParentNode = (node: Node | undefined) => {\n  if (!node) return\n  node = node.parent\n  expandParentNode(node)\n  node && expandNode(node)\n}\n\nconst getFlattedNodes = (leafOnly: boolean) => store?.getFlattedNodes(leafOnly)\n\nconst getCheckedNodes = (leafOnly: boolean) => {\n  return getFlattedNodes(leafOnly)?.filter(({ checked }) => checked !== false)\n}\n\nconst clearCheckedNodes = () => {\n  checkedNodes.value.forEach((node) => node.doCheck(false))\n  calculateCheckedValue()\n  menus.value = menus.value.slice(0, 1)\n  expandingNode.value = undefined\n  emit('expand-change', [])\n}\n\nconst calculateCheckedValue = () => {\n  const { checkStrictly, multiple } = config.value\n  const oldNodes = checkedNodes.value\n  const newNodes = getCheckedNodes(!checkStrictly)!\n  // ensure the original order\n  const nodes = sortByOriginalOrder(oldNodes, newNodes)\n  const values = nodes.map((node) => node.valueByOption)\n  checkedNodes.value = nodes\n  checkedValue.value = multiple ? values : (values[0] ?? null)\n}\n\nconst syncCheckedValue = (loaded = false, forced = false) => {\n  const { modelValue } = props\n  const { lazy, multiple, checkStrictly } = config.value\n  const leafOnly = !checkStrictly\n\n  if (\n    !initialLoaded.value ||\n    manualChecked ||\n    (!forced && isEqual(modelValue, checkedValue.value))\n  )\n    return\n\n  if (lazy && !loaded) {\n    const values: CascaderNodeValue[] = unique(\n      flattenDeep(castArray(modelValue as CascaderNodeValue[]))\n    )\n    const nodes = values\n      .map((val) => store?.getNodeByValue(val))\n      .filter((node) => !!node && !node.loaded && !node.loading) as Node[]\n\n    if (nodes.length) {\n      nodes.forEach((node) => {\n        lazyLoad(node, () => syncCheckedValue(false, forced))\n      })\n    } else {\n      syncCheckedValue(true, forced)\n    }\n  } else {\n    const values = multiple ? castArray(modelValue) : [modelValue]\n    const nodes = unique(\n      values.map((val) =>\n        store?.getNodeByValue(val as CascaderNodeValue, leafOnly)\n      )\n    ) as Node[]\n    syncMenuState(nodes, forced)\n    checkedValue.value = cloneDeep(modelValue ?? undefined)\n  }\n}\n\nconst syncMenuState = (\n  newCheckedNodes: CascaderNode[],\n  reserveExpandingState = true\n) => {\n  const { checkStrictly } = config.value\n  const oldNodes = checkedNodes.value\n  const newNodes = newCheckedNodes.filter(\n    (node) => !!node && (checkStrictly || node.isLeaf)\n  )\n  const oldExpandingNode = store?.getSameNode(expandingNode.value!)\n  const newExpandingNode =\n    (reserveExpandingState && oldExpandingNode) || newNodes[0]\n\n  if (newExpandingNode) {\n    newExpandingNode.pathNodes.forEach((node) => expandNode(node, true))\n  } else {\n    expandingNode.value = undefined\n  }\n\n  oldNodes.forEach((node) => node.doCheck(false))\n  reactive(newNodes).forEach((node) => node.doCheck(true))\n  checkedNodes.value = newNodes\n  nextTick(scrollToExpandingNode)\n}\n\nconst scrollToExpandingNode = () => {\n  if (!isClient) return\n\n  menuList.value.forEach((menu) => {\n    const menuElement = menu?.$el\n    if (menuElement) {\n      const container = menuElement.querySelector(\n        `.${ns.namespace.value}-scrollbar__wrap`\n      )\n      let activeNode = menuElement.querySelector(\n        `.${ns.b('node')}.in-active-path`\n      )\n      if (!activeNode) {\n        const activeElements = menuElement.querySelectorAll(\n          `.${ns.b('node')}.${ns.is('active')}`\n        )\n        activeNode = activeElements[activeElements.length - 1]\n      }\n      scrollIntoView(container, activeNode)\n    }\n  })\n}\n\nconst handleKeyDown = (e: KeyboardEvent) => {\n  const target = e.target as HTMLElement\n  const code = getEventCode(e)\n\n  switch (code) {\n    case EVENT_CODE.up:\n    case EVENT_CODE.down: {\n      e.preventDefault()\n      const distance = code === EVENT_CODE.up ? -1 : 1\n      focusNode(\n        getSibling(\n          target,\n          distance,\n          `.${ns.b('node')}[tabindex=\"-1\"]`\n        ) as HTMLElement\n      )\n      break\n    }\n    case EVENT_CODE.left: {\n      e.preventDefault()\n      const preMenu = menuList.value[getMenuIndex(target) - 1]\n      const expandedNode = preMenu?.$el.querySelector(\n        `.${ns.b('node')}[aria-expanded=\"true\"]`\n      )\n      focusNode(expandedNode)\n      break\n    }\n    case EVENT_CODE.right: {\n      e.preventDefault()\n      const nextMenu = menuList.value[getMenuIndex(target) + 1]\n      const firstNode = nextMenu?.$el.querySelector(\n        `.${ns.b('node')}[tabindex=\"-1\"]`\n      )\n      focusNode(firstNode)\n      break\n    }\n    case EVENT_CODE.enter:\n    case EVENT_CODE.numpadEnter:\n      checkNode(target)\n      break\n  }\n}\n\nprovide(\n  CASCADER_PANEL_INJECTION_KEY,\n  reactive({\n    config,\n    expandingNode,\n    checkedNodes,\n    isHoverMenu,\n    initialLoaded,\n    renderLabelFn,\n    lazyLoad,\n    expandNode,\n    handleCheckChange,\n  })\n)\n\nwatch(\n  config,\n  (newVal, oldVal) => {\n    if (isEqual(newVal, oldVal)) return\n    initStore()\n  },\n  {\n    immediate: true,\n  }\n)\n\nwatch(() => props.options, initStore, {\n  deep: true,\n})\n\nwatch(\n  () => props.modelValue,\n  () => {\n    manualChecked = false\n    syncCheckedValue()\n  },\n  {\n    deep: true,\n  }\n)\n\nwatch(\n  () => checkedValue.value,\n  (val) => {\n    if (!isEqual(val, props.modelValue)) {\n      emit(UPDATE_MODEL_EVENT, val)\n      emit(CHANGE_EVENT, val)\n    }\n  }\n)\n\nconst loadLazyRootNodes = () => {\n  if (initialLoadedOnce.value) return\n  initStore()\n}\n\nonBeforeUpdate(() => (menuList.value = []))\n\nonMounted(() => !isEmpty(props.modelValue) && syncCheckedValue())\n\ndefineExpose({\n  menuList,\n  menus,\n  checkedNodes,\n  handleKeyDown,\n  handleCheckChange,\n  getFlattedNodes,\n  /**\n   * @description get an array of currently selected node,(leafOnly) whether only return the leaf checked nodes, default is `false`\n   */\n  getCheckedNodes,\n  /**\n   * @description clear checked nodes\n   */\n  clearCheckedNodes,\n  calculateCheckedValue,\n  scrollToExpandingNode,\n  loadLazyRootNodes,\n})\n</script>\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}