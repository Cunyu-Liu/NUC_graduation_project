{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { ref, onMounted, onBeforeUnmount } from 'vue';\nimport { FOCUSOUT_PREVENTED, FOCUSOUT_PREVENTED_OPTS } from './tokens.mjs';\nimport { focusElement } from '../../../utils/dom/aria.mjs';\nconst focusReason = ref();\nconst lastUserFocusTimestamp = ref(0);\nconst lastAutomatedFocusTimestamp = ref(0);\nlet focusReasonUserCount = 0;\nconst obtainAllFocusableElements = element => {\n  const nodes = [];\n  const walker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: node => {\n      const isHiddenInput = node.tagName === \"INPUT\" && node.type === \"hidden\";\n      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;\n      return node.tabIndex >= 0 || node === document.activeElement ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    }\n  });\n  while (walker.nextNode()) nodes.push(walker.currentNode);\n  return nodes;\n};\nconst getVisibleElement = (elements, container) => {\n  for (const element of elements) {\n    if (!isHidden(element, container)) return element;\n  }\n};\nconst isHidden = (element, container) => {\n  if (process.env.NODE_ENV === \"test\") return false;\n  if (getComputedStyle(element).visibility === \"hidden\") return true;\n  while (element) {\n    if (container && element === container) return false;\n    if (getComputedStyle(element).display === \"none\") return true;\n    element = element.parentElement;\n  }\n  return false;\n};\nconst getEdges = container => {\n  const focusable = obtainAllFocusableElements(container);\n  const first = getVisibleElement(focusable, container);\n  const last = getVisibleElement(focusable.reverse(), container);\n  return [first, last];\n};\nconst isSelectable = element => {\n  return element instanceof HTMLInputElement && \"select\" in element;\n};\nconst tryFocus = (element, shouldSelect) => {\n  if (element) {\n    const prevFocusedElement = document.activeElement;\n    focusElement(element, {\n      preventScroll: true\n    });\n    lastAutomatedFocusTimestamp.value = window.performance.now();\n    if (element !== prevFocusedElement && isSelectable(element) && shouldSelect) {\n      element.select();\n    }\n  }\n};\nfunction removeFromStack(list, item) {\n  const copy = [...list];\n  const idx = list.indexOf(item);\n  if (idx !== -1) {\n    copy.splice(idx, 1);\n  }\n  return copy;\n}\nconst createFocusableStack = () => {\n  let stack = [];\n  const push = layer => {\n    const currentLayer = stack[0];\n    if (currentLayer && layer !== currentLayer) {\n      currentLayer.pause();\n    }\n    stack = removeFromStack(stack, layer);\n    stack.unshift(layer);\n  };\n  const remove = layer => {\n    var _a, _b;\n    stack = removeFromStack(stack, layer);\n    (_b = (_a = stack[0]) == null ? void 0 : _a.resume) == null ? void 0 : _b.call(_a);\n  };\n  return {\n    push,\n    remove\n  };\n};\nconst focusFirstDescendant = (elements, shouldSelect = false) => {\n  const prevFocusedElement = document.activeElement;\n  for (const element of elements) {\n    tryFocus(element, shouldSelect);\n    if (document.activeElement !== prevFocusedElement) return;\n  }\n};\nconst focusableStack = createFocusableStack();\nconst isFocusCausedByUserEvent = () => {\n  return lastUserFocusTimestamp.value > lastAutomatedFocusTimestamp.value;\n};\nconst notifyFocusReasonPointer = () => {\n  focusReason.value = \"pointer\";\n  lastUserFocusTimestamp.value = window.performance.now();\n};\nconst notifyFocusReasonKeydown = () => {\n  focusReason.value = \"keyboard\";\n  lastUserFocusTimestamp.value = window.performance.now();\n};\nconst useFocusReason = () => {\n  onMounted(() => {\n    if (focusReasonUserCount === 0) {\n      document.addEventListener(\"mousedown\", notifyFocusReasonPointer);\n      document.addEventListener(\"touchstart\", notifyFocusReasonPointer);\n      document.addEventListener(\"keydown\", notifyFocusReasonKeydown);\n    }\n    focusReasonUserCount++;\n  });\n  onBeforeUnmount(() => {\n    focusReasonUserCount--;\n    if (focusReasonUserCount <= 0) {\n      document.removeEventListener(\"mousedown\", notifyFocusReasonPointer);\n      document.removeEventListener(\"touchstart\", notifyFocusReasonPointer);\n      document.removeEventListener(\"keydown\", notifyFocusReasonKeydown);\n    }\n  });\n  return {\n    focusReason,\n    lastUserFocusTimestamp,\n    lastAutomatedFocusTimestamp\n  };\n};\nconst createFocusOutPreventedEvent = detail => {\n  return new CustomEvent(FOCUSOUT_PREVENTED, {\n    ...FOCUSOUT_PREVENTED_OPTS,\n    detail\n  });\n};\nexport { createFocusOutPreventedEvent, focusFirstDescendant, focusableStack, getEdges, getVisibleElement, isFocusCausedByUserEvent, isHidden, obtainAllFocusableElements, tryFocus, useFocusReason };","map":{"version":3,"names":["focusReason","ref","lastUserFocusTimestamp","lastAutomatedFocusTimestamp","focusReasonUserCount","obtainAllFocusableElements","element","nodes","walker","document","createTreeWalker","NodeFilter","SHOW_ELEMENT","acceptNode","node","isHiddenInput","tagName","type","disabled","hidden","FILTER_SKIP","tabIndex","activeElement","FILTER_ACCEPT","nextNode","push","currentNode","getVisibleElement","elements","container","isHidden","process","env","NODE_ENV","getComputedStyle","visibility","display","parentElement","getEdges","focusable","first","last","reverse","isSelectable","HTMLInputElement","tryFocus","shouldSelect","prevFocusedElement","focusElement","preventScroll","value","window","performance","now","select","removeFromStack","list","item","copy","idx","indexOf","splice","createFocusableStack","stack","layer","currentLayer","pause","unshift","remove","_a","_b","resume","call","focusFirstDescendant","focusableStack","isFocusCausedByUserEvent","notifyFocusReasonPointer","notifyFocusReasonKeydown","useFocusReason","onMounted","addEventListener","onBeforeUnmount","removeEventListener","createFocusOutPreventedEvent","detail","CustomEvent","FOCUSOUT_PREVENTED","FOCUSOUT_PREVENTED_OPTS"],"sources":["../../../../../../packages/components/focus-trap/src/utils.ts"],"sourcesContent":["import { onBeforeUnmount, onMounted, ref } from 'vue'\nimport { focusElement } from '@element-plus/utils'\nimport { FOCUSOUT_PREVENTED, FOCUSOUT_PREVENTED_OPTS } from './tokens'\n\nconst focusReason = ref<'pointer' | 'keyboard'>()\nconst lastUserFocusTimestamp = ref<number>(0)\nconst lastAutomatedFocusTimestamp = ref<number>(0)\nlet focusReasonUserCount = 0\n\nexport type FocusLayer = {\n  paused: boolean\n  pause: () => void\n  resume: () => void\n}\n\nexport type FocusStack = FocusLayer[]\n\nexport const obtainAllFocusableElements = (\n  element: HTMLElement\n): HTMLElement[] => {\n  const nodes: HTMLElement[] = []\n  const walker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: (\n      node: Element & {\n        disabled: boolean\n        hidden: boolean\n        type: string\n        tabIndex: number\n      }\n    ) => {\n      const isHiddenInput = node.tagName === 'INPUT' && node.type === 'hidden'\n      if (node.disabled || node.hidden || isHiddenInput)\n        return NodeFilter.FILTER_SKIP\n      return node.tabIndex >= 0 || node === document.activeElement\n        ? NodeFilter.FILTER_ACCEPT\n        : NodeFilter.FILTER_SKIP\n    },\n  })\n  while (walker.nextNode()) nodes.push(walker.currentNode as HTMLElement)\n\n  return nodes\n}\n\nexport const getVisibleElement = (\n  elements: HTMLElement[],\n  container: HTMLElement\n) => {\n  for (const element of elements) {\n    if (!isHidden(element, container)) return element\n  }\n}\n\nexport const isHidden = (element: HTMLElement, container: HTMLElement) => {\n  if (process.env.NODE_ENV === 'test') return false\n  if (getComputedStyle(element).visibility === 'hidden') return true\n\n  while (element) {\n    if (container && element === container) return false\n    if (getComputedStyle(element).display === 'none') return true\n    element = element.parentElement as HTMLElement\n  }\n\n  return false\n}\n\nexport const getEdges = (container: HTMLElement) => {\n  const focusable = obtainAllFocusableElements(container)\n  const first = getVisibleElement(focusable, container)\n  const last = getVisibleElement(focusable.reverse(), container)\n  return [first, last]\n}\n\nconst isSelectable = (\n  element: any\n): element is HTMLInputElement & { select: () => void } => {\n  return element instanceof HTMLInputElement && 'select' in element\n}\n\nexport const tryFocus = (\n  element?: HTMLElement | { focus: () => void } | null,\n  shouldSelect?: boolean\n) => {\n  if (element) {\n    const prevFocusedElement = document.activeElement\n\n    focusElement(element, { preventScroll: true })\n    lastAutomatedFocusTimestamp.value = window.performance.now()\n\n    if (\n      element !== prevFocusedElement &&\n      isSelectable(element) &&\n      shouldSelect\n    ) {\n      element.select()\n    }\n  }\n}\n\nfunction removeFromStack<T>(list: T[], item: T) {\n  const copy = [...list]\n\n  const idx = list.indexOf(item)\n\n  if (idx !== -1) {\n    copy.splice(idx, 1)\n  }\n  return copy\n}\n\nconst createFocusableStack = () => {\n  let stack = [] as FocusStack\n\n  const push = (layer: FocusLayer) => {\n    const currentLayer = stack[0]\n\n    if (currentLayer && layer !== currentLayer) {\n      currentLayer.pause()\n    }\n\n    stack = removeFromStack(stack, layer)\n    stack.unshift(layer)\n  }\n\n  const remove = (layer: FocusLayer) => {\n    stack = removeFromStack(stack, layer)\n    stack[0]?.resume?.()\n  }\n\n  return {\n    push,\n    remove,\n  }\n}\n\nexport const focusFirstDescendant = (\n  elements: HTMLElement[],\n  shouldSelect = false\n) => {\n  const prevFocusedElement = document.activeElement\n  for (const element of elements) {\n    tryFocus(element, shouldSelect)\n    if (document.activeElement !== prevFocusedElement) return\n  }\n}\n\nexport const focusableStack = createFocusableStack()\n\nexport const isFocusCausedByUserEvent = (): boolean => {\n  return lastUserFocusTimestamp.value > lastAutomatedFocusTimestamp.value\n}\n\nconst notifyFocusReasonPointer = () => {\n  focusReason.value = 'pointer'\n  lastUserFocusTimestamp.value = window.performance.now()\n}\n\nconst notifyFocusReasonKeydown = () => {\n  focusReason.value = 'keyboard'\n  lastUserFocusTimestamp.value = window.performance.now()\n}\n\nexport const useFocusReason = (): {\n  focusReason: typeof focusReason\n  lastUserFocusTimestamp: typeof lastUserFocusTimestamp\n  lastAutomatedFocusTimestamp: typeof lastAutomatedFocusTimestamp\n} => {\n  onMounted(() => {\n    if (focusReasonUserCount === 0) {\n      document.addEventListener('mousedown', notifyFocusReasonPointer)\n      document.addEventListener('touchstart', notifyFocusReasonPointer)\n      document.addEventListener('keydown', notifyFocusReasonKeydown)\n    }\n    focusReasonUserCount++\n  })\n\n  onBeforeUnmount(() => {\n    focusReasonUserCount--\n    if (focusReasonUserCount <= 0) {\n      document.removeEventListener('mousedown', notifyFocusReasonPointer)\n      document.removeEventListener('touchstart', notifyFocusReasonPointer)\n      document.removeEventListener('keydown', notifyFocusReasonKeydown)\n    }\n  })\n\n  return {\n    focusReason,\n    lastUserFocusTimestamp,\n    lastAutomatedFocusTimestamp,\n  }\n}\n\nexport const createFocusOutPreventedEvent = (\n  detail: CustomEventInit['detail']\n) => {\n  return new CustomEvent(FOCUSOUT_PREVENTED, {\n    ...FOCUSOUT_PREVENTED_OPTS,\n    detail,\n  })\n}\n"],"mappings":";;;;AAIA,MAAMA,WAAA,GAAcC,GAA4B;AAChD,MAAMC,sBAAA,GAAyBD,GAAA,CAAY,CAAC;AAC5C,MAAME,2BAAA,GAA8BF,GAAA,CAAY,CAAC;AACjD,IAAIG,oBAAuB;AAUd,MAAAC,0BAAA,GACXC,OACkB;EAClB,MAAMC,KAAA,GAAuB,EAAC;EAC9B,MAAMC,MAAS,GAAAC,QAAA,CAASC,gBAAiB,CAAAJ,OAAA,EAASK,UAAA,CAAWC,YAAc;IACzEC,UAAA,EACEC,IAMG;MACH,MAAMC,aAAgB,GAAAD,IAAA,CAAKE,OAAY,gBAAWF,IAAA,CAAKG,IAAS;MAC5D,IAAAH,IAAA,CAAKI,QAAY,IAAAJ,IAAA,CAAKK,MAAU,IAAAJ,aAAA,EAClC,OAAOJ,UAAW,CAAAS,WAAA;MACb,OAAAN,IAAA,CAAKO,QAAA,IAAY,CAAK,IAAAP,IAAA,KAASL,QAAA,CAASa,aAC3C,GAAAX,UAAA,CAAWY,aAAA,GACXZ,UAAW,CAAAS,WAAA;IAAA;EACjB,CACD;EACD,OAAOZ,MAAA,CAAOgB,QAAS,IAASjB,KAAA,CAAAkB,IAAA,CAAKjB,MAAA,CAAOkB,WAA0B;EAE/D,OAAAnB,KAAA;AACT;AAEa,MAAAoB,iBAAA,GAAoBA,CAC/BC,QAAA,EACAC,SACG;EACH,WAAWvB,OAAA,IAAWsB,QAAU;IAC1B,KAACE,QAAS,CAAAxB,OAAA,EAASuB,SAAS,GAAU,OAAAvB,OAAA;EAAA;AAE9C;AAEa,MAAAwB,QAAA,GAAWA,CAACxB,OAAA,EAAsBuB,SAA2B;EACpE,IAAAE,OAAA,CAAQC,GAAA,CAAIC,QAAa,aAAe;EACxC,IAAAC,gBAAA,CAAiB5B,OAAO,EAAE6B,UAAe,eAAiB;EAE9D,OAAO7B,OAAS;IACd,IAAIuB,SAAA,IAAavB,OAAY,KAAAuB,SAAA,EAAkB;IAC3C,IAAAK,gBAAA,CAAiB5B,OAAO,EAAE8B,OAAY,aAAe;IACzD9B,OAAA,GAAUA,OAAQ,CAAA+B,aAAA;EAAA;EAGb;AACT;AAEa,MAAAC,QAAA,GAAYT,SAA2B;EAC5C,MAAAU,SAAA,GAAYlC,0BAAA,CAA2BwB,SAAS;EAChD,MAAAW,KAAA,GAAQb,iBAAkB,CAAAY,SAAA,EAAWV,SAAS;EACpD,MAAMY,IAAO,GAAAd,iBAAA,CAAkBY,SAAU,CAAAG,OAAA,IAAWb,SAAS;EACtD,QAACW,KAAA,EAAOC,IAAI;AACrB;AAEA,MAAME,YAAA,GACJrC,OACyD;EAClD,OAAAA,OAAA,YAAmBsC,gBAAA,IAAoB,QAAY,IAAAtC,OAAA;AAC5D;AAEa,MAAAuC,QAAA,GAAWA,CACtBvC,OAAA,EACAwC,YACG;EACH,IAAIxC,OAAS;IACX,MAAMyC,kBAAA,GAAqBtC,QAAS,CAAAa,aAAA;IAEpC0B,YAAA,CAAa1C,OAAS;MAAE2C,aAAe;IAAA,CAAM;IACjB9C,2BAAA,CAAA+C,KAAA,GAAQC,MAAO,CAAAC,WAAA,CAAYC,GAAI;IAE3D,IACE/C,OAAY,KAAAyC,kBAAA,IACZJ,YAAa,CAAArC,OAAO,KACpBwC,YACA;MACAxC,OAAA,CAAQgD,MAAO;IAAA;EACjB;AAEJ;AAEA,SAASC,gBAAmBC,IAAA,EAAWC,IAAS;EACxC,MAAAC,IAAA,GAAO,CAAC,GAAGF,IAAI;EAEf,MAAAG,GAAA,GAAMH,IAAK,CAAAI,OAAA,CAAQH,IAAI;EAE7B,IAAIE,GAAA,KAAQ,CAAI;IACTD,IAAA,CAAAG,MAAA,CAAOF,GAAA,EAAK,CAAC;EAAA;EAEb,OAAAD,IAAA;AACT;AAEA,MAAMI,oBAAA,GAAuBA,CAAA,KAAM;EACjC,IAAIC,KAAA,GAAQ,EAAC;EAEP,MAAAtC,IAAA,GAAQuC,KAAsB;IAClC,MAAMC,YAAA,GAAeF,KAAM;IAEvB,IAAAE,YAAA,IAAgBD,KAAA,KAAUC,YAAc;MAC1CA,YAAA,CAAaC,KAAM;IAAA;IAGbH,KAAA,GAAAR,eAAA,CAAgBQ,KAAA,EAAOC,KAAK;IACpCD,KAAA,CAAMI,OAAA,CAAQH,KAAK;EAAA,CACrB;EAEM,MAAAI,MAAA,GAAUJ,KAAsB;IA3HxC,IAAAK,EAAA,EAAAC,EAAA;IA4HYP,KAAA,GAAAR,eAAA,CAAgBQ,KAAA,EAAOC,KAAK;IAC9B,CAAAM,EAAA,IAAAD,EAAA,GAAAN,KAAA,QAAN,gBAAAM,EAAA,CAAUE,MAAV,qBAAAD,EAAA,CAAAE,IAAA,CAAAH,EAAA;EAAA,CACF;EAEO;IACL5C,IAAA;IACA2C;EAAA,CACF;AACF;AAEO,MAAMK,oBAAuB,GAAAA,CAClC7C,QACA,EAAAkB,YAAA,GAAe,KACZ;EACH,MAAMC,kBAAA,GAAqBtC,QAAS,CAAAa,aAAA;EACpC,WAAWhB,OAAA,IAAWsB,QAAU;IAC9BiB,QAAA,CAASvC,OAAA,EAASwC,YAAY;IAC9B,IAAIrC,QAAA,CAASa,aAAkB,KAAAyB,kBAAA,EAAoB;EAAA;AAEvD;AAEO,MAAM2B,cAAA,GAAiBZ,oBAAqB;AAE5C,MAAMa,wBAAA,GAA2BA,CAAA,KAAe;EAC9C,OAAAzE,sBAAA,CAAuBgD,KAAA,GAAQ/C,2BAA4B,CAAA+C,KAAA;AACpE;AAEA,MAAM0B,wBAAA,GAA2BA,CAAA,KAAM;EACrC5E,WAAA,CAAYkD,KAAQ;EACGhD,sBAAA,CAAAgD,KAAA,GAAQC,MAAO,CAAAC,WAAA,CAAYC,GAAI;AACxD;AAEA,MAAMwB,wBAAA,GAA2BA,CAAA,KAAM;EACrC7E,WAAA,CAAYkD,KAAQ;EACGhD,sBAAA,CAAAgD,KAAA,GAAQC,MAAO,CAAAC,WAAA,CAAYC,GAAI;AACxD;AAEO,MAAMyB,cAAA,GAAiBA,CAAA,KAIzB;EACHC,SAAA,CAAU,MAAM;IACd,IAAI3E,oBAAA,KAAyB,CAAG;MACrBK,QAAA,CAAAuE,gBAAA,CAAiB,aAAaJ,wBAAwB;MACtDnE,QAAA,CAAAuE,gBAAA,CAAiB,cAAcJ,wBAAwB;MACvDnE,QAAA,CAAAuE,gBAAA,CAAiB,WAAWH,wBAAwB;IAAA;IAE/DzE,oBAAA;EAAA,CACD;EAED6E,eAAA,CAAgB,MAAM;IACpB7E,oBAAA;IACA,IAAIA,oBAAA,IAAwB,CAAG;MACpBK,QAAA,CAAAyE,mBAAA,CAAoB,aAAaN,wBAAwB;MACzDnE,QAAA,CAAAyE,mBAAA,CAAoB,cAAcN,wBAAwB;MAC1DnE,QAAA,CAAAyE,mBAAA,CAAoB,WAAWL,wBAAwB;IAAA;EAClE,CACD;EAEM;IACL7E,WAAA;IACAE,sBAAA;IACAC;EAAA,CACF;AACF;AAEa,MAAAgF,4BAAA,GACXC,MACG;EACI,WAAIC,WAAA,CAAYC,kBAAoB;IACzC,GAAGC,uBAAA;IACHH;EAAA,CACD;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}