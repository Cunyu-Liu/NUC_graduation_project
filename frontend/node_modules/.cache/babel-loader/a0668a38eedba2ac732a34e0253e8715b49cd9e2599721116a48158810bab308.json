{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.reduce.js\";\nimport { defineComponent, getCurrentInstance, inject, watch, onUnmounted, h } from 'vue';\nimport useLayoutObserver from '../layout-observer.mjs';\nimport { removePopper } from '../util.mjs';\nimport { TABLE_INJECTION_KEY } from '../tokens.mjs';\nimport useRender from './render-helper.mjs';\nimport defaultProps from './defaults.mjs';\nimport { useNamespace } from '../../../../hooks/use-namespace/index.mjs';\nimport { addClass, removeClass } from '../../../../utils/dom/style.mjs';\nimport { isClient } from '@vueuse/core';\nimport { rAF } from '../../../../utils/raf.mjs';\nvar TableBody = defineComponent({\n  name: \"ElTableBody\",\n  props: defaultProps,\n  setup(props) {\n    var _a;\n    const instance = getCurrentInstance();\n    const parent = inject(TABLE_INJECTION_KEY);\n    const ns = useNamespace(\"table\");\n    const {\n      wrappedRowRender,\n      tooltipContent,\n      tooltipTrigger\n    } = useRender(props);\n    const {\n      onColumnsChange,\n      onScrollableChange\n    } = useLayoutObserver(parent);\n    const hoveredCellList = [];\n    watch((_a = props.store) == null ? void 0 : _a.states.hoverRow, (newVal, oldVal) => {\n      var _a2, _b;\n      const el = instance == null ? void 0 : instance.vnode.el;\n      const rows = Array.from((el == null ? void 0 : el.children) || []).filter(e => e == null ? void 0 : e.classList.contains(`${ns.e(\"row\")}`));\n      let rowNum = newVal;\n      const childNodes = (_a2 = rows[rowNum]) == null ? void 0 : _a2.childNodes;\n      if (childNodes == null ? void 0 : childNodes.length) {\n        let control = 0;\n        const indexes = Array.from(childNodes).reduce((acc, item, index) => {\n          var _a3, _b2;\n          if (((_a3 = childNodes[index]) == null ? void 0 : _a3.colSpan) > 1) {\n            control = (_b2 = childNodes[index]) == null ? void 0 : _b2.colSpan;\n          }\n          if (item.nodeName !== \"TD\" && control === 0) {\n            acc.push(index);\n          }\n          control > 0 && control--;\n          return acc;\n        }, []);\n        indexes.forEach(rowIndex => {\n          var _a3;\n          rowNum = newVal;\n          while (rowNum > 0) {\n            const preChildNodes = (_a3 = rows[rowNum - 1]) == null ? void 0 : _a3.childNodes;\n            if (preChildNodes[rowIndex] && preChildNodes[rowIndex].nodeName === \"TD\" && preChildNodes[rowIndex].rowSpan > 1) {\n              addClass(preChildNodes[rowIndex], \"hover-cell\");\n              hoveredCellList.push(preChildNodes[rowIndex]);\n              break;\n            }\n            rowNum--;\n          }\n        });\n      } else {\n        hoveredCellList.forEach(item => removeClass(item, \"hover-cell\"));\n        hoveredCellList.length = 0;\n      }\n      if (!((_b = props.store) == null ? void 0 : _b.states.isComplex.value) || !isClient) return;\n      rAF(() => {\n        const oldRow = rows[oldVal];\n        const newRow = rows[newVal];\n        if (oldRow && !oldRow.classList.contains(\"hover-fixed-row\")) {\n          removeClass(oldRow, \"hover-row\");\n        }\n        if (newRow) {\n          addClass(newRow, \"hover-row\");\n        }\n      });\n    });\n    onUnmounted(() => {\n      var _a2;\n      (_a2 = removePopper) == null ? void 0 : _a2();\n    });\n    return {\n      ns,\n      onColumnsChange,\n      onScrollableChange,\n      wrappedRowRender,\n      tooltipContent,\n      tooltipTrigger\n    };\n  },\n  render() {\n    const {\n      wrappedRowRender,\n      store\n    } = this;\n    const data = (store == null ? void 0 : store.states.data.value) || [];\n    return h(\"tbody\", {\n      tabIndex: -1\n    }, [data.reduce((acc, row) => {\n      return acc.concat(wrappedRowRender(row, acc.length));\n    }, [])]);\n  }\n});\nexport { TableBody as default };","map":{"version":3,"names":["TableBody","defineComponent","name","props","defaultProps","setup","_a","instance","getCurrentInstance","parent","inject","TABLE_INJECTION_KEY","ns","useNamespace","wrappedRowRender","tooltipContent","tooltipTrigger","useRender","onColumnsChange","onScrollableChange","useLayoutObserver","hoveredCellList","watch","store","states","hoverRow","newVal","oldVal","_a2","_b","el","vnode","rows","Array","from","children","filter","e","classList","contains","rowNum","childNodes","length","control","indexes","reduce","acc","item","index","_a3","_b2","colSpan","nodeName","push","forEach","rowIndex","preChildNodes","rowSpan","addClass","removeClass","isComplex","value","isClient","rAF","oldRow","newRow","onUnmounted","removePopper","render","data","h","tabIndex","row","concat"],"sources":["../../../../../../../packages/components/table/src/table-body/index.ts"],"sourcesContent":["import {\n  defineComponent,\n  getCurrentInstance,\n  h,\n  inject,\n  onUnmounted,\n  watch,\n} from 'vue'\nimport { addClass, isClient, rAF, removeClass } from '@element-plus/utils'\nimport { useNamespace } from '@element-plus/hooks'\nimport useLayoutObserver from '../layout-observer'\nimport { removePopper } from '../util'\nimport { TABLE_INJECTION_KEY } from '../tokens'\nimport useRender from './render-helper'\nimport defaultProps from './defaults'\n\nimport type { VNode } from 'vue'\n\nexport default defineComponent({\n  name: 'ElTableBody',\n  props: defaultProps,\n  setup(props) {\n    const instance = getCurrentInstance()\n    const parent = inject(TABLE_INJECTION_KEY)\n    const ns = useNamespace('table')\n    const { wrappedRowRender, tooltipContent, tooltipTrigger } =\n      useRender(props)\n    const { onColumnsChange, onScrollableChange } = useLayoutObserver(parent!)\n\n    const hoveredCellList: HTMLTableCellElement[] = []\n    watch(props.store?.states.hoverRow, (newVal: any, oldVal: any) => {\n      const el = instance?.vnode.el as HTMLElement\n      const rows = Array.from(el?.children || []).filter((e) =>\n        e?.classList.contains(`${ns.e('row')}`)\n      )\n\n      // hover rowSpan > 1 choose the whole row\n      let rowNum = newVal\n      const childNodes = rows[rowNum]\n        ?.childNodes as NodeListOf<HTMLTableCellElement>\n      if (childNodes?.length) {\n        let control = 0\n        const indexes = Array.from(childNodes).reduce((acc, item, index) => {\n          // drop colsSpan\n          if (childNodes[index]?.colSpan > 1) {\n            control = childNodes[index]?.colSpan\n          }\n          if (item.nodeName !== 'TD' && control === 0) {\n            acc.push(index)\n          }\n          control > 0 && control--\n          return acc\n        }, [] as number[])\n\n        indexes.forEach((rowIndex) => {\n          rowNum = newVal\n          while (rowNum > 0) {\n            // find from previous\n            const preChildNodes = rows[rowNum - 1]\n              ?.childNodes as NodeListOf<HTMLTableCellElement>\n\n            if (\n              preChildNodes[rowIndex] &&\n              preChildNodes[rowIndex].nodeName === 'TD' &&\n              preChildNodes[rowIndex].rowSpan > 1\n            ) {\n              addClass(preChildNodes[rowIndex], 'hover-cell')\n              hoveredCellList.push(preChildNodes[rowIndex])\n              break\n            }\n            rowNum--\n          }\n        })\n      } else {\n        hoveredCellList.forEach((item) => removeClass(item, 'hover-cell'))\n        hoveredCellList.length = 0\n      }\n      if (!props.store?.states.isComplex.value || !isClient) return\n\n      rAF(() => {\n        // just get first level children; fix #9723\n        const oldRow = rows[oldVal]\n        const newRow = rows[newVal]\n        // when there is fixed row, hover on rowSpan > 1 should not clear the class\n        if (oldRow && !oldRow.classList.contains('hover-fixed-row')) {\n          removeClass(oldRow, 'hover-row')\n        }\n        if (newRow) {\n          addClass(newRow, 'hover-row')\n        }\n      })\n    })\n\n    onUnmounted(() => {\n      removePopper?.()\n    })\n\n    return {\n      ns,\n      onColumnsChange,\n      onScrollableChange,\n      wrappedRowRender,\n      tooltipContent,\n      tooltipTrigger,\n    }\n  },\n  render() {\n    const { wrappedRowRender, store } = this\n    const data = store?.states.data.value || []\n    // Why do we need tabIndex: -1 ?\n    // If you set the tabindex attribute on an element ,\n    // then its child content cannot be scrolled with the arrow keys,\n    // unless you set tabindex on the content too\n    // See https://github.com/facebook/react/issues/25462#issuecomment-1274775248 or https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/tabindex\n    return h('tbody', { tabIndex: -1 }, [\n      data.reduce((acc: VNode[], row) => {\n        return acc.concat(wrappedRowRender(row, acc.length) as VNode[])\n      }, []),\n    ])\n  },\n})\n"],"mappings":";;;;;;;;;;;;;;;AAkBA,IAAAA,SAAA,GAAeC,eAAgB;EAC7BC,IAAM;EACNC,KAAO,EAAAC,YAAA;EACPC,MAAMF,KAAO;IArBf,IAAAG,EAAA;IAsBI,MAAMC,QAAA,GAAWC,kBAAmB;IAC9B,MAAAC,MAAA,GAASC,MAAA,CAAOC,mBAAmB;IACnC,MAAAC,EAAA,GAAKC,YAAA,CAAa,OAAO;IAC/B,MAAM;MAAEC,gBAAkB;MAAAC,cAAA;MAAgBC;IAAe,IACvDC,SAAA,CAAUd,KAAK;IACjB,MAAM;MAAEe,eAAA;MAAiBC;IAAmB,IAAIC,iBAAA,CAAkBX,MAAO;IAEzE,MAAMY,eAAA,GAA0C,EAAC;IACjDC,KAAA,EAAMhB,EAAA,GAAAH,KAAA,CAAMoB,KAAN,qBAAAjB,EAAA,CAAakB,MAAA,CAAOC,QAAU,GAACC,MAAA,EAAaC,MAAgB;MA9BtE,IAAAC,GAAA,EAAAC,EAAA;MA+BY,MAAAC,EAAA,GAAKvB,QAAA,oBAAAA,QAAA,CAAUwB,KAAM,CAAAD,EAAA;MAC3B,MAAME,IAAA,GAAOC,KAAM,CAAAC,IAAA,EAAKJ,EAAA,oBAAAA,EAAA,CAAIK,QAAY,OAAE,CAAE,CAAAC,MAAA,CAAQC,CAAA,IAClDA,CAAG,oBAAAA,CAAA,CAAAC,SAAA,CAAUC,QAAA,CAAS,GAAG3B,EAAA,CAAGyB,CAAA,CAAE,KAAK,KACrC;MAGA,IAAIG,MAAS,GAAAd,MAAA;MACb,MAAMe,UAAa,IAAAb,GAAA,GAAAI,IAAK,CAAAQ,MAAA,MAAL,gBAAAZ,GACf,CAAAa,UAAA;MACJ,IAAIA,UAAA,oBAAAA,UAAA,CAAYC,MAAQ;QACtB,IAAIC,OAAU;QACR,MAAAC,OAAA,GAAUX,KAAA,CAAMC,IAAK,CAAAO,UAAU,EAAEI,MAAO,EAACC,GAAK,EAAAC,IAAA,EAAMC,KAAU;UA1C5E,IAAAC,GAAA,EAAAC,GAAA;UA4CU,MAAID,GAAA,GAAAR,UAAW,CAAAO,KAAA,MAAX,gBAAAC,GAAA,CAAmBE,OAAA,IAAU,CAAG;YAClCR,OAAA,IAAUO,GAAA,GAAAT,UAAA,CAAWO,KAAX,sBAAAE,GAAmB,CAAAC,OAAA;UAAA;UAE/B,IAAIJ,IAAK,CAAAK,QAAA,KAAa,IAAQ,IAAAT,OAAA,KAAY,CAAG;YAC3CG,GAAA,CAAIO,IAAA,CAAKL,KAAK;UAAA;UAEhBL,OAAA,GAAU,CAAK,IAAAA,OAAA;UACR,OAAAG,GAAA;QAAA,CACT,EAAG,EAAc;QAETF,OAAA,CAAAU,OAAA,CAASC,QAAa;UAtDtC,IAAAN,GAAA;UAuDmBT,MAAA,GAAAd,MAAA;UACT,OAAOc,MAAA,GAAS,CAAG;YAEjB,MAAMgB,aAAA,IAAgBP,GAAA,GAAAjB,IAAA,CAAKQ,MAAS,UAAd,gBAAAS,GAClB,CAAAR,UAAA;YAGF,IAAAe,aAAA,CAAcD,QAAA,KACdC,aAAc,CAAAD,QAAA,EAAUH,QAAA,KAAa,IACrC,IAAAI,aAAA,CAAcD,QAAU,EAAAE,OAAA,GAAU,CAClC;cACSC,QAAA,CAAAF,aAAA,CAAcD,QAAA,GAAW,YAAY;cAC9BlC,eAAA,CAAAgC,IAAA,CAAKG,aAAA,CAAcD,QAAS;cAC5C;YAAA;YAEFf,MAAA;UAAA;QACF,CACD;MAAA,CACI;QACLnB,eAAA,CAAgBiC,OAAA,CAASP,IAAA,IAASY,WAAY,CAAAZ,IAAA,EAAM,YAAY,CAAC;QACjE1B,eAAA,CAAgBqB,MAAS;MAAA;MAE3B,IAAI,GAACb,EAAM,GAAA1B,KAAA,CAAAoB,KAAA,KAAN,gBAAAM,EAAA,CAAaL,MAAO,CAAAoC,SAAA,CAAUC,KAAA,KAAS,CAACC,QAAA,EAAU;MAEvDC,GAAA,CAAI,MAAM;QAER,MAAMC,MAAA,GAAShC,IAAK,CAAAL,MAAA;QACpB,MAAMsC,MAAA,GAASjC,IAAK,CAAAN,MAAA;QAEpB,IAAIsC,MAAA,IAAU,CAACA,MAAA,CAAO1B,SAAU,CAAAC,QAAA,CAAS,iBAAiB,CAAG;UAC3DoB,WAAA,CAAYK,MAAA,EAAQ,WAAW;QAAA;QAEjC,IAAIC,MAAQ;UACVP,QAAA,CAASO,MAAA,EAAQ,WAAW;QAAA;MAC9B,CACD;IAAA,CACF;IAEDC,WAAA,CAAY,MAAM;MA7FtB,IAAAtC,GAAA;MA8FM,CAAAA,GAAA,GAAAuC,YAAA,qBAAAvC,GAAA;IAAA,CACD;IAEM;MACLhB,EAAA;MACAM,eAAA;MACAC,kBAAA;MACAL,gBAAA;MACAC,cAAA;MACAC;IAAA,CACF;EAAA,CACF;EACAoD,MAASA,CAAA;IACD;MAAEtD,gBAAkB;MAAAS;IAAA,CAAU;IACpC,MAAM8C,IAAO,IAAA9C,KAAA,oBAAAA,KAAA,CAAOC,MAAO,CAAA6C,IAAA,CAAKR,KAAA,KAAS,EAAC;IAM1C,OAAOS,CAAE,UAAS;MAAEC,QAAA,EAAU;IAAA,CAAM,GAClCF,IAAK,CAAAxB,MAAA,CAAO,CAACC,GAAA,EAAc0B,GAAQ;MACjC,OAAO1B,GAAA,CAAI2B,MAAO,CAAA3D,gBAAA,CAAiB0D,GAAK,EAAA1B,GAAA,CAAIJ,MAAM,CAAY;IAAA,CAChE,EAAG,EAAE,EACN;EAAA;AAEL,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}