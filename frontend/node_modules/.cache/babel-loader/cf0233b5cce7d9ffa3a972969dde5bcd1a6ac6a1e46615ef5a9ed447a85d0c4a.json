{"ast":null,"code":"import \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport { defineComponent, inject, ref, shallowRef, computed, watch, onMounted, onUpdated, triggerRef, createVNode, nextTick } from 'vue';\nimport { useDocumentVisibility, useWindowFocus, useElementSize, useResizeObserver } from '@vueuse/core';\nimport { ElIcon } from '../../icon/index.mjs';\nimport { ArrowLeft, ArrowRight, Close } from '@element-plus/icons-vue';\nimport useWheel from '../../virtual-list/src/hooks/use-wheel.mjs';\nimport { clamp } from 'lodash-unified';\nimport TabBar from './tab-bar2.mjs';\nimport { tabsRootContextKey } from './constants.mjs';\nimport { buildProps, definePropType } from '../../../utils/vue/props/runtime.mjs';\nimport { mutable } from '../../../utils/typescript.mjs';\nimport { throwError } from '../../../utils/error.mjs';\nimport { useNamespace } from '../../../hooks/use-namespace/index.mjs';\nimport { rAF } from '../../../utils/raf.mjs';\nimport { getEventCode } from '../../../utils/dom/event.mjs';\nimport { EVENT_CODE } from '../../../constants/aria.mjs';\nimport { capitalize } from '../../../utils/strings.mjs';\nconst tabNavProps = buildProps({\n  panes: {\n    type: definePropType(Array),\n    default: () => mutable([])\n  },\n  currentName: {\n    type: [String, Number],\n    default: \"\"\n  },\n  editable: Boolean,\n  type: {\n    type: String,\n    values: [\"card\", \"border-card\", \"\"],\n    default: \"\"\n  },\n  stretch: Boolean,\n  tabindex: {\n    type: [String, Number],\n    default: void 0\n  }\n});\nconst tabNavEmits = {\n  tabClick: (tab, tabName, ev) => ev instanceof Event,\n  tabRemove: (tab, ev) => ev instanceof Event\n};\nconst COMPONENT_NAME = \"ElTabNav\";\nconst TabNav = defineComponent({\n  name: COMPONENT_NAME,\n  props: tabNavProps,\n  emits: tabNavEmits,\n  setup(props, {\n    expose,\n    emit\n  }) {\n    const rootTabs = inject(tabsRootContextKey);\n    if (!rootTabs) throwError(COMPONENT_NAME, `<el-tabs><tab-nav /></el-tabs>`);\n    const ns = useNamespace(\"tabs\");\n    const visibility = useDocumentVisibility();\n    const focused = useWindowFocus();\n    const navScroll$ = ref();\n    const nav$ = ref();\n    const el$ = ref();\n    const tabRefsMap = ref({});\n    const tabBarRef = ref();\n    const scrollable = ref(false);\n    const navOffset = ref(0);\n    const isFocus = ref(false);\n    const focusable = ref(true);\n    const tracker = shallowRef();\n    const isHorizontal = computed(() => [\"top\", \"bottom\"].includes(rootTabs.props.tabPosition));\n    const sizeName = computed(() => isHorizontal.value ? \"width\" : \"height\");\n    const navStyle = computed(() => {\n      const dir = sizeName.value === \"width\" ? \"X\" : \"Y\";\n      return {\n        transform: `translate${dir}(-${navOffset.value}px)`\n      };\n    });\n    const {\n      width: navContainerWidth,\n      height: navContainerHeight\n    } = useElementSize(navScroll$);\n    const {\n      width: navWidth,\n      height: navHeight\n    } = useElementSize(nav$, {\n      width: 0,\n      height: 0\n    }, {\n      box: \"border-box\"\n    });\n    const navContainerSize = computed(() => isHorizontal.value ? navContainerWidth.value : navContainerHeight.value);\n    const navSize = computed(() => isHorizontal.value ? navWidth.value : navHeight.value);\n    const {\n      onWheel\n    } = useWheel({\n      atStartEdge: computed(() => navOffset.value <= 0),\n      atEndEdge: computed(() => navSize.value - navOffset.value <= navContainerSize.value),\n      layout: computed(() => isHorizontal.value ? \"horizontal\" : \"vertical\")\n    }, offset => {\n      navOffset.value = clamp(navOffset.value + offset, 0, navSize.value - navContainerSize.value);\n    });\n    const scrollPrev = () => {\n      if (!navScroll$.value) return;\n      const containerSize = navScroll$.value[`offset${capitalize(sizeName.value)}`];\n      const currentOffset = navOffset.value;\n      if (!currentOffset) return;\n      const newOffset = currentOffset > containerSize ? currentOffset - containerSize : 0;\n      navOffset.value = newOffset;\n    };\n    const scrollNext = () => {\n      if (!navScroll$.value || !nav$.value) return;\n      const navSize2 = nav$.value[`offset${capitalize(sizeName.value)}`];\n      const containerSize = navScroll$.value[`offset${capitalize(sizeName.value)}`];\n      const currentOffset = navOffset.value;\n      if (navSize2 - currentOffset <= containerSize) return;\n      const newOffset = navSize2 - currentOffset > containerSize * 2 ? currentOffset + containerSize : navSize2 - containerSize;\n      navOffset.value = newOffset;\n    };\n    const scrollToActiveTab = async () => {\n      const nav = nav$.value;\n      if (!scrollable.value || !el$.value || !navScroll$.value || !nav) return;\n      await nextTick();\n      const activeTab = tabRefsMap.value[props.currentName];\n      if (!activeTab) return;\n      const navScroll = navScroll$.value;\n      const activeTabBounding = activeTab.getBoundingClientRect();\n      const navScrollBounding = navScroll.getBoundingClientRect();\n      const maxOffset = isHorizontal.value ? nav.offsetWidth - navScrollBounding.width : nav.offsetHeight - navScrollBounding.height;\n      const currentOffset = navOffset.value;\n      let newOffset = currentOffset;\n      if (isHorizontal.value) {\n        if (activeTabBounding.left < navScrollBounding.left) {\n          newOffset = currentOffset - (navScrollBounding.left - activeTabBounding.left);\n        }\n        if (activeTabBounding.right > navScrollBounding.right) {\n          newOffset = currentOffset + activeTabBounding.right - navScrollBounding.right;\n        }\n      } else {\n        if (activeTabBounding.top < navScrollBounding.top) {\n          newOffset = currentOffset - (navScrollBounding.top - activeTabBounding.top);\n        }\n        if (activeTabBounding.bottom > navScrollBounding.bottom) {\n          newOffset = currentOffset + (activeTabBounding.bottom - navScrollBounding.bottom);\n        }\n      }\n      newOffset = Math.max(newOffset, 0);\n      navOffset.value = Math.min(newOffset, maxOffset);\n    };\n    const update = () => {\n      var _a;\n      if (!nav$.value || !navScroll$.value) return;\n      props.stretch && ((_a = tabBarRef.value) == null ? void 0 : _a.update());\n      const navSize2 = nav$.value[`offset${capitalize(sizeName.value)}`];\n      const containerSize = navScroll$.value[`offset${capitalize(sizeName.value)}`];\n      const currentOffset = navOffset.value;\n      if (containerSize < navSize2) {\n        scrollable.value = scrollable.value || {};\n        scrollable.value.prev = currentOffset;\n        scrollable.value.next = currentOffset + containerSize < navSize2;\n        if (navSize2 - currentOffset < containerSize) {\n          navOffset.value = navSize2 - containerSize;\n        }\n      } else {\n        scrollable.value = false;\n        if (currentOffset > 0) {\n          navOffset.value = 0;\n        }\n      }\n    };\n    const changeTab = event => {\n      const code = getEventCode(event);\n      let step = 0;\n      switch (code) {\n        case EVENT_CODE.left:\n        case EVENT_CODE.up:\n          step = -1;\n          break;\n        case EVENT_CODE.right:\n        case EVENT_CODE.down:\n          step = 1;\n          break;\n        default:\n          return;\n      }\n      const tabList = Array.from(event.currentTarget.querySelectorAll(\"[role=tab]:not(.is-disabled)\"));\n      const currentIndex = tabList.indexOf(event.target);\n      let nextIndex = currentIndex + step;\n      if (nextIndex < 0) {\n        nextIndex = tabList.length - 1;\n      } else if (nextIndex >= tabList.length) {\n        nextIndex = 0;\n      }\n      tabList[nextIndex].focus({\n        preventScroll: true\n      });\n      tabList[nextIndex].click();\n      setFocus();\n    };\n    const setFocus = () => {\n      if (focusable.value) isFocus.value = true;\n    };\n    const removeFocus = () => isFocus.value = false;\n    const setRefs = (el, key) => {\n      tabRefsMap.value[key] = el;\n    };\n    const focusActiveTab = async () => {\n      await nextTick();\n      const activeTab = tabRefsMap.value[props.currentName];\n      activeTab == null ? void 0 : activeTab.focus({\n        preventScroll: true\n      });\n    };\n    watch(visibility, visibility2 => {\n      if (visibility2 === \"hidden\") {\n        focusable.value = false;\n      } else if (visibility2 === \"visible\") {\n        setTimeout(() => focusable.value = true, 50);\n      }\n    });\n    watch(focused, focused2 => {\n      if (focused2) {\n        setTimeout(() => focusable.value = true, 50);\n      } else {\n        focusable.value = false;\n      }\n    });\n    useResizeObserver(el$, () => {\n      rAF(update);\n    });\n    onMounted(() => setTimeout(() => scrollToActiveTab(), 0));\n    onUpdated(() => update());\n    expose({\n      scrollToActiveTab,\n      removeFocus,\n      focusActiveTab,\n      tabListRef: nav$,\n      tabBarRef,\n      scheduleRender: () => triggerRef(tracker)\n    });\n    return () => {\n      const scrollBtn = scrollable.value ? [createVNode(\"span\", {\n        \"class\": [ns.e(\"nav-prev\"), ns.is(\"disabled\", !scrollable.value.prev)],\n        \"onClick\": scrollPrev\n      }, [createVNode(ElIcon, null, {\n        default: () => [createVNode(ArrowLeft, null, null)]\n      })]), createVNode(\"span\", {\n        \"class\": [ns.e(\"nav-next\"), ns.is(\"disabled\", !scrollable.value.next)],\n        \"onClick\": scrollNext\n      }, [createVNode(ElIcon, null, {\n        default: () => [createVNode(ArrowRight, null, null)]\n      })])] : null;\n      const tabs = props.panes.map((pane, index) => {\n        var _a, _b, _c, _d, _e;\n        const uid = pane.uid;\n        const disabled = pane.props.disabled;\n        const tabName = (_b = (_a = pane.props.name) != null ? _a : pane.index) != null ? _b : `${index}`;\n        const closable = !disabled && (pane.isClosable || pane.props.closable !== false && props.editable);\n        pane.index = `${index}`;\n        const btnClose = closable ? createVNode(ElIcon, {\n          \"class\": \"is-icon-close\",\n          \"onClick\": ev => emit(\"tabRemove\", pane, ev)\n        }, {\n          default: () => [createVNode(Close, null, null)]\n        }) : null;\n        const tabLabelContent = ((_d = (_c = pane.slots).label) == null ? void 0 : _d.call(_c)) || pane.props.label;\n        const tabindex = !disabled && pane.active ? (_e = props.tabindex) != null ? _e : rootTabs.props.tabindex : -1;\n        return createVNode(\"div\", {\n          \"ref\": el => setRefs(el, tabName),\n          \"class\": [ns.e(\"item\"), ns.is(rootTabs.props.tabPosition), ns.is(\"active\", pane.active), ns.is(\"disabled\", disabled), ns.is(\"closable\", closable), ns.is(\"focus\", isFocus.value)],\n          \"id\": `tab-${tabName}`,\n          \"key\": `tab-${uid}`,\n          \"aria-controls\": `pane-${tabName}`,\n          \"role\": \"tab\",\n          \"aria-selected\": pane.active,\n          \"tabindex\": tabindex,\n          \"onFocus\": () => setFocus(),\n          \"onBlur\": () => removeFocus(),\n          \"onClick\": ev => {\n            removeFocus();\n            emit(\"tabClick\", pane, tabName, ev);\n          },\n          \"onKeydown\": ev => {\n            const code = getEventCode(ev);\n            if (closable && (code === EVENT_CODE.delete || code === EVENT_CODE.backspace)) {\n              emit(\"tabRemove\", pane, ev);\n            }\n          }\n        }, [...[tabLabelContent, btnClose]]);\n      });\n      tracker.value;\n      return createVNode(\"div\", {\n        \"ref\": el$,\n        \"class\": [ns.e(\"nav-wrap\"), ns.is(\"scrollable\", !!scrollable.value), ns.is(rootTabs.props.tabPosition)]\n      }, [scrollBtn, createVNode(\"div\", {\n        \"class\": ns.e(\"nav-scroll\"),\n        \"ref\": navScroll$\n      }, [props.panes.length > 0 ? createVNode(\"div\", {\n        \"class\": [ns.e(\"nav\"), ns.is(rootTabs.props.tabPosition), ns.is(\"stretch\", props.stretch && [\"top\", \"bottom\"].includes(rootTabs.props.tabPosition))],\n        \"ref\": nav$,\n        \"style\": navStyle.value,\n        \"role\": \"tablist\",\n        \"onKeydown\": changeTab,\n        \"onWheel\": onWheel\n      }, [...[!props.type ? createVNode(TabBar, {\n        \"ref\": tabBarRef,\n        \"tabs\": [...props.panes],\n        \"tabRefs\": tabRefsMap.value\n      }, null) : null, tabs]]) : null])]);\n    };\n  }\n});\nexport { TabNav as default, tabNavEmits, tabNavProps };","map":{"version":3,"names":["tabNavProps","buildProps","panes","type","definePropType","Array","default","mutable","currentName","String","Number","editable","Boolean","values","stretch","tabindex","tabNavEmits","tabClick","tab","tabName","ev","Event","tabRemove","COMPONENT_NAME","TabNav","defineComponent","name","props","emits","setup","expose","emit","rootTabs","inject","tabsRootContextKey","throwError","ns","useNamespace","visibility","useDocumentVisibility","focused","useWindowFocus","navScroll$","ref","nav$","el$","tabRefsMap","tabBarRef","scrollable","navOffset","isFocus","focusable","tracker","shallowRef","isHorizontal","computed","includes","tabPosition","sizeName","value","navStyle","dir","transform","width","navContainerWidth","height","navContainerHeight","useElementSize","navWidth","navHeight","box","navContainerSize","navSize","onWheel","useWheel","atStartEdge","atEndEdge","layout","offset","clamp","scrollPrev","containerSize","capitalize","currentOffset","newOffset","scrollNext","navSize2","scrollToActiveTab","nav","nextTick","activeTab","navScroll","activeTabBounding","getBoundingClientRect","navScrollBounding","maxOffset","offsetWidth","offsetHeight","left","right","top","bottom","Math","max","min","update","_a","prev","next","changeTab","event","code","getEventCode","step","EVENT_CODE","up","down","tabList","from","currentTarget","querySelectorAll","currentIndex","indexOf","target","nextIndex","length","focus","preventScroll","click","setFocus","removeFocus","setRefs","el","key","focusActiveTab","watch","visibility2","setTimeout","focused2","useResizeObserver","rAF","onMounted","onUpdated","tabListRef","scheduleRender","triggerRef","scrollBtn","createVNode","e","is","ElIcon","ArrowLeft","ArrowRight","tabs","map","pane","index","_b","_c","_d","_e","uid","disabled","closable","isClosable","btnClose","Close","tabLabelContent","slots","label","call","active","onFocus","onBlur","delete","backspace","TabBar"],"sources":["../../../../../../packages/components/tabs/src/tab-nav.tsx"],"sourcesContent":["import {\n  computed,\n  defineComponent,\n  inject,\n  nextTick,\n  onMounted,\n  onUpdated,\n  ref,\n  shallowRef,\n  triggerRef,\n  watch,\n} from 'vue'\nimport {\n  useDocumentVisibility,\n  useElementSize,\n  useResizeObserver,\n  useWindowFocus,\n} from '@vueuse/core'\nimport {\n  buildProps,\n  capitalize,\n  definePropType,\n  getEventCode,\n  mutable,\n  rAF,\n  throwError,\n} from '@element-plus/utils'\nimport { EVENT_CODE } from '@element-plus/constants'\nimport { ElIcon } from '@element-plus/components/icon'\nimport { ArrowLeft, ArrowRight, Close } from '@element-plus/icons-vue'\nimport { useNamespace } from '@element-plus/hooks'\nimport useWheel from '@element-plus/components/virtual-list/src/hooks/use-wheel'\nimport { clamp } from 'lodash-unified'\nimport TabBar from './tab-bar.vue'\nimport { tabsRootContextKey } from './constants'\n\nimport type {\n  CSSProperties,\n  ComponentPublicInstance,\n  ExtractPropTypes,\n  ExtractPublicPropTypes,\n} from 'vue'\nimport type { TabBarInstance } from './tab-bar'\nimport type { TabPaneName, TabsPaneContext } from './constants'\n\ninterface Scrollable {\n  next?: boolean\n  prev?: number\n}\n\nexport const tabNavProps = buildProps({\n  panes: {\n    type: definePropType<TabsPaneContext[]>(Array),\n    default: () => mutable([] as const),\n  },\n  currentName: {\n    type: [String, Number],\n    default: '',\n  },\n  editable: Boolean,\n  type: {\n    type: String,\n    values: ['card', 'border-card', ''],\n    default: '',\n  },\n  stretch: Boolean,\n  /**\n   * @description tab-nav tabindex\n   */\n  tabindex: {\n    type: [String, Number],\n    default: undefined,\n  },\n} as const)\n\nexport const tabNavEmits = {\n  tabClick: (tab: TabsPaneContext, tabName: TabPaneName, ev: Event) =>\n    ev instanceof Event,\n  tabRemove: (tab: TabsPaneContext, ev: Event) => ev instanceof Event,\n}\n\nexport type TabNavProps = ExtractPropTypes<typeof tabNavProps>\nexport type TabNavPropsPublic = ExtractPublicPropTypes<typeof tabNavProps>\nexport type TabNavEmits = typeof tabNavEmits\n\nconst COMPONENT_NAME = 'ElTabNav'\nconst TabNav = defineComponent({\n  name: COMPONENT_NAME,\n  props: tabNavProps,\n  emits: tabNavEmits,\n  setup(props, { expose, emit }) {\n    const rootTabs = inject(tabsRootContextKey)\n    if (!rootTabs) throwError(COMPONENT_NAME, `<el-tabs><tab-nav /></el-tabs>`)\n\n    const ns = useNamespace('tabs')\n    const visibility = useDocumentVisibility()\n    const focused = useWindowFocus()\n\n    const navScroll$ = ref<HTMLDivElement>()\n    const nav$ = ref<HTMLDivElement>()\n    const el$ = ref<HTMLDivElement>()\n    const tabRefsMap = ref<{ [key: TabPaneName]: HTMLDivElement }>({})\n\n    const tabBarRef = ref<TabBarInstance>()\n\n    const scrollable = ref<false | Scrollable>(false)\n    const navOffset = ref(0)\n    const isFocus = ref(false)\n    const focusable = ref(true)\n    const tracker = shallowRef()\n\n    const isHorizontal = computed(() =>\n      ['top', 'bottom'].includes(rootTabs.props.tabPosition)\n    )\n\n    const sizeName = computed(() => (isHorizontal.value ? 'width' : 'height'))\n    const navStyle = computed<CSSProperties>(() => {\n      const dir = sizeName.value === 'width' ? 'X' : 'Y'\n      return {\n        transform: `translate${dir}(-${navOffset.value}px)`,\n      }\n    })\n\n    const { width: navContainerWidth, height: navContainerHeight } =\n      useElementSize(navScroll$)\n    const { width: navWidth, height: navHeight } = useElementSize(\n      nav$,\n      { width: 0, height: 0 },\n      { box: 'border-box' }\n    )\n\n    const navContainerSize = computed(() =>\n      isHorizontal.value ? navContainerWidth.value : navContainerHeight.value\n    )\n    const navSize = computed(() =>\n      isHorizontal.value ? navWidth.value : navHeight.value\n    )\n\n    const { onWheel } = useWheel(\n      {\n        atStartEdge: computed(() => navOffset.value <= 0),\n        atEndEdge: computed(\n          () => navSize.value - navOffset.value <= navContainerSize.value\n        ),\n        layout: computed(() =>\n          isHorizontal.value ? 'horizontal' : 'vertical'\n        ),\n      },\n      (offset) => {\n        navOffset.value = clamp(\n          navOffset.value + offset,\n          0,\n          navSize.value - navContainerSize.value\n        )\n      }\n    )\n\n    const scrollPrev = () => {\n      if (!navScroll$.value) return\n\n      const containerSize =\n        navScroll$.value[`offset${capitalize(sizeName.value)}`]\n      const currentOffset = navOffset.value\n\n      if (!currentOffset) return\n\n      const newOffset =\n        currentOffset > containerSize ? currentOffset - containerSize : 0\n\n      navOffset.value = newOffset\n    }\n\n    const scrollNext = () => {\n      if (!navScroll$.value || !nav$.value) return\n\n      const navSize = nav$.value[`offset${capitalize(sizeName.value)}`]\n      const containerSize =\n        navScroll$.value[`offset${capitalize(sizeName.value)}`]\n      const currentOffset = navOffset.value\n\n      if (navSize - currentOffset <= containerSize) return\n\n      const newOffset =\n        navSize - currentOffset > containerSize * 2\n          ? currentOffset + containerSize\n          : navSize - containerSize\n\n      navOffset.value = newOffset\n    }\n\n    const scrollToActiveTab = async () => {\n      const nav = nav$.value\n      if (!scrollable.value || !el$.value || !navScroll$.value || !nav) return\n\n      await nextTick()\n\n      const activeTab = tabRefsMap.value[props.currentName]\n      if (!activeTab) return\n\n      const navScroll = navScroll$.value\n\n      const activeTabBounding = activeTab.getBoundingClientRect()\n      const navScrollBounding = navScroll.getBoundingClientRect()\n      const maxOffset = isHorizontal.value\n        ? nav.offsetWidth - navScrollBounding.width\n        : nav.offsetHeight - navScrollBounding.height\n      const currentOffset = navOffset.value\n      let newOffset = currentOffset\n\n      if (isHorizontal.value) {\n        if (activeTabBounding.left < navScrollBounding.left) {\n          newOffset =\n            currentOffset - (navScrollBounding.left - activeTabBounding.left)\n        }\n        if (activeTabBounding.right > navScrollBounding.right) {\n          newOffset =\n            currentOffset + activeTabBounding.right - navScrollBounding.right\n        }\n      } else {\n        if (activeTabBounding.top < navScrollBounding.top) {\n          newOffset =\n            currentOffset - (navScrollBounding.top - activeTabBounding.top)\n        }\n        if (activeTabBounding.bottom > navScrollBounding.bottom) {\n          newOffset =\n            currentOffset +\n            (activeTabBounding.bottom - navScrollBounding.bottom)\n        }\n      }\n      newOffset = Math.max(newOffset, 0)\n      navOffset.value = Math.min(newOffset, maxOffset)\n    }\n\n    const update = () => {\n      if (!nav$.value || !navScroll$.value) return\n\n      props.stretch && tabBarRef.value?.update()\n\n      const navSize = nav$.value[`offset${capitalize(sizeName.value)}`]\n      const containerSize =\n        navScroll$.value[`offset${capitalize(sizeName.value)}`]\n      const currentOffset = navOffset.value\n\n      if (containerSize < navSize) {\n        scrollable.value = scrollable.value || {}\n        scrollable.value.prev = currentOffset\n        scrollable.value.next = currentOffset + containerSize < navSize\n        if (navSize - currentOffset < containerSize) {\n          navOffset.value = navSize - containerSize\n        }\n      } else {\n        scrollable.value = false\n        if (currentOffset > 0) {\n          navOffset.value = 0\n        }\n      }\n    }\n\n    const changeTab = (event: KeyboardEvent) => {\n      const code = getEventCode(event)\n      let step = 0\n\n      switch (code) {\n        case EVENT_CODE.left:\n        case EVENT_CODE.up:\n          step = -1\n          break\n        case EVENT_CODE.right:\n        case EVENT_CODE.down:\n          step = 1\n          break\n        default:\n          return\n      }\n\n      const tabList = Array.from(\n        (\n          event.currentTarget as HTMLDivElement\n        ).querySelectorAll<HTMLDivElement>('[role=tab]:not(.is-disabled)')\n      )\n      const currentIndex = tabList.indexOf(event.target as HTMLDivElement)\n      let nextIndex = currentIndex + step\n\n      if (nextIndex < 0) {\n        nextIndex = tabList.length - 1\n      } else if (nextIndex >= tabList.length) {\n        nextIndex = 0\n      }\n\n      tabList[nextIndex].focus({ preventScroll: true }) // 改变焦点元素\n      tabList[nextIndex].click() // 选中下一个tab\n      setFocus()\n    }\n\n    const setFocus = () => {\n      if (focusable.value) isFocus.value = true\n    }\n    const removeFocus = () => (isFocus.value = false)\n\n    const setRefs = (\n      el: Element | ComponentPublicInstance | null,\n      key: TabPaneName\n    ) => {\n      tabRefsMap.value[key] = el as HTMLDivElement\n    }\n\n    const focusActiveTab = async () => {\n      await nextTick()\n\n      const activeTab = tabRefsMap.value[props.currentName]\n      activeTab?.focus({ preventScroll: true })\n    }\n\n    watch(visibility, (visibility) => {\n      if (visibility === 'hidden') {\n        focusable.value = false\n      } else if (visibility === 'visible') {\n        setTimeout(() => (focusable.value = true), 50)\n      }\n    })\n    watch(focused, (focused) => {\n      if (focused) {\n        setTimeout(() => (focusable.value = true), 50)\n      } else {\n        focusable.value = false\n      }\n    })\n\n    useResizeObserver(el$, () => {\n      rAF(update)\n    })\n\n    onMounted(() => setTimeout(() => scrollToActiveTab(), 0))\n    onUpdated(() => update())\n\n    expose({\n      scrollToActiveTab,\n      removeFocus,\n      focusActiveTab,\n      tabListRef: nav$,\n      tabBarRef,\n      scheduleRender: () => triggerRef(tracker),\n    })\n\n    return () => {\n      const scrollBtn = scrollable.value\n        ? [\n            <span\n              class={[\n                ns.e('nav-prev'),\n                ns.is('disabled', !scrollable.value.prev),\n              ]}\n              onClick={scrollPrev}\n            >\n              <ElIcon>\n                <ArrowLeft />\n              </ElIcon>\n            </span>,\n            <span\n              class={[\n                ns.e('nav-next'),\n                ns.is('disabled', !scrollable.value.next),\n              ]}\n              onClick={scrollNext}\n            >\n              <ElIcon>\n                <ArrowRight />\n              </ElIcon>\n            </span>,\n          ]\n        : null\n\n      const tabs = props.panes.map((pane, index) => {\n        const uid = pane.uid\n        const disabled = pane.props.disabled\n        const tabName = pane.props.name ?? pane.index ?? `${index}`\n        const closable =\n          !disabled &&\n          (pane.isClosable || (pane.props.closable !== false && props.editable))\n        pane.index = `${index}`\n\n        const btnClose = closable ? (\n          <ElIcon\n            class=\"is-icon-close\"\n            // `onClick` not exist when generate dts\n\n            // @ts-ignore\n            onClick={(ev: MouseEvent) => emit('tabRemove', pane, ev)}\n          >\n            <Close />\n          </ElIcon>\n        ) : null\n\n        const tabLabelContent = pane.slots.label?.() || pane.props.label\n        const tabindex =\n          !disabled && pane.active\n            ? (props.tabindex ?? rootTabs.props.tabindex)\n            : -1\n\n        return (\n          <div\n            ref={(el) => setRefs(el, tabName)}\n            class={[\n              ns.e('item'),\n              ns.is(rootTabs.props.tabPosition),\n              ns.is('active', pane.active),\n              ns.is('disabled', disabled),\n              ns.is('closable', closable),\n              ns.is('focus', isFocus.value),\n            ]}\n            id={`tab-${tabName}`}\n            key={`tab-${uid}`}\n            aria-controls={`pane-${tabName}`}\n            role=\"tab\"\n            aria-selected={pane.active}\n            tabindex={tabindex}\n            onFocus={() => setFocus()}\n            onBlur={() => removeFocus()}\n            onClick={(ev: MouseEvent) => {\n              removeFocus()\n              emit('tabClick', pane, tabName, ev)\n            }}\n            onKeydown={(ev: KeyboardEvent) => {\n              const code = getEventCode(ev)\n              if (\n                closable &&\n                (code === EVENT_CODE.delete || code === EVENT_CODE.backspace)\n              ) {\n                emit('tabRemove', pane, ev)\n              }\n            }}\n          >\n            {...[tabLabelContent, btnClose]}\n          </div>\n        )\n      })\n\n      // By tracking the value property, we can schedule a job to re-render `TabNav` when needed.\n      // Unlike `instance.update`, the scheduler ensures the job is queued only once even if we trigger it multiple times.\n      tracker.value\n\n      return (\n        <div\n          ref={el$}\n          class={[\n            ns.e('nav-wrap'),\n            ns.is('scrollable', !!scrollable.value),\n            ns.is(rootTabs.props.tabPosition),\n          ]}\n        >\n          {scrollBtn}\n          <div class={ns.e('nav-scroll')} ref={navScroll$}>\n            {props.panes.length > 0 ? (\n              <div\n                class={[\n                  ns.e('nav'),\n                  ns.is(rootTabs.props.tabPosition),\n                  ns.is(\n                    'stretch',\n                    props.stretch &&\n                      ['top', 'bottom'].includes(rootTabs.props.tabPosition)\n                  ),\n                ]}\n                ref={nav$}\n                style={navStyle.value}\n                role=\"tablist\"\n                onKeydown={changeTab}\n                onWheel={onWheel}\n              >\n                {...[\n                  !props.type ? (\n                    <TabBar\n                      ref={tabBarRef}\n                      tabs={[...props.panes]}\n                      tabRefs={tabRefsMap.value}\n                    />\n                  ) : null,\n                  tabs,\n                ]}\n              </div>\n            ) : null}\n          </div>\n        </div>\n      )\n    }\n  },\n})\n\nexport type TabNavInstance = InstanceType<typeof TabNav> & {\n  scrollToActiveTab: () => Promise<void>\n  removeFocus: () => void\n  focusActiveTab: () => void\n  scheduleRender: () => void\n  tabListRef: HTMLDivElement | undefined\n  tabBarRef: TabBarInstance | undefined\n}\n\nexport default TabNav\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}